<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LogUtils</name>
    </assembly>
    <members>
        <member name="T:LogUtils.BackupListener">
            <summary>
            Provides a means for mods to listen for log backup opportunity signals
            </summary>
        </member>
        <member name="E:LogUtils.BackupListener.Feed">
            <summary>
            Allows subscribers access to all recent, and future backup records
            </summary>
        </member>
        <member name="F:LogUtils.BackupListener.EventRecord.LogFile">
            <summary>
            Backup target
            </summary>
        </member>
        <member name="F:LogUtils.BackupListener.EventRecord.SourcePath">
            <summary>
            The primary source path to the temporary file
            </summary>
        </member>
        <member name="F:LogUtils.BackupListener.EventRecord.BackupPaths">
            <summary>
            Contains source paths for log backups created by other mods (use in case the file is no longer at the primary source path)
            </summary>
        </member>
        <member name="F:LogUtils.ChangeState.FieldState">
            <summary>
            The value of the field when the state was created
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Capacity">
            <summary>
            The amount of nodes managed by the node leaser
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.First">
            <inheritdoc cref="P:System.Collections.Generic.LinkedList`1.First"/>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Last">
            <inheritdoc cref="P:System.Collections.Generic.LinkedList`1.Last"/>
        </member>
        <member name="F:LogUtils.Collections.BufferedLinkedList`1.AllowModificationsDuringIteration">
            <summary>
            Enable or disable collection modification protection
            </summary>
            <remarks>This is essentially deprecated</remarks>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.#ctor(System.Int32)">
            <summary>
            Construct a BufferedLinkedList object
            </summary>
            <param name="capacity">The amount of nodes to maintain in the leaser by default</param>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnsureCapacity">
            <summary>
            Ensure that there are always nodes available in the node leaser
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.AddFirst(`0)">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.AddFirst(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.AddLast(`0)">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.AddLast(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.AddBefore(System.Collections.Generic.LinkedListNode{`0},`0)">
            <summary>
            Adds the specified value to a new node before the specified existing node
            </summary>
            <returns>The node storing the specified value</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},`0)">
            <summary>
            Adds the specified value to a new node after the specified existing node
            </summary>
            <returns>The node storing the specified value</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Find(`0)">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.Find(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.FindLast(`0)">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.FindLast(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Remove(System.Collections.Generic.LinkedListNode{`0})">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.Remove(System.Collections.Generic.LinkedListNode{`0})"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.RemoveFirst">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.RemoveLast">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.RemoveLast"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Where(System.Func{`0,System.Boolean})">
            <summary>
            Performs a Where query using the given predicate
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.GetLinkedListEnumerator">
            <summary>
            Returns an enumerator specially designed to enumerate through this collection
            </summary>
        </member>
        <member name="T:LogUtils.Collections.BufferedLinkedList`1.Enumerator">
            <summary>
            The specialized enumerator for BufferedLinkedList
            </summary>
        </member>
        <member name="F:LogUtils.Collections.BufferedLinkedList`1.Enumerator.refNode">
            <summary>
            This is the node that controls the reference to the Current node
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Enumerator.CurrentNode">
            <summary>
            The LinkedListNode associated with Current
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Enumerator.#ctor(LogUtils.Collections.BufferedLinkedList{`0})">
            <summary>
            Constructs an Enumerator struct
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Enumerator.Dispose">
            <summary>
            Resets enumerator to a default state
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Enumerator.Reset">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper">
            <summary>
            A simple wrapper for handling an IEnumerable similarly to an ILinkedListEnumerable despite not having the same functionality as one
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.CurrentNode">
            <summary>
            Not implemented by design - data is unavailable
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.Current">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Constructs an EnumeratorWrapper struct
            </summary>
            <param name="enumerator">The enumerator that is intended to be wrapped</param>
            <exception cref="T:System.ArgumentNullException">Enumerator is null</exception>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.Dispose">
            <summary>
            Resets enumerator to a default state
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.Reset">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerableWrapper.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerable.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerable.GetLinkedListEnumerator">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.CurrentNode">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.Current">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.Dispose">
            <summary>
            Resets enumerator to a default state
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.Reset">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ILinkedListEnumerable`1.GetLinkedListEnumerator">
            <summary>
            Returns an enumerator designed to iterate through a LinkedList
            </summary>
        </member>
        <member name="P:LogUtils.Collections.ILinkedListEnumerator`1.CurrentNode">
            <summary>
            The LinkedListNode associated with Current
            </summary>
        </member>
        <member name="T:LogUtils.Collections.ValueCollection`1">
            <summary>
            A hashset wrapper class with built-in ReadOnly support from a bindable source
            </summary>
            <remarks>Class is mainly designed to keep user changes to LogProperties safe from modification </remarks>
        </member>
        <member name="P:LogUtils.Collections.ValueCollection`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Collections.ValueCollection`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Collections.ValueCollection`1.Values">
            <summary>
            The underlying dataset
            </summary>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.#ctor(LogUtils.Collections.ReadOnlyProvider)">
            <summary>
            Creates a new <see cref="T:LogUtils.Collections.ValueCollection`1"/> instance
            </summary>
            <param name="readOnlySource">The binding source for determining the ReadOnly state of the collection</param>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all elements from a collection of elements skipping over any duplicated elements in the collection
            </summary>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Reset">
            <summary>
            Changes collection back to its initial state
            </summary>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.Add(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.RemoveCollectedEntries">
            <summary>
            Remove entries that have been collected by the Garbage Collector
            </summary>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.UnsafeCount">
            <summary>
            Returns the count of all entries in the collection, reference collected, or otherwise
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.AdapterServices.Convert(BepInEx.Logging.ManualLogSource)">
            <summary>
            Creates a wrapper object that can interface with a ManualLogSource
            </summary>
            <exception cref="T:System.ArgumentNullException">Provided source is null</exception>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.BepInExAdapter">
            <summary>
            Adapter service for converting the BepInEx logging system to the system that LogUtils operates
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExAdapter.AdaptLoggingSystem">
            <summary>
            Transitions the BepInEx logging system, and data over to the system operated by LogUtils
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExAdapter.CleanBepInExFolder">
            <summary>
            Detects, and removes log file copies in the original BepInEx logs folder directory
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExAdapter.RetroactivelyApplyRules(System.String)">
            <summary>
            Applies log rules to already logged messages, overwriting the existing file with the new changes
            </summary>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.BepInExInfo">
            <summary>
            Contains references to state controlled by BepInEx
            </summary>
        </member>
        <member name="P:LogUtils.Compatibility.BepInEx.BepInExInfo.ManagerObject">
            <summary>
            The GameObject that contains the game, and all modded assemblies
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.Close(BepInEx.Logging.ILogListener)">
            <summary>
            Removes listener from BepInEx Listeners collection, and disposes the listener instance
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.Find``1">
            <summary>
            Finds the first ILogListener of a given type, or null if not found
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.GetPlugin(System.Reflection.Assembly)">
            <summary>
            Gets the plugin instance associated with the provided assembly
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.GetPluginInfo(System.Reflection.Assembly)">
            <summary>
            Gets the PluginInfo instance associated with the provided assembly
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.GetPluginMetadata(System.Reflection.Assembly)">
            <summary>
            Gets the plugin metadata associated with the provided assembly
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.BepInExLogger.Source">
            <summary>
            BepInEx derived logging interface
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogDebug(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogInfo(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogImportant(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogMessage(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogWarning(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogError(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogFatal(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogDebug(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogInfo(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogImportant(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogMessage(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogWarning(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogError(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogFatal(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.Config">
            <summary>
            Config values inherited from BepInEx
            </summary>
            <remarks>Changing these settings may not have an effect on LogUtils functionality</remarks>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.Base">
            <summary>
            Contains the BepInEx Core config instance
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.AllowConsole">
            <summary>
            Config setting affecting whether the a console is displayed when BepInEx loads
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.AllowLoggingToFile">
            <summary>
            Config setting affecting whether any logs make it to file, error logging excluded
            </summary>
            <remarks>Needs implementation</remarks>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.AllowUnityLogging">
            <summary>
            Config setting enabling, or disabling Unity logging
            </summary>
            <remarks>LogUtils provides this functionality through the properties file. Config option is unnecessary</remarks>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.AppendLogEntries">
            <summary>
            Config setting affecting whether the BepInEx log file gets replaced when BepInEx loads
            </summary>
            <remarks>LogUtils doesn't support this behavior yet</remarks>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.SendUnityLogsToOutputLog">
            <summary>
            Config setting affecting whether Unity logs also appear in the BepInEx output log file
            </summary>
            <remarks>LogUtils doesn't support this yet</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.Config.InitializeEntries">
            <summary>
            Config setting affecting whether Unity logs appear in the BepInEx console
            </summary>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.IExtendedLogSource">
            <summary>
            Represents a type that implements both ILogger, and ILogSource
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Writer">
            <summary>
            This writer handles all BepInEx log traffic for Rain World
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.utilityRequestsInProcess">
            <summary>
            Stores LogUtils requests until they are able to be handled
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Dispose">
            <inheritdoc cref="M:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Dispose(System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Finalize">
            <summary/>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.ManualLogSourceWrapper">
            <summary>
            A class dedicated to translating a ManualLogSource to an IExtendedLogSource
            </summary>
        </member>
        <member name="T:LogUtils.Compatibility.DotNet.DotNetLogger">
            <summary>
            A logger type that implements <see cref="T:Microsoft.Extensions.Logging.ILogger"/> interface
            </summary>
            <remarks>Allows usage of all existing logging overloads in addition to those provided by the interface</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(BepInEx.Logging.ILogSource)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Compatibility.DotNet.DotNetLogger"/> instance
            </summary>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(BepInEx.Logging.ILogSource)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(System.Boolean,LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(BepInEx.Logging.ILogSource)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(BepInEx.Logging.ILogSource)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(BepInEx.Logging.ILogSource)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(BepInEx.Logging.ILogSource)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(BepInEx.Logging.ILogSource)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(BepInEx.Logging.ILogSource)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor(BepInEx.Logging.ILogSource)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.BeginScope``1(``0)">
            <summary>
            Begins a logical operation scope.
            </summary>
            <remarks>Currently not implemented and will throw an exception</remarks>
            <param name="state">The identifier for the scope.</param>
            <typeparam name="TState">The type of the state to begin scope for.</typeparam>
            <returns>An <see cref="T:System.IDisposable"/> that ends the logical operation scope on dispose.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">
            <summary>
            Checks if the given <paramref name="category"/> is enabled.
            </summary>
            <param name="category">Logging context to be checked.</param>
            <returns><see langword="true" /> if enabled.</returns>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.Log``1(Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,``0,System.Exception,System.Func{``0,System.Exception,System.String})">
            <summary>
            Logs a message using the <see cref="T:Microsoft.Extensions.Logging.ILogger"/> interface, storing all provided event state to be accessed at a later stage.
            </summary>
            <param name="category">Entry will be written on this level.</param>
            <param name="eventID">Id of the event.</param>
            <param name="state">The entry to be written. Can be also an object.</param>
            <param name="exception">The exception related to this entry.</param>
            <param name="formatter">Function to create a <see cref="T:System.String"/> message of the <paramref name="state"/> and <paramref name="exception"/>.</param>
            <typeparam name="TState">The type of the object to be written.</typeparam>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.LoggerUtils.GetEquivalentCategory(Microsoft.Extensions.Logging.LogLevel)">
            <summary>
            Converts a <see cref="T:Microsoft.Extensions.Logging.LogLevel"/> value to its equivalent <see cref="T:LogUtils.Enums.LogCategory"/> instance
            </summary>
            <returns>Default <see cref="T:LogUtils.Enums.LogCategory"/> instance will be returned if value provided is not a recognized <see cref="T:Microsoft.Extensions.Logging.LogLevel"/> value</returns>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityAdapter.Run">
            <summary>
            Replaces Unity log handler with a LogUtils managed one
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityDoorstop.AddToWhitelist(System.String)">
            <summary>
            Adds a filename entry to whitelist.txt
            </summary>
            <exception cref="T:System.IO.FileNotFoundException">whitelist.txt does not exist</exception>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityDoorstop.RemoveFromWhitelist(System.String)">
            <summary>
            Removes a filename entry from whitelist.txt
            </summary>
            <remarks>Input is case insensitive</remarks>
            <exception cref="T:System.IO.FileNotFoundException">whitelist.txt does not exist</exception>
        </member>
        <member name="F:LogUtils.Compatibility.Unity.UnityLogEventArgs.Context">
            <summary>
            Unity object - typically given to provide context to the log message
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.Unity.UnityLogEventArgs.Tag">
            <summary>
            Unity tag - typically given to provide context to the log message
            </summary>
        </member>
        <member name="T:LogUtils.Compatibility.Unity.UnityLogger">
            <summary>
            A logger that exclusively writes directly through Unity's logging API
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.Unity.UnityLogger.IsSafeToLogToUnity">
            <summary>
            Critical section flag for interacting with Unity's logging API
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.EnsureLogTypeCapacity(System.Int32)">
            <summary>
            Ensures that the maximum LogType value able to be processed by the Unity logger is at least the specified capacity value
            </summary>
            <param name="capacity">The desired maximum FilterType value as an integer</param>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.Log(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogDebug(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogInfo(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogImportant(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogMessage(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogWarning(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogError(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogFatal(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.Log(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.Log(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.Log(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="F:LogUtils.Compatibility.Unity.UnityLogHandler._hasPendingRequests">
            <summary>
            Flag indicates that not all requests processed are known to have made it to Unity's logging API through this handler
            </summary>
        </member>
        <member name="T:LogUtils.Logger">
            <summary>
            Allows you to log messages to file, or a console using the write implementation of your choosing
            </summary>
        </member>
        <member name="M:LogUtils.Logger.LogBase(UnityEngine.LogType,System.String,System.Object,UnityEngine.Object)">
            <summary>
            This method receives all log API calls that make use of Unity specific logging arguments for this logger
            </summary>
        </member>
        <member name="M:LogUtils.Logger.#ctor(BepInEx.Logging.ILogSource)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.Enums.ILogTarget)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Logger.#ctor(System.Boolean,LogUtils.Enums.ILogTarget)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.Enums.ILogTarget[])">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Logger.#ctor(System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget[])">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(UnityEngine.LogType,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(UnityEngine.LogType,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(UnityEngine.LogType,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.String)"/>
        </member>
        <member name="F:LogUtils.ConflictResolutionFeedback.Overwrite">
            <summary>
            The file at destination will be replaced
            </summary>
        </member>
        <member name="F:LogUtils.ConflictResolutionFeedback.KeepBoth">
            <summary>
            The new filename will be renamed to avoid filename collisions
            </summary>
        </member>
        <member name="F:LogUtils.ConflictResolutionFeedback.CancelMove">
            <summary>
            File move will not be permitted
            </summary>
        </member>
        <member name="F:LogUtils.ConflictResolutionFeedback.SaveForLater">
            <summary>
            Result will be ignored, and asked again at the end
            </summary>
        </member>
        <member name="T:LogUtils.Console.AnsiColorConverter">
            <summary>
            This class converts color information into an ANSI color code
            </summary>
        </member>
        <member name="F:LogUtils.Console.AnsiColorConverter.ANSI_TERMINATOR_CHAR">
            <summary>
            The presence of this char indicates an ANSI color code has terminated
            </summary>
        </member>
        <member name="F:LogUtils.Console.AnsiColorConverter.ANSI_ESCAPE_CHAR">
            <summary>
            Escape character for an ANSI color code
            </summary>
        </member>
        <member name="M:LogUtils.Console.AnsiColorConverter.ApplyFormat(System.String,UnityEngine.Color)">
            <summary>
            Surrounds a message with ANSI codes necessary to display the message in the console with a specified color, and reset back to the default color at the end of the message
            </summary>
        </member>
        <member name="M:LogUtils.Console.AnsiColorConverter.AnsiToForeground(UnityEngine.Color)">
            <summary>
            Converts a UnityEngine.Color to an ANSI escape code for foreground color.
            </summary>
        </member>
        <member name="M:LogUtils.Console.AnsiColorConverter.AnsiBackground(UnityEngine.Color)">
            <summary>
            Converts a UnityEngine.Color to an ANSI escape code for background color.
            </summary>
        </member>
        <member name="F:LogUtils.Console.AnsiColorConverter.AnsiReset">
            <summary>
            ANSI reset code to restore default console color.
            </summary>
        </member>
        <member name="T:LogUtils.Console.ConsoleColorMap">
            <summary>
            This class provides helper methods for converting <see cref="T:System.ConsoleColor"/> enums to their corresponding <see cref="T:UnityEngine.Color"/> value, and vice versa
            </summary>
        </member>
        <member name="F:LogUtils.Console.ConsoleColorMap.DefaultConsoleColor">
            <summary>
            The primary color used for text in the console
            </summary>
        </member>
        <member name="P:LogUtils.Console.ConsoleColorMap.DefaultColor">
            <summary>
            The primary color used for text in the console
            </summary>
        </member>
        <member name="F:LogUtils.Console.ConsoleColorMap.ColorMap">
            <summary>
            A map of <see cref="T:System.ConsoleColor"/> values to their associated <see cref="T:UnityEngine.Color"/> value
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.GetColor(System.ConsoleColor)">
            <summary>
            Gets the <see cref="T:UnityEngine.Color"/> value mapped to a specified <see cref="T:System.ConsoleColor"/> code
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.GetColor(LogUtils.Enums.LogCategoryLevels)">
            <summary>
            Gets the <see cref="T:UnityEngine.Color"/> value mapped to a specified <see cref="T:LogUtils.Enums.LogCategoryLevels"/> value
            </summary>
            <remarks>Aligned with the colors assigned for <see cref="T:BepInEx.Logging.LogLevel"/></remarks>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.GetConsoleColor(LogUtils.Enums.LogCategoryLevels)">
            <summary>
            Gets the <see cref="T:System.ConsoleColor"/> value mapped to a specified <see cref="T:LogUtils.Enums.LogCategoryLevels"/> value
            </summary>
            <remarks>Aligned with the colors assigned for <see cref="T:BepInEx.Logging.LogLevel"/></remarks>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(UnityEngine.Color)">
            <summary>
            Finds the nearest compatible <see cref="T:System.ConsoleColor"/> value for the given color
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(System.Drawing.Color)">
            <inheritdoc cref="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(System.Byte,System.Byte,System.Byte)">
            <inheritdoc cref="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(UnityEngine.Color)"/>
        </member>
        <member name="P:LogUtils.Console.ConsoleLogWriter.Formatter">
            <summary>
            Applies text-based message format changes
            </summary>
        </member>
        <member name="F:LogUtils.Console.ConsoleLogWriter.Rules">
            <summary>
            Collection of associated message format rules
            </summary>
        </member>
        <member name="F:LogUtils.Console.ConsoleLogWriter.ShowLogsAware">
            <summary>
            A flag that determines whether <see cref="P:RainWorld.ShowLogs"/> should affect log processing to the console
            </summary>
        </member>
        <member name="P:LogUtils.Console.ConsoleLogWriter.Stream">
            <summary>
            The active write stream for writers that use one
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.ApplyRules(LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.AssignStreamWriter">
            <summary>
            Gets a valid stream writer instance
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.SendToBuffer(LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.WriteFrom(LogUtils.Requests.LogRequest)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.WriteFromBuffer(LogUtils.Enums.LogID,System.TimeSpan,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Console.LogConsole">
            <summary>
            This class is responsible for accessing the BepInEx console
            </summary>
        </member>
        <member name="F:LogUtils.Console.LogConsole.ANSIColorSupport">
            <summary>
            Indicates whether the host machine supports ANSI color codes
            </summary>
        </member>
        <member name="F:LogUtils.Console.LogConsole.WriteLock">
            <summary>
            This lock is used for interacting with BepInEx log console
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.FindWriter(LogUtils.Enums.ConsoleID,System.Boolean)">
            <summary>
            Finds the writer associated with a given <see cref="T:LogUtils.Enums.ConsoleID"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.FindWriters(System.Collections.Generic.IEnumerable{LogUtils.Enums.ConsoleID},System.Boolean)">
            <summary>
            Finds all writers associated with the given <see cref="T:LogUtils.Enums.ConsoleID"/> instances
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.AddWriter(LogUtils.Console.ConsoleLogWriter)">
            <summary>
            Registers a <see cref="T:LogUtils.Console.ConsoleLogWriter"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.SetConsoleColor(System.ConsoleColor)">
            <summary>
            Fallback method for adjusting text color in the console
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.SetEnabledState(System.Boolean)">
            <summary>
            Sets the enabled state for the BepInEx console (when it is supported) 
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.WriteLine(LogUtils.Enums.LogCategory,System.String)">
            <summary>
            Writes a message to the BepInEx console (when enabled)
            </summary>
            <param name="category">The category associated with the message</param>
            <param name="message">The message to write</param>
        </member>
        <member name="M:LogUtils.Console.LogConsole.WriteLine(System.String)">
            <inheritdoc cref="M:LogUtils.Console.LogConsole.WriteLine(LogUtils.Enums.LogCategory,System.String)"/>
        </member>
        <member name="T:LogUtils.Diagnostics.AssertHandler">
            <summary>
            This type defines behavior for handling assert results 
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.AssertHandler.Default">
            <summary>
            Default assert handling implementation
            </summary>
            <remarks>Possible to customize</remarks>
        </member>
        <member name="P:LogUtils.Diagnostics.AssertHandler.IsEnabled">
            <summary/>
        </member>
        <member name="M:LogUtils.Diagnostics.AssertHandler.SetLogger(LogUtils.ILogger)">
            <summary>
            Assigns an <see cref="T:LogUtils.ILogger"/> instance to the current object
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.AssertHandler.Handle(LogUtils.Diagnostics.Condition.Result)">
            <summary>
            Process a condition result
            </summary>
            <param name="result">The result to evaluate</param>
            <exception cref="T:UnityEngine.Assertions.AssertionException">Throws when <see cref="F:LogUtils.Diagnostics.AssertBehavior.Throw"/> is set, and assert fails</exception>
        </member>
        <member name="M:LogUtils.Diagnostics.AssertHandler.Clone">
            <summary>
            Creates a shallow copy of this instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.AssertHandler.Clone(LogUtils.Diagnostics.AssertBehavior)">
            <summary>
            Creates a shallow copy of this instance with the provided behavior
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.AssertHandler.MessageFormatter.FailResponse">
            <summary>
            The message that appears by default when an assert fails
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.AssertHandler.MessageFormatter.PassResponse">
            <summary>
            The message that appears by default when an assert passes (and pass state is allowed to be reported)
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.AssertBehavior">
            <summary>
            The activity that occurs on an assert result
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Assert">
            <summary>
            This class provides methods for making assert statements
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,System.Func{``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,System.Func{``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,``0,System.Func{``0,``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,``0,System.Func{``0,``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},System.Delegate,LogUtils.Diagnostics.Assert.EvaluationCriteria,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},System.Delegate,LogUtils.Diagnostics.Assert.EvaluationCriteria,System.Object[])"/>
        </member>
        <member name="T:LogUtils.Diagnostics.Assert.EvaluationCriteria">
            <summary>
            Represents the expected condition state
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(``0)">
            <summary>
            Creates a <see cref="T:LogUtils.Diagnostics.Condition`1"/> for asserting the state of a specified value
            </summary>
            <param name="value">Value to be used as an assert target</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0)"/>
            <param name="value">Value to be used as an assert target</param>
            <param name="behavior">Represents options for handling assert behavior</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0)"/>
            <param name="value">Value to be used as an assert target</param>
            <param name="handler">The exclusive handler to receive the assert result</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(System.Nullable{``0},LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.AssertBehavior)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(System.Nullable{``0},LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.IConditionHandler)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.Test``1(``0)">
            <summary>
            Creates a <see cref="T:LogUtils.Diagnostics.Condition`1"/> for asserting the state of a specified value in a test environment
            </summary>
            <param name="value">Value to be used as an assert target</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.Test``1(``0,LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.Test``1(``0)"/>
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.AssertBehavior)" select="param"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.Test``1(``0,LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.Test``1(``0)"/>
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.IConditionHandler)" select="param"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.Test``1(System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.Test``1(``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.Test``1(System.Nullable{``0},LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.Test``1(``0)"/>
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.AssertBehavior)" select="param"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.Test``1(System.Nullable{``0},LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.Test``1(``0)"/>
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.IConditionHandler)" select="param"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsFalse(LogUtils.Diagnostics.Condition{System.Boolean})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsFalse(LogUtils.Diagnostics.Condition{System.Boolean})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsFalse(LogUtils.Diagnostics.Condition{System.Nullable{System.Boolean}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsFalse(LogUtils.Diagnostics.Condition{System.Boolean})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsTrue(LogUtils.Diagnostics.Condition{System.Boolean})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsTrue(LogUtils.Diagnostics.Condition{System.Boolean})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsTrue(LogUtils.Diagnostics.Condition{System.Nullable{System.Boolean}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsTrue(LogUtils.Diagnostics.Condition{System.Boolean})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.ICollection{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IList{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.List{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{``0[]})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.ICollection{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IList{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.List{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{``0[]})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEqualTo``1(LogUtils.Diagnostics.Condition{System.IComparable{``0}},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{System.IComparable{``0}},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.SByte},System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.SByte},System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.SByte},System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.SByte},System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.SByte},System.SByte,System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Byte},System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Byte},System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Byte},System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Byte},System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Byte},System.Byte,System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int16},System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int16},System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int16},System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int16},System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Int16},System.Int16,System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16,System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32,System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int64},System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int64},System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int64},System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int64},System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Int64},System.Int64,System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64,System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Single},System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Single},System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Single},System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Single},System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Single},System.Single,System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Double},System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Double},System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Double},System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Double},System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Double},System.Double,System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal,System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.SByte,System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Byte,System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Int16,System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.UInt16,System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Int32,System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.UInt32,System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Int64,System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.UInt64,System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Single,System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Double,System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Decimal,System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.SByte},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.SByte},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.SByte},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.SByte},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Byte},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Byte},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Byte},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Byte},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int16},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int16},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int16},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int16},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt16},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt16},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt16},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt16},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int64},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int64},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int64},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int64},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt64},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt64},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt64},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt64},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Double},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Double},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Double},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Double},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Decimal},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Decimal},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Decimal},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Decimal},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}},System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEqualTo``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}},System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotNull``1(LogUtils.Diagnostics.Condition{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotNull``1(LogUtils.Diagnostics.Condition{``0})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotNull``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotNull``1(LogUtils.Diagnostics.Condition{``0})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotThisInstance``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotThisInstance``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNull``1(LogUtils.Diagnostics.Condition{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNull``1(LogUtils.Diagnostics.Condition{``0})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNull``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNull``1(LogUtils.Diagnostics.Condition{``0})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsSameInstance``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsSameInstance``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEmpty(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.IsEmpty(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.Contains(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.Contains(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.ContainsOnly(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.ContainsOnly(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.DoesNotContain(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.DoesNotContain(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="T:LogUtils.Diagnostics.Extensions.Assert">
            <summary>
            This class provides methods for making assert statements to additional types
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsGreaterThan``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsGreaterThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsLessThan``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsLessThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsBetween``1(LogUtils.Diagnostics.Condition{``0},``0,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThan``1(LogUtils.Diagnostics.Condition{``0}@,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0}@,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThan``1(LogUtils.Diagnostics.Condition{``0}@,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0}@,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeBetween``1(LogUtils.Diagnostics.Condition{``0}@,``0,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeZero``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustNotBeZero``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeNegative``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBePositive``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBePositiveOrZero``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThan``1(LogUtils.Diagnostics.Condition{``0}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThan``1(LogUtils.Diagnostics.Condition{``0}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThan``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThanOrEqualTo``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThan``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThanOrEqualTo``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeBetween``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,``0,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeZero``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustNotBeZero``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeNegative``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBePositive``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBePositiveOrZero``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition`1.op_True(LogUtils.Diagnostics.Condition{`0})">
            <summary>
            Evaluates the result state as true
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition`1.op_False(LogUtils.Diagnostics.Condition{`0})">
            <summary>
            Evaluates the result state as false
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition`1.op_Implicit(LogUtils.Diagnostics.Condition{`0})~System.Boolean">
            <summary>
            Converts the <see cref="T:LogUtils.Diagnostics.Condition`1"/> into its result state
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition`1.Value">
            <summary>
            Contains the state of the condition to evaluate
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition`1.Result">
            <summary>
            The pass/fail state of the condition
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Condition`1.ShouldProcess">
            <summary>
            Indicates whether more processing is necessary to produce a condition result
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition`1.ExpectPass">
            <summary>
            Indicates that the result should expicitly indicate the expected, or unexpected state, assuming passing as the expected state
            </summary>
            <remarks>Only effective when you use a handler that defers result processing such as DeferredAssertHandler</remarks>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition`1.ExpectFail">
            <summary>
            Indicates that the result should expicitly indicate the expected, or unexpected state, assuming failing as the expected state
            </summary>
            <remarks>Only effective when you use a handler that defers result processing such as DeferredAssertHandler</remarks>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean)">
            <summary>
            Asserts that the input value is true
            </summary>
            <remarks>Default handle behavior is to log a message when the asserted value is not true</remarks>
            <param name="condition">The condition to evaluate</param>
            <returns>true, when the condition is true, otherwise false</returns>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean,LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean)"/>
            <param name="condition">The condition to evaluate</param>
            <param name="behavior">The expected behavior of the assert</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean,LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean)"/>
            <param name="condition">The condition to evaluate</param>
            <param name="handler">The exclusive handler to receive the assert result</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean)">
            <summary>
            Asserts that the input value is false
            </summary>
            <remarks>Default handle behavior is to log a message when the asserted value is true</remarks>
            <param name="condition">The condition to evaluate</param>
            <returns>true, when the condition is false, otherwise false</returns>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean,LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean)"/>
            <param name="condition">The condition to evaluate</param>
            <param name="behavior">The expected behavior of the assert</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean,LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean)"/>
            <param name="condition">The condition to evaluate</param>
            <param name="handler">The exclusive handler to receive the assert result</param>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Message.Descriptors">
            <summary>
            When applicable, this contains descriptor terms used to format result messages
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Message.Raw">
            <summary>
            Message with no formatting applied
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Message.Tags">
            <summary>
            A set of strings to be appended to the end of the message for result reports
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Message.#ctor(System.String)">
            <summary>
            Constructs a response message
            </summary>
            <param name="message">The raw unformatted message string</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Message.#ctor(System.String,System.String[])">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.Message.#ctor(System.String)"/>
            <param name="message">The raw unformatted message string</param>
            <param name="formatValues">Values to use for formatting the raw string</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Message.SetDescriptors(System.String[],System.Boolean)">
            <summary>
            Replace the current format arguments with a new set of arguments
            </summary>
            <param name="descriptors">The new format arguments</param>
            <param name="throwIfDescriptorCountDoesNotMatch">A flag to remind mod users to update the raw string, before changing the number of format arguments</param>
            <exception cref="T:System.ArgumentException">The argument provided has an improper length</exception>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Result.ID">
            <summary>
            Value used for identification of the result (non-zero based)
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Condition.Result.IsUnexpected">
            <summary>
            Checks that there is an expected outcome and the result is consistent with that outcome
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Result.Expectation">
            <summary>
            Optional field that can be used to change how a result outcome is interpreted by comparing it to an expected outcome (e.g. fail may not always be treated as a fail)
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Result.Handlers">
            <summary>
            The handlers responsible for handling the assertion result
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Result.CompileMessageTags">
            <summary>
            Compiles a set of supported tags for the purpose of appending to a condition response message
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Result.PassedWithExpectations">
            <summary>
            Checks that a result is consistent with a set expectation, or if it has passed when none is set
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Result.ToString">
            <summary>
            Gets the result string
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Result.ResetCount">
            <summary>
            Change the next result ID to zero
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Debug.LogFrameReportThreshold">
            <summary>
            The maximum amount of time (in milliseconds) that a logging thread update can experience without triggering a slow update report message
            Set to 25 by default (time windows shorter than this will be subject to context switching delays)
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Debug.AcceptTestResultsFromAnyContext">
            <summary>
            When set to true, ignores the <see cref="T:LogUtils.Enums.DebugContext"/> information when determining whether an assert is considered a test condition
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Debug.SuppressTestResultCount">
            <summary>
            When set to true, assert results will not be assigned an identifier
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Debug.LastKnownContext">
            <summary>
            Context flag, typically used for assert processing
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Debug.LogRequestInfo(LogUtils.Enums.LogID,System.Collections.Generic.IEnumerable{LogUtils.Requests.LogRequest})">
            <summary>
            Logs requests to file in a report style format
            </summary>
            <param name="reportFile">The log file to write the report to</param>
            <param name="requests">The objects to log</param>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.BeginEnumeration">
            <summary>
            Enumerates through a string provider if available
            </summary>
            <exception cref="T:System.NullReferenceException">Provider is null</exception>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.ResetState">
            <summary>
            Resets state to before enumerating process began
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogCurrent">
            <summary>
            Attempts to log currently provided string
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogNext">
            <summary>
            Moves to next provided string, and attempts to log it
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.Log(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogDebug(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogInfo(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogImportant(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogMessage(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogWarning(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogUtils#ILogger{System#Object}#LogError(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogFatal(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.Log(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.Log(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.Log(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.Dispose">
            <summary>
            Resets enumerator to a default state
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.DeferredAssertHandler.Current">
            <summary>
            Peeks at the current result in the result queue
            </summary>
            <exception cref="T:System.InvalidOperationException">The result queue is empty</exception>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.Handle(LogUtils.Diagnostics.Condition.Result)">
            <summary>
            Enqueues the result in a result queue for future handling
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.HandleAll">
            <summary>
            Handles all results
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.HandleAll(LogUtils.Diagnostics.DeferredAssertHandler.HandleCondition)">
            <summary>
            Handles all results
            </summary>
            <remarks>When delegate returns true, result is handled normally, when false result is discarded</remarks>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.HandleCurrent">
            <summary>
            Handles the currently enumerated result
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.HandleCurrent(LogUtils.Diagnostics.DeferredAssertHandler.HandleCondition)">
            <summary>
            Handles the currently enumerated result
            </summary>
            <remarks>When delegate returns true, result is handled normally, when false result is discarded</remarks>
        </member>
        <member name="P:LogUtils.Diagnostics.DirectoryExceptionHandler.IsFileContext">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.DirectoryExceptionHandler.CreateErrorMessage(LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.DirectoryExceptionHandler.GetSimpleDescriptor(LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Diagnostics.ExceptionHandler.DATA_CONTEXT">
            <summary>
            Data key to access LogUtils <see cref="P:System.Exception.Data"/> for exceptions that support it
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.ExceptionHandler.Protocol">
            <summary>
            The behavior that results from handling an exception
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.ExceptionHandler.OnError(System.Exception)">
            <inheritdoc cref="M:LogUtils.Diagnostics.ExceptionHandler.OnError(System.Exception,System.Object)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.ExceptionHandler.OnError(System.Exception,System.Object)">
            <summary>
            The behavior that will happen when an <see cref="T:System.Exception"/> occurs
            </summary>
            <param name="exception">An unhandled exception</param>
            <param name="context">Optional contextual information to attach to an <see cref="T:System.Exception"/> object</param>
        </member>
        <member name="M:LogUtils.Diagnostics.ExceptionHandler.LogError(System.Exception)">
            <summary>
            Logs a message when an <see cref="T:System.Exception"/> is handled
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.ExceptionHandler.AttachContextToException(System.Exception,System.Object)">
            <summary>
            Attach contextual information to an <see cref="T:System.Exception"/> object
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.FailProtocol">
            <summary>
            Represents common <see cref="T:System.Exception"/> handling procedures
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.FailProtocol.LogAndIgnore">
            <summary><see cref="T:System.Exception"/> object will be logged</summary>
        </member>
        <member name="F:LogUtils.Diagnostics.FailProtocol.FailSilently">
            <summary><see cref="T:System.Exception"/> object will be silently consumed</summary>
        </member>
        <member name="F:LogUtils.Diagnostics.FailProtocol.Throw">
            <summary><see cref="T:System.Exception"/> object will be rethrown while preserving stacktrace</summary>
        </member>
        <member name="P:LogUtils.Diagnostics.FileExceptionHandler.IsFileContext">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.FileExceptionHandler.CanRecoverFrom(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.FileExceptionHandler.CreateErrorMessage(LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.FileExceptionHandler.GetSimpleDescriptor(LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper)">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Diagnostics.FileSystemExceptionHandler.CanContinue">
            <summary>
            Can the process recover from an exceptional state
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.FileSystemExceptionHandler.ContextStack">
            <summary>
            Contains an hierarchial set of contextual state in the order it was assigned to the handler
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.FileSystemExceptionHandler.Context">
            <summary>
            The current contextual state - this value affects the phrasing of certain contextual information when exception information is logged
            </summary>
            <value>Currently supported values: <see cref="F:LogUtils.Enums.FileSystem.ActionType.Move"/>, <see cref="F:LogUtils.Enums.FileSystem.ActionType.Copy"/>, <see cref="F:LogUtils.Enums.FileSystem.ActionType.Delete"/></value>
        </member>
        <member name="P:LogUtils.Diagnostics.FileSystemExceptionHandler.IsFileContext">
            <summary>
            The value of this affects the value of descriptors when exception information is logged
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.FileSystemExceptionHandler.System#IDisposable#Dispose">
            <summary>
            Finishes the current <see cref="P:LogUtils.Diagnostics.FileSystemExceptionHandler.Context"/> scope for this instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.FileSystemExceptionHandler.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.FileSystemExceptionHandler.CanRecoverFrom(System.Exception)">
            <summary>
            Influences the value of <see cref="P:LogUtils.Diagnostics.FileSystemExceptionHandler.CanContinue"/> which is used particular in cases where exceptions need to be caught inside a loop operation
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.FileSystemExceptionHandler.CreateErrorMessage(LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper,System.Boolean@)">
            <summary>
            Generates a message to be included when logging the <see cref="T:System.Exception"/>
            </summary>
            <param name="contextWrapper">Contains context specific information such as the <see cref="T:System.Exception"/> instance</param>
            <param name="includeStackTrace">
            Affects whether stack trace is going to be part of the logging output; true by default. Don't change unless you need to change it.
            </param>
        </member>
        <member name="M:LogUtils.Diagnostics.FileSystemExceptionHandler.LogError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.FileSystemExceptionHandler.LogError(System.Exception,System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Diagnostics.FileSystemExceptionHandler.LogError(System.Exception)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.FileSystemExceptionHandler.GetDescriptor(LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper)">
            <summary>
            Identifies the target file, or directory
            </summary>
            <returns>A string that represents a file, or directory (for logging purposes)</returns>
        </member>
        <member name="M:LogUtils.Diagnostics.FileSystemExceptionHandler.GetSimpleDescriptor(LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper)">
            <summary>
            The short form identification of the target file, or directory
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.FileSystemExceptionHandler.GetPathFromExceptionData(System.Exception)">
            <summary>
            Attempts to extract path data from the <see cref="T:System.Exception"/> data store.
            </summary>
            <returns>
            Information about the path. When there are invalid path characters, this returns the <see cref="T:LogUtils.Helpers.FileHandling.PathInfo"/> instance for an empty <see langword="string"/>.
            When no path data exists, this method returns <see langword="null"/>.
            </returns>
        </member>
        <member name="F:LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper.Source">
            <summary>
            The <see cref="T:System.Exception"/> object associated with the context
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper.Context">
            <summary>
            A value that helps identify what file system activity that was happening when the <see cref="T:System.Exception"/> occurred.
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper.IsExceptionContext">
            <summary>
            The context most directly associated with the <see cref="T:System.Exception"/> itself, and its data.
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.FileSystemExceptionHandler.ExceptionContextWrapper.CustomMessage">
            <summary>
            A message that should replace the standard message when not null
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.IConditionHandler.IsEnabled">
            <summary>
            Determines whether result should be handled or ignored
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.IConditionHandler.Handle(LogUtils.Diagnostics.Condition.Result)">
            <summary>
            Apply post-processing logic to a condition result
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.ResultAnalyzer.TotalResults">
            <summary/>
        </member>
        <member name="F:LogUtils.Diagnostics.ResultAnalyzer.TotalPassedResults">
            <summary/>
        </member>
        <member name="F:LogUtils.Diagnostics.ResultAnalyzer.TotalFailedResults">
            <summary/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.LogPropertyFactory.Create(System.String,System.Boolean)">
            <summary>
            Create an instance of a LogProperties for testing purposes
            </summary>
            <param name="path">The path to use for the instance</param>
            <param name="register">Whether or not instance should be added to the PropertyDataController</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.LogPropertyFactory.Create(System.String,System.Boolean,System.Boolean)">
            <summary>
            Create an instance of a LogProperties for testing purposes
            </summary>
            <param name="path">The path to use for the instance</param>
            <param name="advanceEnumeration">Affects whether a new string is provided, or the latest one</param>
            <param name="register">Whether or not instance should be added to the PropertyDataController</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.LogPropertyFactory.Dispose">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.Diagnostics.Tests.Components.LogPropertyFactory"/>
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.Components.TestEnum">
            <summary>
            A bare-structured implementation of a SharedExtEnum
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.Components.TestEnum.Factory">
            <summary>
            Access factory methods for creating specific kinds of <see cref="T:LogUtils.Diagnostics.Tests.Components.TestEnum"/> instances 
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.Components.TestEnumFactory">
            <summary>
            Factory implementation
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.Components.TestEnumFactory.Objects">
            <summary>
            Objects that have been created by the factory that have yet to be cleaned up
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestEnumFactory.Create(System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:LogUtils.Diagnostics.Tests.Components.TestEnum"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestEnumFactory.FromTarget(LogUtils.Diagnostics.Tests.Components.TestEnum)">
            <summary>
            Creates a new <see cref="T:LogUtils.Diagnostics.Tests.Components.TestEnum"/> instance using the <see cref="P:LogUtils.Enums.SharedExtEnum`1.Value"/> of an existing instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestEnumFactory.Add``1(``0)">
            <summary>
            Notify the factory class that an object should be managed
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestEnumFactory.DisposeObjects">
            <summary>
            Ensure that <see cref="T:ExtEnum`1"/> entries used for testing are properly disposed, and will not affect runtime behavior
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.Components.TestLogID.Factory">
            <inheritdoc cref="F:LogUtils.Enums.LogID.Factory"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestLogID.CycleAccess">
            <summary>
            Cycle to the next <see cref="T:LogUtils.Enums.LogAccess"/> value
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.Components.TestLogIDFactory">
            <summary>
            Factory implementation
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestLogIDFactory.Create">
            <summary>
            Creates a new <see cref="T:LogUtils.Diagnostics.Tests.Components.TestLogID"/> instance with a randomized filename
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestLogIDFactory.Create(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.Diagnostics.Tests.Components.TestLogID"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestLogIDFactory.CreateLogGroup(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.Enums.LogGroupID"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestLogIDFactory.CreateLogGroupMember(LogUtils.Enums.LogGroupID,System.String,System.String)">
            <summary>
            Assigns a new <see cref="T:LogUtils.Enums.LogID"/> member to a log group
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestLogIDFactory.FromTarget(LogUtils.Enums.LogID)">
            <summary>
            Creates a new <see cref="T:LogUtils.Diagnostics.Tests.Components.TestLogID"/> instance using the <see cref="P:LogUtils.Enums.SharedExtEnum`1.Value"/> of an existing instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestLogIDFactory.FromTarget(LogUtils.Enums.LogID,System.String)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Tests.Components.TestLogIDFactory.FromTarget(LogUtils.Enums.LogID)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestLogIDFactory.FromPath(System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.Diagnostics.Tests.Components.TestLogID"/> instance with a randomized filename
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.ITestable">
            <summary>
            Simple interface to make an object compatible with a TestSuite instance
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.ITestable.Name">
            <summary>
            A descriptive name for the test
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.ITestable.Test">
            <summary>
            Processes test logic, and assertions
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.PostTestAttribute">
            <summary>
            Identifies a method that should be run after testing
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.PreTestAttribute">
            <summary>
            Identifies a method that should be run before testing
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestCase.Group">
            <summary>
            The group that this test case belongs to
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestCase.GroupState">
            <summary>
            A shared state that applies to the top level test case and all of its children
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestCase.IsEnabled">
            <summary/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCase.AssertThat``1(``0)">
            <summary>
            Creates a structure for asserting the state of a specified value
            </summary>
            <param name="value">Value to be used as an assert target</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCase.AssertThat``1(System.Nullable{``0})">
            <summary>
            Creates a structure for asserting the state of a specified value
            </summary>
            <param name="value">Value to be used as an assert target</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCase.Dispose">
            <summary>
            Selects a new test case from the parent group
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCase.HasFailed">
            <summary>
            Checks that the test case has a failed outcome
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.TestCase.SharedState">
            <summary>
            State that is capable of being shared between two or more test case instances
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestCase.SharedState.InheritFromTestSuite">
            <summary>
            Should the state of the TestSuit affect the state of this instance
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestCase.SharedState.PropagateToChildren">
            <summary>
            Should children be exposed to this state, or only the most top level instance
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestCaseGroup.AllResults">
            <summary>
            Gets the test results for the test case and any children cases starting with the test group
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestCaseGroup.Count">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCaseGroup.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCaseGroup.Handle(LogUtils.Diagnostics.Condition.Result)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCaseGroup.HasFailed">
            <summary>
            Checks that any test cases under the group have failed outcomes, as well as its own asserts
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.TestInput">
            <summary>
            Contains test values for use in unit tests
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.TestInput.Strings">
            <summary>
            Test string constants
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestInput.Strings.FULL">
            <summary>
            Test value representing a non-empty string
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestInput.Strings.EMPTY">
            <summary>
            Test value representing a zero length string
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestInput.Strings.NULL">
            <summary>
            Test value representing a null string
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestInput.Strings.EmptyPathStrings">
            <summary>
            All strings that evaluate to an empty path
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestInput.OBJECT">
            <summary>
            Test value for an object
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.TestSuite">
            <summary>
            Simple utility object for storing and running tests
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestSuite.ActiveSuite">
            <summary>
            This is set during the process when tests are being run through a TestSuite instance
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestSuite.Handler">
            <summary>
            The handler to be used for all tests run through this test suite (null by default)
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestSuite.Capacity">
            <summary>
            The size of the inner collection
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestSuite.Size">
            <summary>
            The current number of collection entries
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestSuite.Count">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestSuite.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.#ctor">
            <summary>
            Constructs a new TestSuite instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.#ctor(System.Int32)">
            <summary>
            Constructs a new TestSuite instance with a specified default capacity
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.AddTests(System.Reflection.Assembly)">
            <summary>
            Searches for all implementors of the ITestable interface in a given assembly, and adds an instance of the type to the test suite 
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Add(LogUtils.Diagnostics.Tests.ITestable)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Clear">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Contains(LogUtils.Diagnostics.Tests.ITestable)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.CopyTo(LogUtils.Diagnostics.Tests.ITestable[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Remove(LogUtils.Diagnostics.Tests.ITestable)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{LogUtils.Diagnostics.Tests.ITestable})">
            <summary>
            Sorts the elements in a range of elements in an System.Array using the specified IComparer generic interface
            </summary>
            <param name="index">The starting index of the range to sort</param>
            <param name="count">The amount of elements in the range to sort</param>
            <param name="comparer">The IComparer to use</param>
            <exception cref="T:System.ArgumentNullException">Provided comparer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is less than the lower bound of array. -or- count is less than zero.</exception>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.RunTests(System.Func{LogUtils.Diagnostics.Tests.ITestable,System.Boolean})">
            <summary>
            Run tests that match a specific predicate
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.AssertTests.testCollectionDetection">
            <summary>
            Demonstrate the ways collection specific asserts are accessed
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.Utility.AssertTests.CustomCollection">
            <summary>
            Empty class used to test detection of custom collections
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.ExtEnumTests.testManagedReferenceIsDifferentPerLogPath">
            <summary>
            Test that a log filename can exist at two different paths without sharing the same managed reference
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.Utility.LogCategoryTests.TransferMode">
            <summary>
            TransferMode is primarily useful for checking that registration status propagates correctly to all instances
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.LogConsoleTests.TestColors">
            <summary>
            Sends color debug information to the console
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.LoggerTests.testConflictResolution">
            <summary>
            Tests related to ensuring that <see cref="T:LogUtils.Enums.LogID"/> instances with an equivalent filename, but different paths make it to the correct <see cref="T:LogUtils.Logger"/> instances
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.Utility.LogOverloadTests">
            <summary>
            These tests check that the Logger API translate user input into the correct logging overload
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.LogsFolderTests.TestMoveAndRestore">
            <summary>
            Moves eligible files to Logs folder and moves them back to their original location 
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.StressTests.TestThreadSafeWorker">
            <summary>
            Shows that <see cref="T:LogUtils.Threading.ThreadSafeWorker"/> can lock an arbitrary number of locks without being at risk of causing a deadlock
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tools.DeadlockTester">
            <summary>
            Basic type for checking deadlock conditions
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.AverageLogRate">
            <summary>
            The average window of time in between write requests
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.SampleFrequency">
            <summary>
            The polling frequency represented as the number of samples required to collect a new sample 
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.LogRateThreshold">
            <summary>
            The minimum rate between received messages considered to be normal, (or perhaps above normal, but not high volume). The value 2.5f represents 1/10th the length of
            a typical RainWorld frame at 40 FPS (25 ms / 10). Values less than this value are considered to be high volume.
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.HighVolumeSustainmentThreshold">
            <summary>
            The amount of consecutive sampling periods exceeding the allowable average rate (of logged messages) allowed before triggering the message buffer
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.PeriodsUnderHighVolume">
            <summary>
            The current amount of consecutive sampling periods exceeding the allowable average rate (of logged messages)
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.LogRateDecay">
            <summary>
            Average is multiplied by this amount for each period there are no new messages to sample
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tools.NullChecker">
            <summary>
            A simple struct that helps with identifying sources of null data
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.NullChecker.NullIndex">
            <summary>
            This number represents the item count position of the latest value to be confirmed as null
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.NullChecker.DetectionThreshold">
            <summary>
            Allows a limit to be set on null matches detected. Useful for detecting nulls in an object reference chain.
            </summary>
            <remarks>Example: obj.FieldA.FieldB
            <br></br>
            <br>Make sure that you null check each potential null, before trying to pass it into the NullChecker.</br>
            The null-condition operator (?) can be used to make this easier.</remarks>
        </member>
        <member name="M:LogUtils.Diagnostics.Tools.NullChecker.Check(System.Object,System.String)">
            <summary>
            Performs a null check on an object. Resulting feedback is then stored as field data
            </summary>
            <param name="obj">Object to evaluate</param>
            <param name="callerArgumentName">The name of the reference. Leave blank to autocapture argument</param>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.TestStringProvider.Template">
            <summary>
            The base log string to enumerate on
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tools.TestStringProvider.StringFactory.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.DirectToFileLogger.Delete">
            <summary>
            Attempts to delete the debug log for the current Rain World process
            </summary>
        </member>
        <member name="M:LogUtils.DirectToFileLogger.DeleteAll">
            <summary>
            Attempts to cleanup stray debug logs that were created by LogUtils belonging to different Rain World processes
            </summary>
        </member>
        <member name="T:LogUtils.DiscreteLogger">
            <summary>
            A logger instance designed to be isolated from remote requests by default
            </summary>
        </member>
        <member name="P:LogUtils.DiscreteLogger.AllowRemoteLogging">
            <inheritdoc/>
            <value>Always returns false</value>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget)">
            <summary>
            Constructs a new <see cref="T:LogUtils.DiscreteLogger"/> instance
            </summary>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(System.Boolean,LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget)"/>
            <inheritdoc select="params"/>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,System.Func{``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)">
            <summary>
            Asserts a condition by invoking a delegate using specified values as arguments
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="conditionArg">Condition argument for delegate</param>
            <param name="conditionDelegate">Callback that checks the condition state</param>
            <param name="criteria">The expected state of the condition</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,``0,System.Func{``0,``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)">
            <summary>
            Asserts a condition by invoking a delegate using specified values as arguments
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="firstArg">First condition argument</param>
            <param name="secondArg">Second condition argument</param>
            <param name="conditionDelegate">Callback that checks the condition state</param>
            <param name="criteria">The expected state of the condition</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},System.Delegate,LogUtils.Diagnostics.Assert.EvaluationCriteria,System.Object[])">
            <summary>
            Asserts a condition by dynamically invoking a delegate
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="dynamicCondition">Delegate that evaluates a condition (must return true or false)</param>
            <param name="criteria">The expected state of the condition</param>
            <param name="dynamicParams">Parameters for evaluating a condition</param>
            <exception cref="T:System.MemberAccessException">
               The caller does not have access to the method represented by the delegate (for
               example, if the method is private). -or- The number, order, or type of parameters
               listed in args is invalid.</exception>
            <exception cref="T:System.ArgumentException">
                The method represented by the delegate is invoked on an object or a class that
                does not support it.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">
                The method represented by the delegate is an instance method and the target object
                is null. -or- One of the encapsulated methods throws an exception.</exception>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsFalse(LogUtils.Diagnostics.Condition{System.Boolean})">
            <summary>
            Asserts that target value must be false
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsTrue(LogUtils.Diagnostics.Condition{System.Boolean})">
            <summary>
            Asserts that target value must be true
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <summary>
            Asserts that the target value must be not equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareObject">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <summary>
            Asserts that the target value must be equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareObject">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotNull``1(LogUtils.Diagnostics.Condition{``0})">
            <summary>
            Asserts that the target value must not be null
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotThisInstance``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <summary>
            Asserts that the target object refers to a different object than a specified object
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareObject">The object to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNull``1(LogUtils.Diagnostics.Condition{``0})">
            <summary>
            Asserts that the target value must be null
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsSameInstance``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <summary>
            Asserts that the target object refers to the same object as a specified object
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareObject">The object to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Asserts that the target collection must have at least one entry
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Asserts that the target collection must be null or empty
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{System.IComparable{``0}},``0)">
            <summary>
            Asserts that the target value must be equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <summary>
            Asserts that the target value must be greater than a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <summary>
            Asserts that the target value must be greater than or equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <summary>
            Asserts that the target value must be less than a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <summary>
            Asserts that the target value must be less than or equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)">
            <summary>
            Asserts that the target value must be in a given interval
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="minimum">The lower bound</param>
            <param name="maximum">The upper bound</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must be equal to zero
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must not be equal to zero
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must be negative
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must be positive
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must not be negative
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.IsEmpty(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory})">
            <summary>
            Asserts that the target value's IsEmpty property is set to true
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.Contains(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <summary>
            Asserts that the target value contains a given value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="flag">The flag value to evaluate</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.ContainsOnly(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <summary>
            Asserts that the target value only contains a given value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="flag">The flag value to evaluate</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.DoesNotContain(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <summary>
            Asserts that the target value does not contain a given value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="flag">The flag value to evaluate</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)">
            <summary>
            Formats and writes a log message
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)">
            <summary>
            Formats and writes a log message
            </summary>
            <remarks>Accepts multiple targets through the use of bitflag operators (to combine multiple log targets into one)</remarks>
            <param name="target">The specified log file, or console identifier to target</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <summary>
            Formats and writes a log message to multiple log targets
            </summary>
            <param name="targets">The specified log file, or console identifiers to target</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)">
            <summary>
            Formats and writes a log message with a debug context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)">
            <summary>
            Formats and writes a log message with an informational context (typically the default context)
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)">
            <summary>
            Formats and writes a log message with an important context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)">
            <summary>
            Formats and writes a log message with a message context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)">
            <summary>
            Formats and writes a log message with a warning context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)">
            <summary>
            Formats and writes a log message with an error context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)">
            <summary>
            Formats and writes a log message with a fatal context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)">
            <summary>
            Formats and writes a log message only once
            </summary>
            <remarks>Prevents logging a message more than once</remarks>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message only once with a specified logging context
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)">
            <summary>
            Formats and writes a log message only once
            </summary>
            <remarks>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <para>
            Accepts multiple targets through the use of bitflag operators (to combine multiple log targets into one) <br/>
            When multiple targets are selected, it will log once to each specific target </para>
            </remarks>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message only once with a specified logging context
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)" select="param, remarks"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <summary>
            Formats and writes a log message to multiple log targets only once
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])">
            <summary>
            Formats and writes a log message according to a message template, and provided format arguments
            </summary>
            <param name="format">The message template</param>
            <param name="formatArgs">Arguments processed by the message template</param>
            <exception cref="T:System.ArgumentNullException">Format, or format arguments array is null</exception>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <summary>
            Formats and writes a log message with a specified logging context according to a message template, and provided format arguments
            </summary>
            <param name="category">The specified logging context</param>
            <param name="format">The message template</param>
            <param name="formatArgs">Arguments processed by the message template</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])"/>
            <remarks>Accepts multiple targets through the use of bitflag operators (to combine multiple log targets into one)</remarks>
            <param name="target">The specified log file, or console identifier to target</param>
            <param name="format">The message template</param>
            <param name="formatArgs">Arguments processed by the message template</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <summary>
            Formats and writes a log message to multiple targets according to a message template, and provided format arguments
            </summary>
            <param name="targets">The specified log file, or console identifiers to target</param>
            <param name="format">The message template</param>
            <param name="formatArgs">Arguments processed by the message template</param>
            <exception cref="T:System.ArgumentNullException">Format, or format arguments array is null</exception>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
            <param name="targets">The specified log file, or console identifiers to target</param>
            <param name="category">The specified logging context</param>
            <param name="format">The message template</param>
            <param name="formatArgs">Arguments processed by the message template</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.Object[])">
            <summary>
            Formats and writes a log message with a debug context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.Object[])">
            <summary>
            Formats and writes a log message with an informational context (typically the default context) according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.Object[])">
            <summary>
            Formats and writes a log message with an important context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.Object[])">
            <summary>
            Formats and writes a log message with a message context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.Object[])">
            <summary>
            Formats and writes a log message with a warning context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.Object[])">
            <summary>
            Formats and writes a log message with an error context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.Object[])">
            <summary>
            Formats and writes a log message with a fatal context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.String,System.Object[])">
            <summary>
            Formats and writes a log message only once according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <summary>
            Formats and writes a log message only once with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.Object[])">
            <summary>
            Formats and writes a log message only once according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <summary>
            Formats and writes a log message only once with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param, remarks"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])">
            <summary>
            Formats and writes a log message to multiple log targets only once according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])"/>
            <param name="format">The message template</param>
            <param name="formatArg">Argument processed by the message template</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])"/>
            <param name="category">The specified logging context</param>
            <param name="format">The message template</param>
            <param name="formatArg">Argument processed by the message template</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])"/>
            <remarks>Accepts multiple targets through the use of bitflag operators (to combine multiple log targets into one)</remarks>
            <param name="target">The specified log file, or console identifier to target</param>
            <param name="format">The message template</param>
            <param name="formatArg">Argument processed by the message template</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <summary>
            Formats and writes a log message to multiple targets according to a message template, and provided format arguments
            </summary>
            <param name="targets">The specified log file, or console identifiers to target</param>
            <param name="format">The message template</param>
            <param name="formatArg">Argument processed by the message template</param>
            <exception cref="T:System.ArgumentNullException">Format, or format arguments array is null</exception>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
            <param name="targets">The specified log file, or console identifiers to target</param>
            <param name="category">The specified logging context</param>
            <param name="format">The message template</param>
            <param name="formatArg">Argument processed by the message template</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.String)">
            <summary>
            Formats and writes a log message with a debug context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.String)">
            <summary>
            Formats and writes a log message with an informational context (typically the default context) according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.String)">
            <summary>
            Formats and writes a log message with an important context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.String)">
            <summary>
            Formats and writes a log message with a message context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.String)">
            <summary>
            Formats and writes a log message with a warning context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.String)">
            <summary>
            Formats and writes a log message with an error context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.String)">
            <summary>
            Formats and writes a log message with a fatal context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.String,System.String)">
            <summary>
            Formats and writes a log message only once according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.String,System.String)">
            <summary>
            Formats and writes a log message only once with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.String)">
            <summary>
            Formats and writes a log message only once according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.String,System.String)">
            <summary>
            Formats and writes a log message only once with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.String,System.String)" select="param, remarks"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)">
            <summary>
            Formats and writes a log message to multiple log targets only once according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object[])"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
            <param name="messageColor">The text color to apply to a message</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)"/>
            <param name="target">The specified log file, or console identifier to target</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
            <param name="messageColor">The text color to apply to a message</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <param name="targets">The specified log file, or console identifiers to target</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
            <param name="messageColor">The text color to apply to a message</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)">
            <summary>
            Formats and writes a log message to BepInEx
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)">
            <summary>
            Formats and writes a log message to BepInEx with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)">
            <summary>
            Formats and writes a log message to BepInEx with a specified logging context, and logging source
            </summary>
            <param name="source">The source of the logged message (usually a ManualLogSource in a modding context)</param>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.Object)">
            <summary>
            Formats and writes a log message to Unity
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)">
            <summary>
            Formats and writes a log message to Unity with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.Object)">
            <summary>
            Formats and writes a log message to Expedition
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message to Expedition with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.Object)">
            <summary>
            Formats and writes a log message to JollyCoop
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message to JollyCoop with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.String,System.Object[])">
            <summary>
            Formats and writes a log message to BepInEx according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Formats and writes a log message to BepInEx with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Formats and writes a log message to BepInEx with a specified logging context, and logging source according to a message template, and provided format arguments
            </summary>
            <param name="source">The source of the logged message (usually a ManualLogSource in a modding context)</param>
            <param name="category">The specified logging context</param>
            <param name="format">The message template</param>
            <param name="formatArgs">Arguments processed by the message template</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.String,System.Object[])">
            <summary>
            Formats and writes a log message to Unity according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.String,System.Object[])">
            <summary>
            Formats and writes a log message to Unity with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.String,System.Object[])">
            <summary>
            Formats and writes a log message to Expedition according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <summary>
            Formats and writes a log message to Expedition with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.String,System.Object[])">
            <summary>
            Formats and writes a log message to JollyCoop
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <summary>
            Formats and writes a log message to JollyCoop with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.String,System.String)">
            <summary>
            Formats and writes a log message to BepInEx according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.String,System.String)">
            <summary>
            Formats and writes a log message to BepInEx with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.String,System.String)">
            <summary>
            Formats and writes a log message to BepInEx with a specified logging context, and logging source according to a message template, and provided format arguments
            </summary>
            <param name="source">The source of the logged message (usually a ManualLogSource in a modding context)</param>
            <param name="category">The specified logging context</param>
            <param name="format">The message template</param>
            <param name="formatArg">Argument processed by the message template</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.String,System.String)">
            <summary>
            Formats and writes a log message to Unity according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.String,System.String)">
            <summary>
            Formats and writes a log message to Unity with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.String,System.String)">
            <summary>
            Formats and writes a log message to Expedition according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.String,System.String)">
            <summary>
            Formats and writes a log message to Expedition with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.String,System.String)">
            <summary>
            Formats and writes a log message to JollyCoop
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.String,System.String)">
            <summary>
            Formats and writes a log message to JollyCoop with a specified logging context according to a message template, and provided format arguments
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.String)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="T:LogUtils.Enums.ComparisonLogID">
            <summary>
            A type of <see cref="T:LogUtils.Enums.LogID"/> designed for comparisons. Not to be used for logging purposes
            </summary>
        </member>
        <member name="F:LogUtils.Enums.ComparisonLogID.RepresentedType">
            <summary>
            Indicates the kind of <see cref="T:LogUtils.Enums.LogID"/> represented by the comparison instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.ComparisonLogID.Tag">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.ComparisonLogID.#ctor(System.String,System.String)">
            <summary>
            Constructs a lightweight <see cref="T:LogUtils.Enums.LogID"/> instance intended for local comparisons rather than logging
            </summary>
            <inheritdoc cref="M:LogUtils.Enums.LogID.#ctor(System.String,System.String,LogUtils.Enums.LogAccess,System.Boolean)"/>
            <remarks>This type is not registered by default, and does not have its own properties (unless an existing <see cref="T:LogUtils.Enums.LogID"/> already has properties)</remarks>
        </member>
        <member name="M:LogUtils.Enums.ComparisonLogID.#ctor(System.String,LogUtils.Enums.LogIDType)">
            <inheritdoc cref="M:LogUtils.Enums.ComparisonLogID.#ctor(System.String,System.String)"/>
            <param name="value">The value that identifies the <see cref="T:LogUtils.Enums.ComparisonLogID"/> instance</param>
            <param name="representedType">The type of <see cref="T:LogUtils.Enums.LogID"/> represented by this instance</param>
        </member>
        <member name="M:LogUtils.Enums.ComparisonLogID.Register">
            <summary>
            Unsupported operation on this type
            </summary>
        </member>
        <member name="M:LogUtils.Enums.ComparisonLogID.Unregister">
            <summary>
            Unsupported operation on this type
            </summary>
        </member>
        <member name="F:LogUtils.Enums.ComparisonLogID.Factory">
            <inheritdoc cref="F:LogUtils.Enums.LogID.Factory"/>
        </member>
        <member name="T:LogUtils.Enums.ComparisonLogID.FactoryImpl">
            <summary>
            Factory implementation
            </summary>
        </member>
        <member name="T:LogUtils.Enums.ComparisonLogID.IFactory">
            <summary>
            Represents a type exposing <see cref="T:LogUtils.Enums.LogID"/> construction options
            </summary>
        </member>
        <member name="M:LogUtils.Enums.ComparisonLogID.IFactory.CreateID(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Enums.ComparisonLogID.#ctor(System.String,System.String)"/>
        </member>
        <member name="T:LogUtils.Enums.CompositeLogCategory">
            <summary>
            A type of <see cref="T:LogUtils.Enums.LogCategory"/> featuring properties of enum bitflags
            </summary>
            <remarks><see cref="T:LogUtils.Enums.LogCategory"/> instances can be combined using overloaded bitflag operators to create a composite instance</remarks>
        </member>
        <member name="F:LogUtils.Enums.CompositeLogCategory.Set">
            <summary>
            Contains the flags that represent the composite instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogCategory.BepInExCategory">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogCategory.UnityCategory">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogCategory.FlagValue">
            <summary>
            The combined bitflag translation of all contained flags within this instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogCategory.Level">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogCategory.ConsoleColor">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.Register">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.Deconstruct">
            <summary>
            Returns the <see cref="T:LogUtils.Enums.LogCategory"/> instances that make up the composite set
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.FromFlags(BepInEx.Logging.LogLevel[])">
            <summary>
            Combines any number of enum values into a composite <see cref="T:LogUtils.Enums.LogCategory"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.FromFlags(UnityEngine.LogType[])">
            <summary>
            Combines any number of enum values into a composite <see cref="T:LogUtils.Enums.LogCategory"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.GetMostRelevantFlags">
            <summary>
            Finds all flags that match the most relevant category level
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.Contains(LogUtils.Enums.LogCategory)">
            <summary>
            Checks whether this instance contains the specified flag element
            </summary>
            <param name="flag">The element to look for</param>
            <returns>true, if the flag element is contained by this instance; otherwise, false</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.Contains(LogUtils.Enums.CompositeLogCategory)">
            <summary>
            Checks whether this instance contains all elements specified within the composite flag
            </summary>
            <param name="flags">Contains a set of flags to look for</param>
            <returns>true, if all flag elements are contained by this instance; otherwise, false</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.HasAll(LogUtils.Enums.CompositeLogCategory)">
            <summary>
            Checks whether this instance contains every element of another compatible composite instance
            </summary>
            <param name="flags">Contains a set of flags to look for</param>
            <returns>true, if all flag elements are contained by this instance; otherwise, false</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.HasAny(LogUtils.Enums.CompositeLogCategory)">
            <summary>
            Checks whether this instance contains any element of another compatible composite instance
            </summary>
            <param name="flags">Contains a set of flags to look for</param>
            <returns>true, if at least one flag element is contained by this instance; otherwise, false</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.HasFlag(LogUtils.Enums.LogCategory,LogUtils.Helpers.FlagSearchOption)">
            <summary>
            Checks whether this instance contains a flag as a whole value, or elements of the flag based on a specified search behavior 
            </summary>
            <param name="flag">Contains a flag, or set of flags to look for</param>
            <param name="searchOption">Specifies the search behavior when the flag represents multiple elements, has no effect when there is only one element</param>
            <returns>true, when an element has been matched based on the provided search criteria</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.ToString">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogTarget.Value">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogTarget.IsEnabled">
            <inheritdoc/>
            <remarks>Composite targets are never available to be handled</remarks>
        </member>
        <member name="F:LogUtils.Enums.CompositeLogTarget.Set">
            <summary>
            Contains the flags that represent the composite instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogTarget.GetRequestType(LogUtils.ILogHandler)">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.ConsoleID.IsEnabled">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.FileSystem.ActionType.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:LogUtils.Enums.FileSystem.ActionType"/> instance
            </summary>
            <param name="value">The <see cref="T:ExtEnum`1"/> value associated with this instance</param>
            <param name="register">Whether or not this instance should be registered as a unique <see cref="T:ExtEnum`1"/> entry</param>
        </member>
        <member name="M:LogUtils.Enums.FileSystem.ActionType.#ctor(LogUtils.Enums.FileSystem.FileAction)">
            <summary>
            Initializes a new <see cref="T:LogUtils.Enums.FileSystem.ActionType"/> instance
            </summary>
            <param name="action">The conversion value that initializes the state</param>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Enum value was unrecognized</exception>
        </member>
        <member name="M:LogUtils.Enums.FileSystem.ActionType.IsValid(LogUtils.Enums.FileSystem.ActionType)">
            <summary>
            Checks that a value is consistent with a valid <see cref="T:LogUtils.Enums.FileSystem.ActionType"/> value
            </summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.None">
            <summary>Default value</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.Create">
            <summary>Represents a file, or directory creation event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.Delete">
            <summary>Represents a file, or directory deletion event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.Buffering">
            <summary>Represents a file stream buffer event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.Write">
            <summary>Represents a file write event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.Move">
            <summary>Represents a file, or directory move or rename event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.Copy">
            <summary>Represents a file, or directory copy event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.Open">
            <summary>Represents a file (or filestream) open event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.PathUpdate">
            <summary>Represents a path update event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.SessionStart">
            <summary>Represents a log session started event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.SessionEnd">
            <summary>Represents a log session ended event</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ActionType.StreamDisposal">
            <summary>Represents a file stream disposal event</summary>
        </member>
        <member name="T:LogUtils.Enums.FileSystem.ScopedActionType">
            <summary>
            Constructs a new unregistered instance of a scoped <see cref="T:LogUtils.Enums.FileSystem.ActionType"/>
            </summary>
            <param name="type">The type that the scope will be associated with</param>
        </member>
        <member name="M:LogUtils.Enums.FileSystem.ScopedActionType.#ctor(LogUtils.Enums.FileSystem.ActionType)">
            <summary>
            Constructs a new unregistered instance of a scoped <see cref="T:LogUtils.Enums.FileSystem.ActionType"/>
            </summary>
            <param name="type">The type that the scope will be associated with</param>
        </member>
        <member name="T:LogUtils.Enums.FileSystem.FolderPermissions">
            <summary>
            Represents permission flags that apply to a folder
            </summary>
        </member>
        <member name="M:LogUtils.Enums.FileSystem.ProcessCompletion.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new <see cref="T:LogUtils.Enums.FileSystem.ProcessCompletion"/> instance
            </summary>
            <param name="value">The <see cref="T:ExtEnum`1"/> value associated with this instance</param>
            <param name="register">Whether or not this instance should be registered as a unique <see cref="T:ExtEnum`1"/> entry</param>
        </member>
        <member name="M:LogUtils.Enums.FileSystem.ProcessCompletion.#ctor(LogUtils.Enums.FileSystem.FileStatus)">
            <summary>
            Initializes a new <see cref="T:LogUtils.Enums.FileSystem.ProcessCompletion"/> instance
            </summary>
            <param name="status">The conversion value that initializes the state</param>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Enum value was unrecognized</exception>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ProcessCompletion.AwaitingStatus">
            <summary>The initial process state</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ProcessCompletion.NoActionRequired">
            <summary>Indicates that no changes were made or required. Action was already completed.</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ProcessCompletion.ActionRequired">
            <summary>Indicates that the process is incomplete</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ProcessCompletion.Complete">
            <summary>Indicates that requested action has been completed successfully</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ProcessCompletion.AlreadyExists">
            <summary>Indicates that process did not complete due to file, or directory already existing; state is similar to <see cref="F:LogUtils.Enums.FileSystem.ProcessCompletion.NoActionRequired"/></summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ProcessCompletion.ValidationFailed">
            <summary>Indicates that process did not complete due to validation process failure</summary>
        </member>
        <member name="F:LogUtils.Enums.FileSystem.ProcessCompletion.Error">
            <summary>Indicates that process did not complete due to an <see cref="T:System.Exception"/> or other error state</summary>
        </member>
        <member name="T:LogUtils.Enums.IExtEnumBase">
            <summary>
            The non-generic representation of a <see cref="T:LogUtils.Enums.SharedExtEnum`1"/> derived type
            </summary>
        </member>
        <member name="P:LogUtils.Enums.IExtEnumBase.Index">
            <summary>
            Index position for this entry in the <see cref="F:ExtEnumType.entries"/> list
            </summary>
        </member>
        <member name="P:LogUtils.Enums.IExtEnumBase.Registered">
            <summary>
            This <see cref="T:ExtEnum`1"/> entry is associated with a valid (non-negative) <see cref="P:ExtEnum`1.Index"/> value
            </summary>
        </member>
        <member name="P:LogUtils.Enums.IExtEnumBase.Value">
            <summary>
            An identifying string assigned to each <see cref="T:ExtEnum`1"/> entry
            </summary>
        </member>
        <member name="M:LogUtils.Enums.IExtEnumBase.Register">
            <summary>
            Registers the <see cref="T:ExtEnum`1"/> entry
            </summary>
            <remarks>Note: Registration status is propagated to all other created instances sharing the value of this instance.</remarks>
        </member>
        <member name="M:LogUtils.Enums.IExtEnumBase.Unregister">
            <summary>
            Unregisters the <see cref="T:ExtEnum`1"/> entry
            </summary>
            <remarks>Note: Registration status is propagated to all other created instances sharing the value of this instance.</remarks>
        </member>
        <member name="F:LogUtils.Enums.LogCategory.LOG_LEVEL_DEFAULT">
            <summary>
            The default conversion type for <see cref="T:BepInEx.Logging.LogLevel"/> enum type
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogCategory.LOG_TYPE_DEFAULT">
            <summary>
            The default conversion type for <see cref="T:UnityEngine.LogType"/> enum type
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.BepInExCategory">
            <summary>
            The category value translated to the category enum used for BepInEx logging
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.UnityCategory">
            <summary>
            The category value translated to the category enum used for Unity logging
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.FlagValue">
            <summary>
            The bitflag translation representing this instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.Level">
            <summary>
            The overall logging group defined for this category - used for tasks such as filtering by one or more categories
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.ConsoleColor">
            <summary>
            The color that will be used in the console, or other write implementation that supports text coloration  
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.#ctor(System.String,System.Nullable{BepInEx.Logging.LogLevel},System.Nullable{UnityEngine.LogType})">
            <summary>
            Constructs a registered <see cref="T:LogUtils.Enums.LogCategory"/> instance
            </summary>
            <param name="value">The <see cref="T:ExtEnum`1"/> value associated with this instance</param>
            <param name="bepInExEquivalent">
            The enum value to be used when this category is used by the BepInEx logger<br/>
            Setting to null assigns a custom <see cref="T:BepInEx.Logging.LogLevel"/>, otherwise will take the value of the <see cref="T:BepInEx.Logging.LogLevel"/> provided
            </param>
            <param name="unityEquivalent">
            The enum value to be used when this category is used by the Unity logger<br/>
            Setting to null assigns a custom <see cref="T:UnityEngine.LogType"/>, otherwise will take the value of the <see cref="T:UnityEngine.LogType"/> provided
            </param>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs a <see cref="T:LogUtils.Enums.LogCategory"/> instance
            </summary>
            <param name="value">The <see cref="T:ExtEnum`1"/> value associated with this instance</param>
            <param name="register">Whether or not this instance should be registered as a unique <see cref="T:ExtEnum`1"/> entry</param>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.Register">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.GetUnityLogID(UnityEngine.LogType)">
            <summary>
            Determines if the logging context is general purpose, or targets an exception
            </summary>
            <returns>The proper <see cref="T:LogUtils.Enums.LogID"/> for the provided logging context</returns>
        </member>
        <member name="F:LogUtils.Enums.LogCategory.CONVERSION_OFFSET">
            <summary>
            The bit-oriented value position of an enum value (<see cref="T:BepInEx.Logging.LogLevel"/> or <see cref="T:UnityEngine.LogType"/>) reserved for custom conversions of <see cref="T:LogUtils.Enums.LogCategory"/> values
            </summary>
            <remarks>Value must be compliant with <see cref="T:BepInEx.Logging.LogLevel"/>, which assigns a max value of 63.
            This value must be at least 64 or greater for compatibility purposes</remarks>
        </member>
        <member name="F:LogUtils.Enums.LogCategory.CONVERSION_OFFSET_POWER">
            <summary>
            The power of two used to produce the conversion offset
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.ToCategory(System.String)">
            <summary>
            Converts a <see cref="T:System.String"/> to its equivalent <see cref="T:LogUtils.Enums.LogCategory"/> instance
            </summary>
            <returns><see cref="T:LogUtils.Enums.LogCategory"/> instance will be unregistered if no registered equivalent exists</returns>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.ToCategory(BepInEx.Logging.LogLevel)">
            <summary>
            Converts a <see cref="T:BepInEx.Logging.LogLevel"/> value to its equivalent <see cref="T:LogUtils.Enums.LogCategory"/> instance
            </summary>
            <returns><see cref="T:LogUtils.Enums.LogCategory"/> instance will be unregistered if no registered equivalent exists</returns>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.ToCategory(UnityEngine.LogType)">
            <summary>
            Converts a <see cref="T:UnityEngine.LogType"/> value to its equivalent <see cref="T:LogUtils.Enums.LogCategory"/> instance
            </summary>
            <returns><see cref="T:LogUtils.Enums.LogCategory"/> instance will be unregistered if no registered equivalent exists</returns>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.ToCategoryLevel(BepInEx.Logging.LogLevel)">
            <summary>
            Converts a <see cref="T:BepInEx.Logging.LogLevel"/> value to its equivalent <see cref="T:LogUtils.Enums.LogCategoryLevels"/> flags
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.GetEquivalent(BepInEx.Logging.LogLevel)">
            <summary>
            An internal helper that assumes that composite checks have already been handled, and input is not a composite
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.GetEquivalent(UnityEngine.LogType)">
            <summary>
            An internal helper that assumes that composite checks have already been handled, and input is not a composite
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryCombiner.Combine(LogUtils.Enums.LogCategory,LogUtils.Enums.LogCategory)">
            <summary>
            Create a composite object out of two component objects
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryCombiner.extractElements(LogUtils.Enums.LogCategory)">
            <summary>
            Extract the component elements from the provided category
            </summary>
        </member>
        <member name="T:LogUtils.Enums.LogCategoryFilter">
            <summary>
            <see cref="T:LogUtils.Enums.LogCategoryFilter.ByCategory"/><br/>
            Supports matching against specific <see cref="T:LogUtils.Enums.LogCategory"/> entries, and can function as a whitelist, or blacklist.<br/>
            This is the best option when you want to limit to a single <see cref="T:LogUtils.Enums.LogCategory"/> entry.<br/>
            <see cref="T:LogUtils.Enums.LogCategoryFilter.ByLevel"/><br/>
            Supports matching against, and up to a specific <see cref="T:LogUtils.Enums.LogCategoryLevels"/> value, the means to which logging categories are organized based on their importance<br/>
            or "severity" of the message. For instance, setting the filter to <see cref="F:LogUtils.Enums.LogCategoryLevels.Warning"/> will filter <see cref="F:LogUtils.Enums.LogCategoryLevels.Info"/> messages,
            but not <see cref="F:LogUtils.Enums.LogCategoryLevels.Error"/> messages.<br/>
            Supports matching against a specific <see cref="T:LogUtils.Enums.LogCategoryLevels"/> which contains all <see cref="T:LogUtils.Enums.LogCategory"/> instances belonging to that level.
            </summary>
        </member>
        <member name="T:LogUtils.Enums.LogCategoryFilter.ByCategory">
            <summary>
            See <see cref="T:LogUtils.Enums.LogCategoryFilter"/> for class description
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.ByCategory.IsAllowed(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.ByCategory.CompareTo(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Enums.LogCategoryFilter.ByLevel">
            <summary>
            See <see cref="T:LogUtils.Enums.LogCategoryFilter"/> for class description
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.ByLevel.IsAllowed(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.ByLevel.CompareTo(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Enums.LogCategoryFilter.BySpecificLevel">
            <summary>
            Allow filtering by one, or more specific category levels. Unlock <see cref="T:LogUtils.Enums.LogCategoryFilter.ByLevel"/> filtering, this filter does not operate on a range of values
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.BySpecificLevel.IsAllowed(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.BySpecificLevel.CompareTo(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.IFilter`1.IsAllowed(`0)">
            <summary>
            Check that an entry is allowed according to defined filter criteria
            </summary>
        </member>
        <member name="T:LogUtils.Enums.LogCategoryLevelMap">
            <summary>
            Class for accessing the default <see cref="T:LogUtils.Enums.LogCategoryLevels"/>, and other internal functions for mapping <see cref="T:BepInEx.Logging.LogLevel"/> to an associated <see cref="T:LogUtils.Enums.LogCategoryLevels"/>
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogCategoryLevelMap.DefaultLevel">
            <summary>
            The value that is assigned before a more specific category level is applied
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryLevelMap.GetEquivalent(BepInEx.Logging.LogLevel@,System.Boolean)">
            <summary>
            Implementation doesn't account for composites
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryLevelMap.GetEquivalentSlow(BepInEx.Logging.LogLevel@)">
            <summary>
            Implementation accounts for composites
            </summary>
        </member>
        <member name="T:LogUtils.Enums.LogCategoryLevels">
            <summary>
            A slightly modified set of values based on <see cref="T:BepInEx.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="T:LogUtils.Enums.LogGroupID">
            <summary>
            A type of <see cref="T:LogUtils.Enums.LogID"/> representing a log file group.
            </summary>
            <remarks>
            Log group properties may be accessed, and changed through the <see cref="P:LogUtils.Enums.LogGroupID.Properties"/> field.
            </remarks>
        </member>
        <member name="F:LogUtils.Enums.LogGroupID.ID_PREFIX">
            <summary>
            This prefix differentiates log group entries from log file entries
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogGroupID.RegistrationStage">
            <summary>
            Registration may be handled through the <see cref="T:LogUtils.Enums.SharedExtEnum`1"/> constructor only when no other existing reference to this <see cref="T:LogUtils.Enums.LogID"/> value is present.  
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogGroupID.Tag">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.LogGroupID.Properties">
            <inheritdoc cref="P:LogUtils.Properties.IPropertyHolder.Properties"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.#ctor(System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.#ctor(System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:LogUtils.Enums.LogGroupID"/> instance.
            </summary>
            <inheritdoc cref="M:LogUtils.Enums.LogID.#ctor(System.String,LogUtils.Enums.LogAccess,System.Boolean)"/>
            <param name="value">The value that identifies the <see cref="T:LogUtils.Enums.LogGroupID"/> instance</param>
            <param name="path">An optional path that all group members will have in common</param>
            <param name="register"></param>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.Register">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Log group is anonymous</exception>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.CheckTag(System.String)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Enums.LogGroupID.Factory">
            <inheritdoc cref="F:LogUtils.Enums.LogID.Factory"/>
        </member>
        <member name="T:LogUtils.Enums.LogGroupID.FactoryImpl">
            <summary>
            Factory implementation
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateNamedGroup(System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateNamedGroup(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateNamedGroup(System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateNamedGroup(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateNamedGroup(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Creates a <see cref="T:LogUtils.Enums.LogGroupID"/> instance with an identifying name value.
            </summary>
            <param name="name">Unique identifying value for the group.</param>
            <param name="path">Default folder location (including folder name) of log group files.</param>
            <param name="modIDHint">The plugin ID that identifies a mod specific folder location to associate with the group path.</param>
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.#ctor(System.String,System.String,System.Boolean)"/>
            <param name="register"></param>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateAnonymousGroup">
            <summary>
            Creates a <see cref="T:LogUtils.Enums.LogGroupID"/> instance without an identifying name or path.
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateAnonymousGroup(System.String)">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateAnonymousGroup(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateAnonymousGroup(System.String,System.String)">
            <summary>
            Creates a <see cref="T:LogUtils.Enums.LogGroupID"/> instance without an identifying name value.
            </summary>
            <param name="path">Default folder location (including folder name) of log group files.</param>
            <param name="modIDHint">The plugin ID that identifies a mod specific folder location to associate with the group path.</param>
        </member>
        <member name="T:LogUtils.Enums.LogGroupID.IFactory">
            <summary>
            Represents a type exposing <see cref="T:LogUtils.Enums.LogID"/> construction options
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.IFactory.CreateComparisonID(System.String)">
            <inheritdoc cref="M:LogUtils.Enums.ComparisonLogID.#ctor(System.String,LogUtils.Enums.LogIDType)"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.IFactory.CreateNamedGroup(System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateNamedGroup(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.IFactory.CreateNamedGroup(System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateNamedGroup(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.IFactory.CreateNamedGroup(System.String,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateNamedGroup(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.IFactory.CreateAnonymousGroup">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateAnonymousGroup"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.IFactory.CreateAnonymousGroup(System.String)">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateAnonymousGroup(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupID.IFactory.CreateAnonymousGroup(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Enums.LogGroupID.FactoryImpl.CreateAnonymousGroup(System.String,System.String)"/>
        </member>
        <member name="T:LogUtils.Enums.LogID">
            <summary>
            An <see cref="T:ExtEnum`1"/> type representing a log file.
            </summary>
            <remarks>
            Log file properties may be accessed, and changed through the <see cref="P:LogUtils.Enums.LogID.Properties"/> field.<br/>
            Implements <see cref="T:LogUtils.Enums.ILogTarget"/> interface.<br/>
            Note: This type serves as the base class for <see cref="T:LogUtils.Enums.LogGroupID"/>, which is designed for inheritance of log properties, not as a logging target.
            </remarks>
        </member>
        <member name="P:LogUtils.Enums.LogID.RegistrationStage">
            <summary>
            Registration may be handled through the <see cref="T:LogUtils.Enums.SharedExtEnum`1"/> constructor only when no other existing reference to this <see cref="T:LogUtils.Enums.LogID"/> value is present.  
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogID.Properties">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.LogID.Tag">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Enums.LogID.Access">
            <summary>
            Acts as a permission flag that affects the behavior of loggers, and the handling of logging requests targeting this <see cref="T:LogUtils.Enums.LogID"/> instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogID.HasLocalAccess">
            <summary>
            Checks that <see cref="T:LogUtils.Enums.LogID"/> will be handled with a local context when passed to a logger
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogID.IsEnabled">
            <summary>
            Controls whether messages targetting this log file can be handled by a logger
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogID.IsInstanceEnabled">
            <summary>
            A flag that controls whether logging should be permitted for this <see cref="T:LogUtils.Enums.LogID"/> instance
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogID.IsGameControlled">
            <summary>
            A flag that indicates that this represents an existing game-controlled log file
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(System.String,LogUtils.Enums.LogAccess,System.Boolean)">
            <summary>
            Creates a new <see cref="T:LogUtils.Enums.LogID"/> instance.
            </summary>
            <param name="filename">The filename, and optional path to target and use for logging.<br/>
            The ExtEnum value will be equivalent to the filename portion of this parameter without the file extension.<br/>
            A filename without a path will default to StreamingAssets directory as a path unless an existing <see cref="T:LogUtils.Enums.LogID"/> with the specified filename is already registered.
            </param>
            <param name="access">Modifier that affects who may access and use the log file.<br/>
            To access a log file you control, use <b>Private/FullAccess</b>. To access a log file you do not control, use <b>RemoteAccessOnly</b>.
            </param>
            <param name="register">Sets registration state for the ExtEnum.<br/>
            <para>Registration affects whether a <see cref="T:LogUtils.Enums.LogID"/> gets its own properties that write to file on game close. An unregistered <see cref="T:LogUtils.Enums.LogID"/> will still get its own properties,<br/>
            but those properties, and changes to those properties wont be saved to file.</para>
            <para>Avoid registering a <see cref="T:LogUtils.Enums.LogID"/> that is temporary, and your mod is designated for public release.</para>
            </param>
            <exception cref="T:System.ArgumentNullException">Filename provided is null</exception>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.Enums.LogID"/> instance without attempting to create properties for it.
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:LogUtils.Enums.LogID"/> instance using a filename, and assuming a default/preexisting registered path.
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(System.String,System.String,LogUtils.Enums.LogAccess,System.Boolean)">
            <summary>
            Creates a new <see cref="T:LogUtils.Enums.LogID"/> instance.
            </summary>
            <param name="filename">The filename to target, and use for logging.<br/>
            The ExtEnum value will be equivalent to the filename without the file extension.
            </param>
            <param name="relativePathNoFile">The path to the log file.<br/>
            Setting to null will default to the StreamingAssets directory as a path unless an existing <see cref="T:LogUtils.Enums.LogID"/> with the specified filename is already registered.
            </param>
            <param name="access">Modifier that affects who may access and use the log file.<br/>
            To access a log file you control, use <b>Private/FullAccess</b>. To access a log file you do not control, use <b>RemoteAccessOnly</b>.
            </param>
            <param name="register">Sets registration state for the ExtEnum.<br/>
            <para>Registration affects whether a <see cref="T:LogUtils.Enums.LogID"/> gets its own properties that write to file on game close. An unregistered <see cref="T:LogUtils.Enums.LogID"/> will still get its own properties,<br/>
            but those properties, and changes to those properties wont be saved to file.</para>
            <para>Avoid registering a <see cref="T:LogUtils.Enums.LogID"/> that is temporary, and your mod is designated for public release.</para>
            </param>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(LogUtils.Enums.LogGroupID,System.String,LogUtils.Enums.LogAccess)">
            <summary>
            Creates a new unregistered <see cref="T:LogUtils.Enums.LogID"/> instance associated with a group identifier.
            </summary>
            <remarks>Log properties will be inherited by the group id <i>unless</i> the specified logging path is already associated with a registered <see cref="T:LogUtils.Enums.LogID"/> instance.</remarks>
            <param name="groupID">The group to associate this instance with.</param>
            <param name="filename">The filename, and optional path to target and use for logging.<br/>
            The ExtEnum value will be equivalent to the filename portion of this parameter without the file extension.<br/>
            A filename without a path will default to StreamingAssets directory as a path unless an existing <see cref="T:LogUtils.Enums.LogID"/> with the specified filename is already registered.
            </param>
            <param name="access">Modifier that affects who may access and use the log file.<br/>
            To access a log file you control, use <b>Private/FullAccess</b>. To access a log file you do not control, use <b>RemoteAccessOnly</b>.
            </param>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(LogUtils.Enums.LogGroupID,System.String,System.String,LogUtils.Enums.LogAccess)">
            <summary>
            Creates a new unregistered <see cref="T:LogUtils.Enums.LogID"/> instance associated with a group identifier.
            </summary>
            <remarks>Log properties will be inherited by the group id <i>unless</i> the specified logging path is already associated with a registered <see cref="T:LogUtils.Enums.LogID"/> instance.</remarks>
            <param name="groupID">The group to associate this instance with.</param>
            <param name="filename">The filename to target, and use for logging.<br/>
            The ExtEnum value will be equivalent to the filename without the file extension.
            </param>
            <param name="relativePathNoFile">The path to the log file.<br/>
            Setting to null will default to the StreamingAssets directory as a path unless an existing <see cref="T:LogUtils.Enums.LogID"/> with the specified filename is already registered.
            </param>
            <param name="access">Modifier that affects who may access and use the log file.<br/>
            To access a log file you control, use <b>Private/FullAccess</b>. To access a log file you do not control, use <b>RemoteAccessOnly</b>.
            </param>
        </member>
        <member name="M:LogUtils.Enums.LogID.CompleteRegistration">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogID.CheckTag(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogID.Equals(LogUtils.Enums.LogID)">
            <inheritdoc cref="M:LogUtils.Enums.LogID.Equals(LogUtils.Enums.LogID,System.Boolean)"/>
            <remarks>The log path is included as part of the equality check</remarks>
        </member>
        <member name="M:LogUtils.Enums.LogID.Equals(LogUtils.Enums.LogID,System.Boolean)">
            <summary>
            Determines whether the specified <see cref="T:LogUtils.Enums.LogID"/> instance is equal to the current instance
            </summary>
            <param name="idOther">The <see cref="T:LogUtils.Enums.LogID"/> instance to compare with the current instance</param>
            <param name="doPathCheck">Whether the folder path should also be considered in the equality check</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.Equals(LogUtils.Properties.LogProperties)">
            <summary>
            Determines whether the current <see cref="T:LogUtils.Enums.LogID"/> instance is associated with an equivalent <see cref="T:LogUtils.Properties.LogProperties"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogID.Register">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogID.Unregister">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogID.IsGroupType(LogUtils.Enums.LogID)">
            <summary>
            Determine if <see cref="T:LogUtils.Enums.LogID"/> reference represents a file, or a log group
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.Sanitize(System.String)">
            <summary>
            Converts a filename input into a LogUtils supported filename
            </summary>
            <exception cref="T:System.ArgumentNullException">Filename provided is null</exception>
        </member>
        <member name="M:LogUtils.Enums.LogID.GetLock">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Enums.LogID.NotUsed">
            <summary>An unregistered <see cref="T:LogUtils.Enums.LogID"/> designed to be used as a throwaway parameter</summary>
        </member>
        <member name="F:LogUtils.Enums.LogID.Factory">
            <summary>
            Access factory methods for creating specific kinds of <see cref="T:LogUtils.Enums.LogID"/> instances 
            </summary>
        </member>
        <member name="T:LogUtils.Enums.LogID.FactoryImpl">
            <summary>
            Factory implementation
            </summary>
        </member>
        <member name="T:LogUtils.Enums.LogID.IFactory">
            <summary>
            Represents a type exposing <see cref="T:LogUtils.Enums.LogID"/> construction options
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.IFactory.CreateID(System.String,LogUtils.Enums.LogAccess,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Enums.LogID.#ctor(System.String,LogUtils.Enums.LogAccess,System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Enums.LogID.IFactory.CreateID(System.String,System.String,LogUtils.Enums.LogAccess,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Enums.LogID.#ctor(System.String,System.String,LogUtils.Enums.LogAccess,System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Enums.LogID.IFactory.CreateTemporaryID(System.String,System.String)">
            <summary>
            Creates a <see cref="T:LogUtils.Enums.LogID"/> instance designed to accessed only in a local context
            </summary>
            <inheritdoc cref="M:LogUtils.Enums.LogID.#ctor(System.String,System.String,LogUtils.Enums.LogAccess,System.Boolean)" select="params"/>
            <exception cref="T:System.InvalidOperationException">A registered <see cref="T:LogUtils.Enums.LogID"/> instance already exists</exception>
        </member>
        <member name="M:LogUtils.Enums.LogID.IFactory.CreateComparisonID(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Enums.ComparisonLogID.#ctor(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Enums.LogID.IFactory.CreateComparisonID(System.String,LogUtils.Enums.LogIDType)">
            <inheritdoc cref="M:LogUtils.Enums.ComparisonLogID.#ctor(System.String,LogUtils.Enums.LogIDType)"/>
        </member>
        <member name="M:LogUtils.Enums.LogID.CreateTemporaryID(System.String,System.String)">
            <inheritdoc cref="M:LogUtils.Enums.LogID.IFactory.CreateTemporaryID(System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.Enums.LogID.GetEntries(System.Boolean)">
            <summary>
            Iterates through a collection of registered <see cref="T:LogUtils.Enums.LogID"/> instances
            </summary>
            <param name="includeGroupIDs">A flag that allows log group identifiers to be included in the results</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.Find(System.String,System.String)">
            <summary>
            Finds a registered <see cref="T:LogUtils.Enums.LogID"/> instance with the given filename, and path
            </summary>
            <remarks>
            Applies to log files only<br/>
            - Compares against ID, Filename, and CurrentFilename fields
            </remarks>
            <param name="filename">The filename to search for</param>
            <param name="relativePathNoFile">The filepath to search for. When set to null, any filename match will be returned with custom root being prioritized</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.Find(System.String,LogUtils.Properties.CompareOptions,System.Boolean)">
            <summary>
            Finds a registered <see cref="T:LogUtils.Enums.LogID"/> instance with the given identifying value
            </summary>
            <param name="value">The value to search for</param>
            <param name="compareOptions">Represents options that determine which fields to check against</param>
            <param name="includeGroupIDs">A flag that allows log group identifiers to be included in the results</param>
            <returns>A <see cref="T:LogUtils.Enums.LogID"/> instance that matches the search criteria, or null if no match was found</returns>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindAll(System.String)">
            <summary>
            Finds all registered <see cref="T:LogUtils.Enums.LogID"/> instance with the given filename
            </summary>
            <remarks>
            Applies to log files only<br/>
            - Compares against ID, Filename, and CurrentFilename fields
            </remarks>
            <param name="filename">The filename to search for</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindAll(System.String,System.Boolean)">
            <summary>
            Finds all registered <see cref="T:LogUtils.Enums.LogID"/> instance matching against common identifying fields
            </summary>
            <remarks>
            - Compares against ID, Filename, and CurrentFilename fields
            </remarks>
            <param name="value">The value to search for</param>
            <param name="includeGroupIDs">A flag that allows log group identifiers to be included in the results</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindAll(System.String,LogUtils.Properties.CompareOptions)">
            <summary>
            Finds all registered <see cref="T:LogUtils.Enums.LogID"/> instances with the given filename
            </summary>
            <remarks>Applies to log files only</remarks>
            <param name="filename">The filename to search for</param>
            <param name="compareOptions">Represents options that determine which fields to check against</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindAll(System.String,LogUtils.Properties.CompareOptions,System.Boolean)">
            <summary>
            Finds all registered <see cref="T:LogUtils.Enums.LogID"/> instances matching against one or more identifying fields
            </summary>
            <param name="value">The value to search for</param>
            <param name="compareOptions">Represents options that determine which fields to check against</param>
            <param name="includeGroupIDs">A flag that allows log group identifiers to be included in the results</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindAll(System.Func{LogUtils.Properties.LogProperties,System.Boolean})">
            <summary>
            Finds all registered <see cref="T:LogUtils.Enums.LogID"/> instances that match a predicate
            </summary>
            <remarks>Applies to log files only</remarks>
            <param name="predicate">The predicate to match</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindAll(System.Func{LogUtils.Properties.LogProperties,System.Boolean},System.Boolean)">
            <summary>
            Finds all registered <see cref="T:LogUtils.Enums.LogID"/> instances that match a predicate
            </summary>
            <param name="predicate">The predicate to match</param>
            <param name="includeGroupIDs">A flag that allows log group identifiers to be included in the results</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindByTag(System.String)">
            <summary>
            Finds all registered <see cref="T:LogUtils.Enums.LogID"/> instances with the given tag
            </summary>
            <remarks>Applies to log files only</remarks>
            <param name="tag">The tag to search for</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindByTag(System.String,System.Boolean)">
            <summary>
            Finds all registered <see cref="T:LogUtils.Enums.LogID"/> instances with the given tag
            </summary>
            <param name="tag">The tag to search for</param>
            <param name="includeGroupIDs">A flag that allows log group identifiers to be included in the results</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.IsRegistered(System.String,System.String)">
            <summary>
            Checks whether file, and path combination matches the file and path information of an existing registered <see cref="T:LogUtils.Enums.LogID"/> instance
            </summary>
            <remarks>Applies to log files only</remarks>
            <param name="filename">The filename to search for</param>
            <param name="relativePathNoFile">The filepath to search for. When set to null, any filename match will be returned with custom root being prioritized</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.IsRegistered(System.String,System.Boolean)">
            <summary>
            Checks whether a registered <see cref="T:LogUtils.Enums.LogID"/> instance with the given identifying value exists
            </summary>
            <param name="value">The value to search for</param>
            <param name="includeGroupIDs">A flag that allows log group identifiers to be included in the results</param>
        </member>
        <member name="T:LogUtils.Enums.LogAccess">
            <summary>
            Logger permission values - Assign to a <see cref="T:LogUtils.Enums.LogID"/> provided to a logger to influence how messages are logged, and handled by that logger
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogAccess.FullAccess">
            <summary>
            The <see cref="T:LogUtils.Enums.LogID"/> can be handled by either local, or remote loggers
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogAccess.RemoteAccessOnly">
            <summary>
            The <see cref="T:LogUtils.Enums.LogID"/> is only able to be handled as a remote request from one logger to another
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogAccess.Private">
            <summary>
            The <see cref="T:LogUtils.Enums.LogID"/> can only be handled through a local log request
            </summary>
        </member>
        <member name="T:LogUtils.Enums.LogIDType">
            <summary>
            A context identifier that describes the purpose of a <see cref="T:LogUtils.Enums.LogID"/>
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogIDType.File">
            <summary>The context represents a log file</summary>
        </member>
        <member name="F:LogUtils.Enums.LogIDType.Group">
            <summary>The context represents a log group</summary>
        </member>
        <member name="T:LogUtils.Enums.ILogTarget">
            <summary>
            Represents a target for logged messages (such as a log file or console)
            </summary>
        </member>
        <member name="P:LogUtils.Enums.ILogTarget.Value">
            <summary>
            A value string assigned on construction
            </summary>
        </member>
        <member name="P:LogUtils.Enums.ILogTarget.IsEnabled">
            <summary>
            Indicates whether this target is available to be handled
            </summary>
        </member>
        <member name="M:LogUtils.Enums.ILogTarget.GetRequestType(LogUtils.ILogHandler)">
            <summary>
            The RequestType that should be assigned when this target is ready to be handled
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogTargetCollection.AllTargets">
            <summary>
            Creates an independent collection instances containing the same collection items as this instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogTargetCollection.Count">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.#ctor">
            <summary>
            Constructs a new target collection containing no targets
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.#ctor(LogUtils.Enums.CompositeLogTarget)">
            <summary>
            Constructs a new target collection containing the elements of the provided composite object
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.#ctor(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget})">
            <summary>
            Constructs a new target collection containing the elements of the provided <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.Clear">
            <summary>
            Removes all elements from the collection
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.Contains(LogUtils.Enums.ILogTarget)">
            <summary>
            Checks whether the collection contains a given log target
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.Clone">
            <summary>
            Creates a new object that is a member deep copy of this instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCombiner.Combine(LogUtils.Enums.ILogTarget,LogUtils.Enums.ILogTarget)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCombiner.Distinct(LogUtils.Enums.ILogTarget,LogUtils.Enums.ILogTarget)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCombiner.GetComplement(LogUtils.Enums.ILogTarget)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCombiner.Intersect(LogUtils.Enums.ILogTarget,LogUtils.Enums.ILogTarget)">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.Index">
            <inheritdoc cref="P:LogUtils.Enums.IExtEnumBase.Index"/>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.BaseIndex">
            <summary>
            The underlying <see cref="T:ExtEnum`1"/> value index (used during the registration process when values are being synced)
            </summary>
        </member>
        <member name="F:LogUtils.Enums.SharedExtEnum`1.ManagedReference">
            <summary>
            A null-safe reference to the <see cref="T:LogUtils.Enums.SharedExtEnum`1"/> shared instance that any mod can access
            </summary>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.Registered">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.Tag">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.Value">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.value">
            <inheritdoc cref="P:LogUtils.Enums.SharedExtEnum`1.Value"/>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.RegistrationStage">
            <summary>
            The current stage in assigning a registered state to this instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.EntryAt(System.Int32)">
            <summary>
            Retrieves an <see cref="T:ExtEnum`1"/> instance at the specified index
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The index provided is outside the bounds of the collection</exception>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.Parse(System.String)">
            <summary>
            A static means of finding a registered instance, or creating a new instance if there are no registered instances
            </summary>
            <param name="value">Case insensitive value to compare with</param>
            <exception cref="T:System.ArgumentException">The argument provided was not of a valid format</exception>
            <exception cref="T:LogUtils.Enums.ValueNotFoundException">A registered entry was not found with the given value</exception>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.TryParse(System.String,`0@)">
            <summary>
            A static means of finding a registered instance
            </summary>
            <param name="value">Case insensitive value to compare with</param>
            <param name="result">The instance created from the provided value</param>
            <returns>Returns whether a registered instance was found</returns>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.CompleteRegistration">
            <summary>
            Completes the registration process
            </summary>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.Register">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.Unregister">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.RegisterCore">
            <inheritdoc cref="M:LogUtils.Enums.SharedExtEnum`1.Register"/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.UnregisterCore">
            <inheritdoc cref="M:LogUtils.Enums.SharedExtEnum`1.Unregister"/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.CheckTag(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.CompareTo(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.BaseEquals(`0)">
            <summary>
            Indicates whether the current object is equal to another object of the same type (utilizes the base value hashcode comparison to determine equality)
            </summary>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.Equals(`0)">
            <summary>
            Indicates whether the current object is equal to another object of the same type (utilizes a customized value hashcode comparison to determine equality)
            </summary>
        </member>
        <member name="T:LogUtils.Enums.SharedExtEnum`1.RegistrationStatus">
            <summary>
            Represents the initialization state of the registration process
            </summary>
        </member>
        <member name="F:LogUtils.Enums.SharedExtEnum`1.RegistrationStatus.Ready">
            <summary>Registration can be completed anytime</summary>
        </member>
        <member name="F:LogUtils.Enums.SharedExtEnum`1.RegistrationStatus.WaitingOnSignal">
            <summary>Registration is deferred until a child class signals it is ready to complete registration</summary>
        </member>
        <member name="F:LogUtils.Enums.SharedExtEnum`1.RegistrationStatus.Completed">
            <summary>Registration has been completed</summary>
        </member>
        <member name="T:LogUtils.Enums.ValueNotFoundException">
            <summary>
            Represents an ExtEnum parsing error
            </summary>
        </member>
        <member name="M:LogUtils.Enums.ValueNotFoundException.#ctor(System.String)">
            <summary>
            Represents an ExtEnum parsing error
            </summary>
        </member>
        <member name="F:LogUtils.Events.ConsoleRequestEventArgs.Handled">
            <summary>
            List of <see cref="T:LogUtils.Enums.ConsoleID"/> instances that were transfered from pending status
            </summary>
        </member>
        <member name="F:LogUtils.Events.ConsoleRequestEventArgs.Pending">
            <summary>
            List of <see cref="T:LogUtils.Enums.ConsoleID"/> instances waiting to be handled
            </summary>
        </member>
        <member name="P:LogUtils.Events.ConsoleRequestEventArgs.Rules">
            <inheritdoc cref="F:LogUtils.Console.ConsoleLogWriter.Rules"/>
            <remarks>Null when a writer isn't currently assigned</remarks>
        </member>
        <member name="M:LogUtils.Events.LogEventArgs.Clone(LogUtils.Enums.LogID)">
            <summary>
            Clones the current <see cref="T:System.EventArgs"/> assigning it the provided <see cref="T:LogUtils.Enums.LogID"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Events.LogEventArgs.Clone">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Events.LogMovePendingEventArgs.MovePath">
            <summary>
            The new path, may be the same path if the file was only renamed
            </summary>
        </member>
        <member name="F:LogUtils.Events.LogMovePendingEventArgs.NewFilename">
            <summary>
            The pending filename to use when it is different from the current filename, otherwise null
            </summary>
        </member>
        <member name="F:LogUtils.Events.LogRequestEventArgs.ExtraArgs">
            <summary>
            A field for extra arguments - Use in cases when it is inconvenient to replace existing argument data  
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.LogSource">
            <summary>
            Contains source information needed to log through the BepInEx logger
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.Category">
            <summary>
            The <see cref="T:LogUtils.Enums.LogCategory"/> instance associated with the message (equivalent to <see cref="T:UnityEngine.LogType"/> (Unity), and <see cref="T:BepInEx.Logging.LogLevel"/> (BepInEx))
            </summary>
        </member>
        <member name="F:LogUtils.Events.LogRequestEventArgs.MessageObject">
            <summary>
            An object targeted for logging
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.Message">
            <summary>
            A message targeted for logging
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.FormattableMessage">
            <summary>
            Returns targeted message object as an <see cref="T:System.IFormattable"/>
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.MessageColor">
            <summary>
            The color to be used by default for a message
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.Rules">
            <summary>
            The message format rules associated with this message data
            </summary>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.CacheMessageTotal">
            <summary>
             Assigns a value to <see cref="P:LogUtils.Events.LogRequestEventArgs.TotalMessagesLogged"/> that will not change when new messages are logged 
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.PendingConsoleIDs">
            <summary>
            Retrieves all <see cref="T:LogUtils.Enums.ConsoleID"/> instances that have yet to handle the message data
            </summary>
        </member>
        <member name="F:LogUtils.Events.LogRequestEventArgs.ShouldFilter">
            <summary>
            Whether this request's message should be filtered after request is successfully handled
            </summary>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,LogUtils.Enums.LogCategory)">
            <summary>
            Creates a new data storage instance for a <see cref="T:LogUtils.Requests.LogRequest"/> event
            </summary>
            <param name="logID">The <see cref="T:LogUtils.Enums.LogID"/> to target</param>
            <param name="messageData">The message to log</param>
            <param name="category">The category associated with the message</param>
            <exception cref="T:System.NullReferenceException">The <see cref="T:LogUtils.Enums.LogID"/>, or its properties field is null</exception>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,BepInEx.Logging.LogLevel)">
            <inheritdoc cref="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,UnityEngine.LogType)">
            <inheritdoc cref="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,LogUtils.Enums.LogCategory)">
            <summary>
            Creates a new data storage instance for a <see cref="T:LogUtils.Requests.LogRequest"/> event
            </summary>
            <param name="consoleID">The <see cref="T:LogUtils.Enums.ConsoleID"/> to target</param>
            <param name="messageData">The message to log</param>
            <param name="category">The category associated with the message</param>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,BepInEx.Logging.LogLevel)">
            <inheritdoc cref="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,UnityEngine.LogType)">
            <inheritdoc cref="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.FindData``1">
            <summary>
            Finds the first match of a given type, or returns null
            </summary>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.GetElement">
            <summary>
            Constructs a JollyCoop LogElement struct using stored event data
            </summary>
        </member>
        <member name="F:LogUtils.Events.UtilityEvents.OnNewUpdateSynced">
            <summary>
            Gets invoked every frame from the base Update method of the abstract MainLoopProcess class. This EventHandler will be synced to the framesPerSecond defined by 
            that process
            </summary>
        </member>
        <member name="P:LogUtils.ExceptionInfo.Message">
            <inheritdoc cref="P:System.Exception.Message"/>
        </member>
        <member name="P:LogUtils.ExceptionInfo.StackTrace">
            <inheritdoc cref="P:System.Exception.StackTrace"/>
        </member>
        <member name="P:LogUtils.ExceptionInfo.InnerException">
            <summary>
            Gets the underlying <see cref="T:System.Exception"/> represented by this object. If such information is unavailable, <see langword="null"/> is returned.
            </summary>
        </member>
        <member name="P:LogUtils.ExceptionInfo.HelpLink">
            <inheritdoc cref="P:System.Exception.HelpLink"/>
            <exception cref="T:System.NullReferenceException">Attempted to set field without underlying <see cref="T:System.Exception"/> present</exception>
        </member>
        <member name="P:LogUtils.ExceptionInfo.Source">
            <inheritdoc cref="P:System.Exception.Source"/>
            <exception cref="T:System.NullReferenceException">Attempted to set field without underlying <see cref="T:System.Exception"/> present</exception>
        </member>
        <member name="P:LogUtils.ExceptionInfo.TargetSite">
            <inheritdoc cref="P:System.Exception.TargetSite"/>
        </member>
        <member name="M:LogUtils.ExceptionInfo.Equals(LogUtils.ExceptionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.ExceptionInfo.GetBaseException">
            <inheritdoc cref="M:System.Exception.GetBaseException"/>
        </member>
        <member name="M:LogUtils.ExceptionInfo.GetUnderlyingInnerException">
            <summary>
            Gets the value of the <see cref="P:System.Exception.InnerException"/> property of the <see cref="T:System.Exception"/> instance represented by this object.
            </summary>
        </member>
        <member name="M:LogUtils.ExceptionInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.ExceptionInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.FilteredStringEntry.CheckValidation">
            <summary>
            Checks whether the filter is currently applicable
            </summary>
            <returns>true, when applicable, false otherwise</returns>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.Log(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogDebug(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogInfo(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogImportant(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogMessage(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogWarning(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogError(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogFatal(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.Log(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.Log(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.Log(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.Log(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogDebug(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogInfo(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogImportant(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogMessage(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogWarning(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogError(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.LogFatal(LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.Log(UnityEngine.LogType,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.Log(BepInEx.Logging.LogLevel,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.Log(LogUtils.Enums.LogCategory,LogUtils.Formatting.InterpolatedStringHandler)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.FormattableLogWrapper.Equals(LogUtils.ILogger)">
            <inheritdoc/>
            <remarks>Both instance, and value of instances are evaluated for equality</remarks>
        </member>
        <member name="T:LogUtils.Formatting.AnsiColorFormatProvider">
            <summary>
            A type of ColorFormatProvider that replaces color data with ANSI color codes
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.AnsiColorFormatProvider.MessageColor">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.AnsiColorFormatProvider.ApplyFormat(System.String,UnityEngine.Color)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.AnsiColorFormatProvider.Format(System.String,System.Object,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.AnsiColorFormatProvider.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.AnsiColorFormatProvider.ResetColor(System.Text.StringBuilder,LogUtils.Formatting.FormatData)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Formatting.EmptyColorFormatProvider">
            <summary>
            A type of ColorFormatProvider that replaces color data with empty strings
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.EmptyColorFormatProvider.MessageColor">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.EmptyColorFormatProvider.ApplyFormat(System.String,UnityEngine.Color)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.EmptyColorFormatProvider.Format(System.String,System.Object,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.EmptyColorFormatProvider.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.EmptyColorFormatProvider.ResetColor(System.Text.StringBuilder,LogUtils.Formatting.FormatData)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Formatting.FormatData">
            <summary>
            A data class for storing format information
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatData.Argument">
            <summary>
            The format argument
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.FormatData.IsColorData">
            <summary>
            Checks that Argument is a <see cref="T:UnityEngine.Color"/> or a <see cref="T:System.ConsoleColor"/>
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatData.BuildOffset">
            <summary>
            The positional offset between the local build position, and the actual position in the formatted string
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatData.LocalPosition">
            <summary>
            The index position in the local StringBuilder handling the format data
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.FormatData.Position">
            <summary>
            The index position of the format argument in the formatted string
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatData.Range">
            <summary>
            The number of valid chars to apply color formatting
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.FormatData.GetColor">
            <summary>
            Converts format argument into a <see cref="T:UnityEngine.Color"/> value
            </summary>
            <exception cref="T:System.InvalidCastException">The format argument cannot be cast to a <see cref="T:UnityEngine.Color"/> value</exception>
        </member>
        <member name="M:LogUtils.Formatting.FormatData.ResolveArgument(System.Object,System.ICustomFormatter,System.Int32)">
            <summary>
            Converts argument into a <see cref="T:LogUtils.Formatting.FormatData"/> object when passed an implementation of <see cref="T:LogUtils.Formatting.IColorFormatProvider"/>, and the argument is a supported Color type 
            </summary>
            <param name="formatArgument">An argument value to a formatted string</param>
            <param name="formatter">Handler responsible for formatting <paramref name="formatArgument"/></param>
            <param name="commaValue">Alignment value of <paramref name="formatArgument"/>. This value is borrowed, and used as a range length.</param>
            <returns>The replacement for <paramref name="formatArgument"/>, or the same instance when extra data is not required</returns>
        </member>
        <member name="M:LogUtils.Formatting.FormatData.ResolveArgument(System.Object,LogUtils.Formatting.IColorFormatProvider,System.Int32)">
            <inheritdoc cref="M:LogUtils.Formatting.FormatData.ResolveArgument(System.Object,System.ICustomFormatter,System.Int32)"/>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.Data.Entries">
            <summary>
            Collection of active format data being processed
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.Data.RangeCounter">
            <summary>
            A check on how many characters are needed to satisfy an argument's range requirement
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.Data.BypassColorCancellation">
            <summary>
            Allows color range check to not be reset when an ANSI color code is detected
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.Data.ExpectAnsiCode">
            <summary>
            Ansi color code escape sequence has been detected. Flag ensures that the code itself isn't considered as including colorable characters
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.FormatDataAccess.Data.Clear">
            <summary>
            Set data fields back to default values
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.NodeData.Builder">
            <summary>
            The builder in control of building the formatted string
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.NodeData.Current">
            <summary>
            The format argument currently being processed
            </summary>
        </member>
        <member name="T:LogUtils.Formatting.IColorFormatProvider">
            <summary>
            An interface for handling color data processed through a FormattableString
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.IColorFormatProvider.ApplyFormat(System.String,UnityEngine.Color)">
            <summary>
            Applies color format to a message string
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.IColorFormatProvider.ResetColor(System.Text.StringBuilder,LogUtils.Formatting.FormatData)">
            <summary>
            Resets the text color back to a default value
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.IColorFormatProvider.MessageColor">
            <summary>
            The color that will be used as the default text color for handled messages
            </summary>
        </member>
        <member name="T:LogUtils.Formatting.InterpolatedStringHandler">
            <summary>
            A class that processes interpolated string data into a formatted string
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.InterpolatedStringHandler.Format">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Formatting.InterpolatedStringHandler.ArgumentCount">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.AppendLiteral(System.String)">
            <summary>
            Adds a string component for later formatting
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.AppendFormatted``1(``0)">
            <summary>
            Adds an object component for later formatting
            </summary>
            <param name="argument">An argument to be formatted</param>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.AppendFormatted``1(``0,System.Int32)">
            <inheritdoc cref="M:LogUtils.Formatting.InterpolatedStringHandler.AppendFormatted``1(``0)"/>
            <param name="argument">An argument to be formatted</param>
            <param name="alignment">Value affects padded space unless used with a <see cref="T:UnityEngine.Color"/> or <see cref="T:System.ConsoleColor"/>, of which it represents the number of formatted characters</param>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.AppendFormatted``1(``0,System.String)">
            <inheritdoc cref="M:LogUtils.Formatting.InterpolatedStringHandler.AppendFormatted``1(``0)"/>
            <param name="argument">An argument to be formatted</param>
            <param name="format">Format specification applicable to an argument</param>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.AppendFormatted``1(``0,System.String,System.Int32)">
            <inheritdoc cref="M:LogUtils.Formatting.InterpolatedStringHandler.AppendFormatted``1(``0)"/>
            <param name="argument">An argument to be formatted</param>
            <param name="format">Format specification applicable to an argument</param>
            <param name="alignment">Value affects padded space unless used with a <see cref="T:UnityEngine.Color"/> or <see cref="T:System.ConsoleColor"/>, of which it represents the number of formatted characters</param>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.AppendFormattedRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a range of arguments to be formatted
            </summary>
            <param name="arguments">An enumeration of arguments to be formatted</param>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.BuildFormat">
            <summary>
            Builds the format string out of appended string literals, and format arguments
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.GetArguments">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.GetArgument(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Formatting.InterpolatedStringHandler.LiteralInfo.BuildPosition">
            <summary>
            The position in the builder string at the time of format
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.InterpolatedStringHandler.LiteralInfo.Value">
            <summary>
            The value of the literal
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.InterpolatedStringHandler.ArgumentInfo.Value">
            <summary>
            An object, or value to be inserted into the builder string
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.InterpolatedStringHandler.ArgumentInfo.Format">
            <summary>
            The format specifier code
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.InterpolatedStringHandler.ArgumentInfo.BuildPosition">
            <summary>
            The position in the builder string at the time of format
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.InterpolatedStringHandler.ArgumentInfo.Range">
            <summary>
            The number of characters to apply the format
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.InterpolatedStringHandler.FormatProcessor.AccessData">
            <summary>
            Accesses color related format data
            </summary>
        </member>
        <member name="T:LogUtils.Formatting.LogMessageFormatter">
            <summary>
            Applies format logic to message strings
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.LogMessageFormatter.Default">
            <summary>
            The default implementation that applies to most write implementations
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.LogMessageFormatter.ColorFormatter">
            <summary>
            Applies color-based message format changes
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.LogMessageFormatter.#ctor">
            <summary>
            Constructs a LogMessageFormatter instance
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.LogMessageFormatter.#ctor(LogUtils.Formatting.IColorFormatProvider)">
            <summary>
            Constructs a LogMessageFormatter instance
            </summary>
            <param name="colorFormatter">Determines how color format arguments are handled</param>
        </member>
        <member name="M:LogUtils.Formatting.LogMessageFormatter.Format(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Formats message data into a log ready format
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.LogMessageFormatter.ApplyColor(System.String,UnityEngine.Color)">
            <summary>
            Formats color data into a provided message string
            </summary>
        </member>
        <member name="T:LogUtils.Formatting.LogRequestStringFormatter">
            <summary>
            Provides format options for handling internally supported <see cref="T:LogUtils.Requests.LogRequest"/> fields as arguments
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.StringParser.GetLines(System.String,System.Int32)">
            <summary>
            Splits a string by Newline characters
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.StringParser.Format(System.String[],System.String,System.Int32)">
            <summary>
            Takes an array of strings and returns a string containing the first series of characters up to the value of maxChars
            - or the length of the array if maxChars is less than or equal to zero. The separator string is excluded when counting characters
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.StringParser.TrimNewLine(System.String)">
            <summary>
            Trim the last trailing new line from the given string
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.StringProvider.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.GameHooks.Initialize">
            <summary>
            Generates managed hooks, and applies all hooks used by the utility module
            </summary>
        </member>
        <member name="M:LogUtils.GameHooks.Apply">
            <summary>
            Apply hooks used by the utility module
            </summary>
        </member>
        <member name="M:LogUtils.GameHooks.Reload">
            <summary>
            Releases, and then reapply hooks used by the utility module 
            </summary>
        </member>
        <member name="M:LogUtils.GameHooks.Unload">
            <summary>
            Releases all hooks used by the utility module
            </summary>
        </member>
        <member name="M:LogUtils.GameHooks.RainWorld_PostModsInit(On.RainWorld.orig_PostModsInit,RainWorld)">
            <summary>
            Ends the grace period in which newly initialized properties can be freely modified
            </summary>
        </member>
        <member name="F:LogUtils.GameHooks.disableLogClearing">
            <summary>
            This flag prevents clear log functions from activating for Expedition, and JollyCoop
            </summary>
        </member>
        <member name="T:LogUtils.GameLogger">
            <summary>
            A class for handling game-controlled log content
            </summary>
        </member>
        <member name="F:LogUtils.GameLogger.LogFileInProcess">
            <summary>
            Set to the <see cref="T:LogUtils.Enums.LogID"/> of a request while it is being handled through an external logging API accessed by this instance
            </summary>
        </member>
        <member name="M:LogUtils.GameLogger.CanHandle(LogUtils.Enums.LogID)">
            <summary>
            Checks that the provided <see cref="T:LogUtils.Enums.LogID"/> is game-controlled, the only type of <see cref="T:LogUtils.Enums.LogID"/> supported by this instance
            </summary>
        </member>
        <member name="M:LogUtils.GameLogger.GetWriter(LogUtils.Enums.LogID)">
            <summary>
            Retrieves the current <see cref="T:LogUtils.ILogWriter"/> instance for a game-controlled log file 
            </summary>
        </member>
        <member name="M:LogUtils.GameLogger.HandleRequest(LogUtils.Requests.LogRequest)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.GameLogger.LogBepEx(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogBepEx(BepInEx.Logging.ILogSource,LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogUnity(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogUnity(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogUnity(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogExp(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogExp(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogJolly(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogJolly(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Helpers.AssemblyUtils.GetAllTypes">
            <summary>
            Get all types from each assembly in the current domain
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.AssemblyUtils.GetCallingAssembly">
            <summary>
            Get the first calling assembly that is not the executing assembly via a stack trace
            </summary>
            <remarks>Credit for this code goes to WilliamCruisoring</remarks>
        </member>
        <member name="P:LogUtils.Helpers.AttemptCounter.Remaining">
            <summary>
            The number of attempts remaining before maximum attempts is reached
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.AttemptCounter.IsLast">
            <summary>
            Indicates that this is the last attempt, or that there are no attempts remaining
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.AttemptCounter.IsFirst">
            <summary>
            Indicates that this is the first attempt
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.AttemptCounter.Increment">
            <summary>
            Increments the attempt count
            </summary>
            <returns>The new attempt count</returns>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ComparerBase`1.Compare(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ComparerBase`1.Equals(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ComparerBase`1.GetHashCode(`0)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ComparerUtils.FilenameComparer">
            <summary>
            Default implementation for comparing filenames
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ComparerUtils.PathComparer">
            <summary>
            Default implementation for comparing file/folder paths
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ComparerUtils.StringComparerIgnoreCase">
            <summary>
            Default invariant case string comparer used by LogUtils
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ExceptionComparer.MAX_CHARS_DEFAULT">
            <summary>
            The maximum amount of characters to check for exception equality
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ExceptionComparer.MAX_LINES_DEFAULT">
            <summary>
            The maximum amount of new lines to check for exception equality
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ExceptionComparer.MaxLinesToCheck">
            <summary>
            The maximum amount of new lines that can be used to evaluate equality - when set to zero, all lines will be checked
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ExceptionComparer.MaxCharsToCheck">
            <summary>
            The maximum amount of characters that can be used to evaluate equality - when set to zero, no limit will be applied
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExceptionComparer.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates an ExceptionComparer instance
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExceptionComparer.Equals(LogUtils.ExceptionInfo,LogUtils.ExceptionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExceptionComparer.GetHashCode(LogUtils.ExceptionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExtEnumValueComparer`1.Compare(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExtEnumValueComparer`1.Equals(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExtEnumValueComparer`1.GetHashCode(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExtEnumValueComparer`1.CompareByHash(ExtEnumBase,ExtEnumBase)">
            <summary>
            Compares two <see cref="T:ExtEnum`1"/> instances by hashcode (without null checks)
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.FilenameComparer.Compare(System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Helpers.Comparers.ComparerBase`1.Compare(`0,`0)"/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.FilenameComparer.Compare(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.FilenameComparer.Equals(System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Helpers.Comparers.ComparerBase`1.Equals(`0,`0)"/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.FilenameComparer.Equals(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.#ctor">
            <summary>
            Constructs a new <see cref="T:LogUtils.Helpers.Comparers.LogIDComparer"/> instance with default comparison options
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.#ctor(LogUtils.Properties.CompareOptions)">
            <inheritdoc cref="M:LogUtils.Helpers.Comparers.LogIDComparer.#ctor(LogUtils.Properties.CompareOptions,System.StringComparison)"/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.#ctor(LogUtils.Properties.CompareOptions,System.StringComparison)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Helpers.Comparers.LogIDComparer"/> instance
            </summary>
            <param name="compareOptions">Options for influencing comparison and equality results. Set as <see cref="F:LogUtils.Properties.CompareOptions.None"/> </param>
            <param name="stringComparison">Defines the case sensitivity, and culture rules when comparing string values</param>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.Compare(LogUtils.Enums.LogID,LogUtils.Enums.LogID)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.Compare(LogUtils.Properties.LogProperties,LogUtils.Properties.LogProperties)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.CompareNullProperties(LogUtils.Enums.LogID,LogUtils.Enums.LogID)">
            <summary>
            A special comparison case where one, or both <see cref="T:LogUtils.Properties.LogProperties"/> instances is a null value
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.Equals(LogUtils.Enums.LogID,LogUtils.Enums.LogID)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.Equals(LogUtils.Properties.LogProperties,LogUtils.Properties.LogProperties)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.GetHashCode(LogUtils.Properties.LogProperties)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.LogPathComparer.Selector">
            <summary>
            Accepts a <see cref="T:LogUtils.Properties.LogProperties"/> instance, and returns a fully qualified path string
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogPathComparer.Equals(LogUtils.Enums.LogID,LogUtils.Enums.LogID)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogPathComparer.GetHashCode(LogUtils.Enums.LogID)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogPathComparer.Equals(LogUtils.Properties.LogProperties,LogUtils.Properties.LogProperties)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogPathComparer.GetHashCode(LogUtils.Properties.LogProperties)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.PathComparer.CompareFilenameAndPath(System.String,System.String,System.Boolean)">
            <summary>
            Compares two paths (with or without a filename)
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.PathComparer.Compare(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.PathComparer.Equals(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.PathComparer.InternalCompare(System.String,System.String)">
            <summary>
            Assumes path info is being compared, not keywords
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.PathComparer.InternalEquals(System.String,System.String)">
            <summary>
            Assumes path info is being compared, not keywords
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.PathComparer.GetHashCode(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.RemoteLoggerComparer.Compare(LogUtils.ILogHandler,LogUtils.ILogHandler)">
            <summary>
            Returns an integer representation of the better candidate for remote logging
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.ExceptionUtils.ExtractAggregate(System.Exception)">
            <summary>
            Takes an exception as input, and returns all InnerExceptions from it when it is an AggregateException, otherwise returns empty set
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryTree.#ctor(System.String)">
            <summary>
            Construct a tree data structure using a directory path as a root
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryTree.FindPositionInTree(System.String)">
            <summary>
            Finds the nearest common directory within the root directory to a provided path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryTree.DirectoryTreeNode.Detach">
            <summary>
            Detach node from the parent node
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryTree.DirectoryTreeNode.FindChild(System.String)">
            <summary>
            Find an immediate child node with a given value, otherwise null
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryUtils.IsDirectoryName(System.String,System.String,System.Boolean)">
            <summary>
            Compares the equality of two directory names
            </summary>
            <param name="dirName">The first directory name to check</param>
            <param name="dirNameOther">The second directory name to check</param>
            <param name="trimLeadingSeparators">Removes leading separator characters before matching</param>
            <returns>Returns whether both directory names have an equivalent value (case insensitive)</returns>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryUtils.GetLocationInPath(System.String,System.String)">
            <summary>
            Returns the char position of the first directory name matching a provided directory string 
            </summary>
            <param name="path">The path to check</param>
            <param name="dirName">The directory name to search for</param>
            <returns>Returns a char position, or -1 if a match is not found</returns>
            <remarks>The returned index will be representative of the position of the first character in the directory string (separator characters are ignored)</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryUtils.GetLocationInPath(LogUtils.Helpers.FileHandling.PathInfo,System.String)">
            <summary>
            Returns the char position of the first directory name matching a provided directory string 
            </summary>
            <param name="info">The <see cref="T:LogUtils.Helpers.FileHandling.PathInfo"/> instance to check</param>
            <param name="dirName">The directory name to search for</param>
            <returns>Returns a char position, or -1 if a match is not found</returns>
            <remarks>The returned index will be representative of the position of the first character in the directory string (separator characters are ignored)</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryUtils.ParentExists(System.String)">
            <summary>
            Determines if the given path has an existing parent directory
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryUtils.DeletePermanently(System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Helpers.FileHandling.DirectoryUtils.DeletePermanently(System.String,LogUtils.Helpers.FileHandling.DirectoryDeletionScope,System.String)"/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryUtils.DeletePermanently(System.String,LogUtils.Helpers.FileHandling.DirectoryDeletionScope)">
            <inheritdoc cref="M:LogUtils.Helpers.FileHandling.DirectoryUtils.DeletePermanently(System.String,LogUtils.Helpers.FileHandling.DirectoryDeletionScope,System.String)"/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryUtils.DeletePermanently(System.String,LogUtils.Helpers.FileHandling.DirectoryDeletionScope,System.String)">
            <summary>
            Permanently deletes a directory at the specified path
            </summary>
            <param name="path">Location of the directory</param>
            <param name="deleteOption">Condition that must be met for deletion operation to complete successfully</param>
            <param name="customErrorMsg">Message that will be logged in the event of an exception</param>
            <returns>true, if the operation was successful, false if an exception was thrown, or condition for deletion was not met</returns>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.DirectoryDeletionScope">
            <summary>
            Specifies a condition that must be met for delete operation to complete
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.DirectoryDeletionScope.OnlyIfEmpty">
            <summary>
            Directory is only touched if there are no files, or other directories inside
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.DirectoryDeletionScope.AllFilesAndFolders">
            <summary>
            Directory, and all of its contents will be deleted
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.FileExtension">
            <summary>
            A helper class for manipulating file extension information
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.FileExtension.SupportedExtensions">
            <summary>
            Case insensitive file extensions that are supports by LogUtils for use in log filenames, or log backup filenames
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.FileExtension.LongExtensionSupport">
            <summary>
            The current standard applied to long file extension handling
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.IsSupported(System.String)">
            <summary>
            Returns true if string contains a file extension listed as a supported extension for the utility
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Match(System.String,System.String)">
            <summary>
            Case insensitive comparison of the file extensions of two filenames
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Remove(System.String)">
            <inheritdoc cref="M:LogUtils.Helpers.FileHandling.FileExtension.Remove(System.String,System.String@)"/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Remove(System.String,System.String@)">
            <summary>
            Removes the file extension from the provided filename
            </summary>
            <param name="filename">The provided filename</param>
            <param name="fileExt">File extension information (including the period), stores an empty string if filename is null, or does not contain a file extension</param>
            <returns>The filename (or path) without the file extension</returns>
            <remarks>Filenames with long extensions may be unaffected by this operation</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Replace(System.String,System.String)">
            <summary>
            Replace the file extension of the provided filename with a provided file extension
            </summary>
            <param name="target">The provided filename</param>
            <param name="fileExt">The file extension to use</param>
            <returns>The filename (or path) with the provided file extension</returns>
            <remarks>Filenames with long extensions may be unaffected by this operation</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Transfer(System.String,System.String)">
            <summary>
            Takes the file extension from one filename and applies it to another filename
            </summary>
            <param name="transferFrom">The file extension source</param>
            <param name="transferTo">The file extension replace target</param>
            <returns>The filename (or path) with the applied file extension</returns>
            <remarks>Filenames with long extensions may be unaffected by this operation</remarks>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.FileUtils">
            <summary>
            Helper class for interacting with the file system that is safe and supported by LogUtils
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.FileUtils.BRACKET_FORMAT">
            <summary>
            Used to attach information to a filename
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryDelete(System.String,System.String)">
            <summary>
            Attempts to delete a file at the specified path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryDelete(System.String,LogUtils.Diagnostics.FileExceptionHandler)">
            <summary>
            Attempts to delete a file at the specified path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryCopy(System.String,System.String,System.Int32)">
            <summary>
            Attempts to copy a file to a specified path 
            </summary>
            <remarks>Any file at the destination path will be overwritten</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryMove(System.String,System.String,System.Int32)">
            <summary>
            Attempts to move a file to a specified path
            </summary>
            <remarks>Any file at the destination path will be overwritten</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryMove(System.String,System.String,LogUtils.Helpers.FileHandling.FileMoveOption)">
            <summary>
            Attempts to move a file to a specified path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryWrite(System.String,System.String[])">
            <summary>
            Attempts to write one or more strings to file
            </summary>
            <remarks>File is created, its contents are overwritten if it already exists</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryWrite(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <inheritdoc cref="M:LogUtils.Helpers.FileHandling.FileUtils.TryWrite(System.String,System.String[])"/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.AppendLine(System.String,System.String)">
            <inheritdoc cref="M:System.IO.File.AppendAllText(System.String,System.String)"/>
            <remarks>
            - Appends a new line after specified string.<br/>
            - Write lock is applied internally for thread safety, but is not safe to run from multiple processes.
            </remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.AppendText(System.String,System.String)">
            <inheritdoc cref="M:System.IO.File.AppendAllText(System.String,System.String)"/>
            <remarks>
            - Write lock is applied internally for thread safety, but is not safe to run from multiple processes.
            </remarks>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.IPathFinder">
            <summary>
            Type provided to a <see cref="T:LogUtils.Helpers.FileHandling.PathResolver"/> that is responsible for matching to specific directory or file path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.IPathFinder.FindMatch(System.String)">
            <summary>
            Searches for a file, or directory path corresponding with a provided path, directory, or filename
            </summary>
            <param name="path">The path, directory, or filename to search for</param>
            <returns>A file, or directory path corresponding with a provided path, directory, or filename, or null if match criteria was not found</returns>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.IPathFinder.FindRootMatch(System.String)">
            <summary>
            Searches for a file, or directory path corresponding with a provided path, directory, or filename, and returns the base root portion of the corresponding path
            </summary>
            <param name="path">The path, directory, or filename to search for</param>
            <returns>A directory path considered as the base root corresponding with a provided path, directory, or filename, or null if match criteria was not found</returns>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.PathBuilder">
            <summary>
            Type makes it easier to construct new paths 
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathBuilder.IncludeRoot">
            <summary>
            Indicates whether root should be included in path result
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathBuilder.IncludeFilenameInResult">
            <summary>
            Set to <see langword="true"/> when a filename (if present) should be appended before getting path result
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathBuilder.GetResult">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathBuilder.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathBuilder.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathBuilder.Reset">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathBuilder.PathIterator.version">
            <summary>
            Increments when iterator gets reset
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathBuilder.PathIterator.PathNode.GetResult">
            <summary>
            Gets the path result. Directory paths will contain a trailing separator char.
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.IPathBuilder.GetResult">
            <summary>
            Returns the compiled path string containing all selected values
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.IPathBuilderNode.Value">
            <summary>
            Name of a directory in a specific place in the path string
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.IPathBuilderNode.Accept">
            <summary>
            Signals that path segment should be added to path string (only invoke once per node)
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathInfo.Target">
            <summary>
            Contains information about the last segment in the path string (typically refers to a filename, or directory)
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathInfo.TargetPath">
            <summary>
            Contains path information extracted from the path string
            </summary>
            <value>Field will be empty when no path information was provided, or the path consisted of a single filename or directory</value>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.PathInfo.HasFilename">
            <summary>
            Checks that path string contains a filename target
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.PathInfo.HasDirectory">
            <summary>
            Checks that path string contains a directory target
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.PathInfo.HasPath">
            <summary>
            Checks that path string contained a partial, or full path
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.PathInfo.IsFilePath">
            <summary>
            Checks that there is path information pertaining to a filename
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.PathInfo.IsDirectoryPath">
            <summary>
            Checks that there is path information pertaining to a directory
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathInfo.BuildPath">
            <summary>
            Creates an object for the streamlined building of subpath strings
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathInfo.BuildPath(System.Boolean,System.Boolean)">
            <summary>
            Creates an object for the streamlined building of subpath strings
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathInfo.GetFullDirectoryNames">
            <summary>
            Incrementally adds directory names from the target path until the entire target path is returned 
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathInfo.GetDirectories">
            <summary>
            Enumerates directory names parsed from the path string
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathInfo.GetDirectoryEnumerator">
            <summary>
            Begins a new directory enumeration returning the enumerator
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathInfo.GetRoot">
            <summary>
            Extracts the path root from the path string
            </summary>
            <remarks>Returns an empty string if no root information is present</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathInfo.GetRootLength">
            <summary>
            Gets the length of the path root
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathInfo.GetPrefixLength">
            <summary>
            Gets the length of any relative, or root path information at the start of the path string
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathTarget.Type">
            <summary>
            Describes the nature of the path information
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathTarget.Name">
            <summary>
            Identifies a component of a path
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathType.Empty">
            <summary>Path is null, or empty</summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathType.Root">
            <summary>Path contains only root information</summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathType.Filename">
            <summary>Path ends with a filename</summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathType.Directory">
            <summary>Path ends with a directory name</summary>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.PathResolution">
            <summary>
            Performs helper functions similar to AssetManager path resolution
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.ResolveResults.Exists">
            <summary>
            Does the resolved path exist, or does the result represent a non-existant fallback path
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.ResolveResults.ModOwner">
            <summary>
            Contains the associated mod instance if it exists
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.ResolveResults.Original">
            <summary>
            The original path
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.ResolveResults.Result">
            <summary>
            The portion of the path that was resolved
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.ResolveResults.CombinedResult">
            <summary>
            Gets the complete resolved path
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.PathResolver.DefaultPath">
            <summary>
            A fully qualified path that tends to serve as a path to fallback on in necessary situations. Usage of this path depends on
            the <see cref="T:LogUtils.Helpers.FileHandling.PathResolver"/> implementation.
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.PathResolver.Finder">
            <summary>
            The path matching implementation used to determine the path resolution result
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathResolver.Resolve(System.String)">
            <summary>
            Translates a provided path string into a new path string
            </summary>
            <param name="path">A fully qualified, relative, or partial path, or filename</param>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathResolver.TryExpandPath(System.String@)">
            <summary>
            Expands relative, or fully qualified paths into a normalized format
            </summary>
            <returns>A value indicating the fully qualified state of the path</returns>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.PathUtils.PATH_VOLUME_LENGTH">
            <summary>
            The length of a Windows path volume
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.ContainsDirectory(System.String,System.String)">
            <summary>
            Checks that a directory is contained within a path string
            </summary>
            <param name="path">The path to check</param>
            <param name="dirName">The directory name to search for</param>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.ContainsDirectory(System.String,System.String,System.Int32)">
            <summary>
            Checks that a directory is contained within a path string
            </summary>
            <param name="path">The path to check</param>
            <param name="dirName">The directory name to search for</param>
            <param name="dirLevelsToCheck">The number of directory separators to check starting from the right</param>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.ContainsOtherPath(System.String,System.String)">
            <summary>
            Checks the second path is contained by the first path
            </summary>
            <example>
            ContainsOtherPath("path/FolderA/FolderB", "path/FolderA") returns true, because the second path is a substring to the first path.
            </example>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.FindCommonRoot(System.String,System.String)">
            <summary>
            Finds a path string that two provided paths have in common. When a partial path is provided, the path will be resolved to a fully qualified path targeting
            either Rain World, StreamingAssets, or BepInEx directory paths, defaulting to StreamingAssets when no match is found. 
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.FindCommonRoot(LogUtils.Helpers.FileHandling.PathInfo,LogUtils.Helpers.FileHandling.PathInfo)">
            <summary>
            Finds a path string that two provided paths have in common.
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.SubPathExists(System.String,System.Int32)">
            <summary>
            Accepts a path, and checks if there is an existing subdirectory after a given length of the path string
            </summary>
            <param name="checkPath">Path to evaluate</param>
            <param name="startAfter">Checks for an existing directory path after a specified character position in the <paramref name="checkPath"/> string</param>
            <returns><see langword="true"/>, when an subpath exists, <see langword="false"/> otherwise.
            Also returns <see langword="false"/> when <paramref name="startAfter"/> is equal to the length of the checked path.</returns>
            <exception cref="T:System.ArgumentNullException">A path given was null or empty</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The index was negative, or greater than the path length</exception>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.TrimCommonRoot(System.String,System.String)">
            <summary>
            Trims the common difference between the first path and the second path from the first path. If the common difference will consume the path, an empty string
            with be returned.
            </summary>
            <param name="path">First path to evaluate</param>
            <param name="pathOther">Second path to evaluate</param>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.ResolvePath(System.String)">
            <summary>
            Converts a partial, or non-partial path into a fully qualified absolute path
            </summary>
            <remarks>Supports files and directories</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.GetPrefixLength(System.String)">
            <summary>
            Gets the length of any relative, or root path information at the start of the path string
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.Normalize(System.String)">
            <summary>
            Replace all directory separator characters with the default platform-specific directory separator character 
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.Trim(System.String)">
            <summary>
            Removes any trailing directory separator characters
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.PathWithoutFilename(System.String)">
            <summary>
            Returns a path string without the filename (filename must have an extension)
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.PathWithoutFilename(System.String,System.String@)">
            <summary>
            Returns a path string without the filename (filename must have an extension)
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.PrependWithSeparator(System.String)">
            <summary>
            Prepends a single directory separator character to a given path string
            </summary>
            <remarks>This method will remove any existing separator characters at the start of the path</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.SplitPath(System.String)">
            <summary>
            Separates a path into its directory and/or file components
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.SplitPath(System.String,System.Int32)">
            <summary>
            Separates a path into its directory and/or file components
            </summary>
            <param name="path">Path to target</param>
            <param name="startAt">The character position in the string to start beging the split</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Index position given was negative or greater than the length of the path string</exception>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.Unroot(System.String)">
            <summary>
            Removes path root information from a path
            </summary>
            <param name="path">Path to check</param>
            <returns>A <see langword="string"/> not containing path root information</returns>
            <exception cref="T:System.ArgumentException">Path contains illegal characters</exception>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.IsAbsolute(System.String)">
            <summary>
            Checks that <paramref name="path"/> contains drive letter information
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.IsEmpty(System.String)">
            <summary>
            Checks that <paramref name="path"/> contains useable path information
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.IsFilePath(System.String)">
            <summary>
            Checks that the path string contains both directory and file information
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.GetFullPathSafely(System.IO.FileSystemInfo)">
            <summary>
            Attempts to get a fully qualified path from a <see cref="T:System.IO.FileSystemInfo"/> instance
            </summary>
            <returns>A fully qualified path, or <see langword="null"/> if one could not be accessed</returns>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.Rebase(System.String,System.String,System.String)">
            <summary>
            Takes a current path, and transfers a subpath to a new containing path
            </summary>
            <param name="basePath">A path that contains <paramref name="subPath"/></param>
            <param name="newBasePath">A new path that should contain <paramref name="subPath"/></param>
            <param name="subPath">A path that is part of <paramref name="basePath"/></param>
            <returns>A path that is the combination of <paramref name="subPath"/>, and <paramref name="newBasePath"/></returns>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.PathsAreEqual(System.String,System.String)">
            <summary>
            Evaluates whether paths are logically equivalent
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.PathWrapper">
            <summary>
            Simple wrapper for a path string
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.RainWorldPathFinder">
            <summary>
            A class for searching for a best fit path match against one or multiple directories
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.RainWorldPathFinder.FindMatch(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.RainWorldPathFinder.FindRootMatch(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationFlags">
            <summary>
            Possible flags for the SHFileOperation method.
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationFlags.FOF_SILENT">
            <summary>
            Do not show a dialog during the process
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationFlags.FOF_NOCONFIRMATION">
            <summary>
            Do not ask the user to confirm selection
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationFlags.FOF_ALLOWUNDO">
            <summary>
            Delete the file to the recycle bin.  (Required flag to send a file to the bin
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationFlags.FOF_SIMPLEPROGRESS">
            <summary>
            Do not show the names of the files or folders that are being recycled.
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationFlags.FOF_NOERRORUI">
            <summary>
            Surpress errors, if any occur during the process.
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationFlags.FOF_WANTNUKEWARNING">
            <summary>
            Warn if files are too big to fit in the recycle bin and will need
            to be deleted completely.
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationType">
            <summary>
            File Operation Function Type for SHFileOperation
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationType.FO_MOVE">
            <summary>
            Move the objects
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationType.FO_COPY">
            <summary>
            Copy the objects
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationType.FO_DELETE">
            <summary>
            Delete (or recycle) the objects
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.RecycleBin.FileOperationType.FO_RENAME">
            <summary>
            Rename the object(s)
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.RecycleBin.SHFILEOPSTRUCT">
            <summary>
            SHFILEOPSTRUCT for SHFileOperation from COM
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.RecycleBin.Send(System.String,LogUtils.Helpers.FileHandling.RecycleBin.FileOperationFlags)">
            <summary>
            Send directory, or file to recycle bin
            </summary>
            <param name="path">Location of directory or file to recycle</param>
            <param name="flags">FileOperationFlags to add in addition to FOF_ALLOWUNDO</param>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.RecycleBin.Send(System.String)">
            <summary>
            Send directory, or file to recycle bin.  Display dialog, display warning if files are too big to fit (FOF_WANTNUKEWARNING)
            </summary>
            <param name="path">Location of directory or file to recycle</param>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.RecycleBin.MoveToRecycleBin(System.String)">
            <summary>
            Send directory, or file silently to recycle bin.  Suppresses dialog, suppresses errors, deletes permanently if too large.
            </summary>
            <param name="path">Location of directory or file to recycle</param>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.TempPathResolver.MaxFoldersToSelect">
            <summary>
            Used in situations in which use of the entire path is undesired. This value sets a limit to how many directory segments to use in the resolved path. 
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.TempPathResolver.Resolve(System.String)">
            <inheritdoc/>
            <remarks>The output string will not contain a trailing separator character</remarks>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.TempPathFinder.TargetPath">
            <summary>
            The fully qualified path that represents the location of a temporary folder
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FlagUtils.HasConvertedFlags(System.Int32)">
            <summary>
            Check that the value is within what is considered the conversion value range
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FlagUtils.HasMultipleFlags(System.Int32)">
            <summary>
            Check that value satisfies a bitflag value requirement - only evaluates positive integers
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.FlagSearchOption">
            <summary>
            Enum type representing options for matching flag enums, or composite <see cref="T:ExtEnum`1"/> types
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FlagSearchOption.MatchAll">
            <summary>
            All specified flags need to be present to qualify as a match
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FlagSearchOption.MatchAny">
            <summary>
            Any specified flag needs to be present to qualify as a match
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.LogFile">
            <summary>
            Contains helper methods for basic file operations involving log files
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.Copy(LogUtils.Enums.LogID,System.String)">
            <summary>
            Creates a copy of a log file
            </summary>
            <param name="logFile">The <see cref="T:LogUtils.Enums.LogID"/> that accesses the log file path</param>
            <param name="copyPath">The full path to the destination of the log file. Log filename is optional</param>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.Copy(System.String,System.String,System.Boolean)">
            <summary>
            Creates a copy of a log file
            </summary>
            <param name="sourceLogPath">The full path to the log file that needs to be copied (including filename and extension)</param>
            <param name="destLogPath">The full path to the destination of the log file. Log filename is optional</param>
            <param name="overwriteExisting">Specifies the behavior that happens when the file already exists at the destination path</param>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.Move(System.String,System.String,System.Boolean)">
            <summary>
            Moves a log file from one place to another. Allows file renaming
            </summary>
            <param name="sourceLogPath">The full path to the log file that needs to be moved (including filename and extension)</param>
            <param name="destLogPath">The full path to the destination of the log file. Log filename is optional</param>
            <param name="overwriteExisting">Specifies the behavior that happens when the file already exists at the destination path</param>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.MoveFolder(System.String,System.String)">
            <summary>
            Process for moving a directory containing log files - assumes folder path is valid
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.Open(LogUtils.Enums.LogID)">
            <summary>
            Opens a FileStream instance for a log file
            </summary>
            <param name="logFile">The <see cref="T:LogUtils.Enums.LogID"/> that accesses the log file path</param>
            <returns>The opened FileStream, or null if the file could not be opened, or created</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.TryCreate(LogUtils.Enums.LogID)">
            <summary>
            Starts a log file session creating the log file if it doesn't exist
            </summary>
            <param name="logFile">The <see cref="T:LogUtils.Enums.LogID"/> that accesses the log file path</param>
            <returns>The active state of the log session</returns>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.StartNewSession(LogUtils.Enums.LogID)">
            <summary>
            Ends the current logging session, and starts a new one if allowed to do so 
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.FindExistingPath(System.String,System.String)">
            <summary>
            Finds a path containing this filename with an unknown file extension
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.GetPersistentLogFiles">
            <summary>
            Retrieves all file handles for log files with at least one persistent FileStream open (file is currently in use), or temporarily closed
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.LogGroup.MoveFolderExample">
            <summary>
            Example showing how API can be used by a mod to move their group folder, or its contents around
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.LogGroup.OnPermissionDenied(System.String,LogUtils.Enums.FileSystem.FolderPermissions)">
            <summary>
            Throws an exception based on a permission violation
            </summary>
            <param name="folderPath">The path that caused the violation</param>
            <param name="permission">The permission violation</param>
            <exception cref="T:System.InvalidOperationException">Log group does not have a folder path specified</exception>
            <exception cref="T:System.IO.IOException">Folder operation was unsafe, or attempted on a protected path</exception>
            <exception cref="T:LogUtils.PermissionDeniedException">Insufficient permission to complete folder operation</exception>
        </member>
        <member name="F:LogUtils.Helpers.Paths.RainWorld.ROOT_DIRECTORY">
            <summary>
            The name of the Rain World root folder
            </summary>
        </member>
        <member name="T:LogUtils.ExtensionMethods">
            <summary>
            Class for miscellaneous extension methods
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.ContainsType``1(System.Collections.IEnumerable)">
            <summary>
            Extension method that checks if an enumerable contains an item of a specified type
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.IsComposite(UnityEngine.LogType)">
            <summary>
            Evaluates whether the enum is composed of two or more distinct flagged values
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.Deconstruct(BepInEx.Logging.LogLevel)">
            <summary>
            Deconstructs an enum into its flagged values
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.Deconstruct(UnityEngine.LogType)">
            <summary>
            Deconstructs an enum into its flagged values
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.GetFlags(UnityEngine.LogType)">
            <summary>
            Extracts any bitflag compatible values, masking all others
            </summary>
            <param name="logType">The LogType to evaluate</param>
            <returns>A LogType only containing bits within the conversion value range if any are present; otherwise defaults to -1</returns>
        </member>
        <member name="M:LogUtils.ExtensionMethods.Normalize(System.Collections.Generic.HashSet{LogUtils.Enums.LogCategory})">
            <summary>
            Ensures that set is not null, and invalid entries are not present
            </summary>
            <remarks>This method is null safe, and HashSet will be operated on directly</remarks>
        </member>
        <member name="M:LogUtils.ExtensionMethods.ToFormattableLogger(LogUtils.ILogger)">
            <summary>
            Converts instance into an <see cref="T:LogUtils.IFormatLogger"/> object
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.CanHandle(LogUtils.ILogHandler,LogUtils.Requests.LogRequest)">
            <summary>
            Check that an <see cref="T:LogUtils.ILogHandler"/> is able to process the provided <see cref="T:LogUtils.Requests.LogRequest"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.CompatibleWith(System.Collections.Generic.IEnumerable{LogUtils.ILogHandler},LogUtils.Enums.LogID,LogUtils.Requests.RequestType)">
            <summary>
            Finds all logger instances that accepts log requests for a specified <see cref="T:LogUtils.Enums.LogID"/> instance
            </summary>
            <param name="handlers"></param>
            <param name="logFile">The <see cref="T:LogUtils.Enums.LogID"/> to check</param>
            <param name="requestType">The request type expected</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.FindCompatible(System.Collections.Generic.IEnumerable{LogUtils.ILogHandler},LogUtils.Enums.LogID,LogUtils.Requests.RequestType)">
            <summary>
            Find a logger instance that accepts log requests for a specified <see cref="T:LogUtils.Enums.LogID"/> instance
            </summary>
            <param name="handlers"></param>
            <param name="logFile">The <see cref="T:LogUtils.Enums.LogID"/> to check</param>
            <param name="requestType">The request type expected</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.NearestEquivalent(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},LogUtils.Enums.LogID)">
            <summary>
            Finds the best fit candidate in a target collection for a provided log file
            </summary>
            <returns>A <see cref="T:LogUtils.Enums.LogID"/> contained in the target collection with a matching filename, and/or path (best fit)</returns>
        </member>
        <member name="M:LogUtils.ExtensionMethods.WriteFromBuffer(LogUtils.ILogWriter,LogUtils.Enums.LogID,System.Boolean)">
            <summary>
            Attempts to write content from the message buffer to file
            </summary>
            <param name="writer"></param>
            <param name="logFile">The file that contains the message buffer</param>
            <param name="respectBufferState">When true no content will be written to file if <see cref="P:LogUtils.MessageBuffer.IsBuffering"/> property is set to true</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.Find(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.String,System.String)">
            <summary>
            Finds a <see cref="T:LogUtils.Enums.LogID"/> instance with the given metadata in the provided collection
            </summary>
            <remarks>
            - Compares ID, Filename, and CurrentFilename fields
            </remarks>
            <param name="values"></param>
            <param name="filename">The filename to search for</param>
            <param name="relativePathNoFile">The filepath to search for. When set to null, any filename match will be returned with custom root being prioritized</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.Find(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.IO.FileInfo)">
            <summary>
            Finds a <see cref="T:LogUtils.Enums.LogID"/> instance with the given metadata in the provided collection
            </summary>
            <remarks>
            - Compares CurrentFilename, and CurrentFolderPath fields
            </remarks>
            <param name="values"></param>
            <param name="fileInfo">The file to search for a direct match for</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.FindAll(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.String)">
            <summary>
            Finds all <see cref="T:LogUtils.Enums.LogID"/> instances with the given metadata in the provided collection
            </summary>
            <remarks>
            - Compares ID, Filename, and CurrentFilename fields
            </remarks>
            <param name="values"></param>
            <param name="filename">The filename to search for</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.FindAll(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.String,LogUtils.Properties.CompareOptions)">
            <summary>
            Finds all <see cref="T:LogUtils.Enums.LogID"/> instances with the given metadata in the provided collection
            </summary>
            <param name="values"></param>
            <param name="filename">The filename to search for</param>
            <param name="compareOptions">Represents options that determine which fields to check against</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.FindAll(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.Func{LogUtils.Properties.LogProperties,System.Boolean})">
            <summary>
            Finds all <see cref="T:LogUtils.Enums.LogID"/> instances that match a predicate in the provided collection
            </summary>
            <param name="values"></param>
            <param name="predicate">The predicate to match</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.FindByTag(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.String)">
            <summary>
            Finds all <see cref="T:LogUtils.Enums.LogID"/> instances with the given tag in the provided collection
            </summary>
            <param name="values"></param>
            <param name="tag">The tag to search for</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.Find(System.Collections.Generic.IEnumerable{LogUtils.Properties.LogProperties},System.String,System.String)">
            <inheritdoc cref="M:LogUtils.ExtensionMethods.Find(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.String,System.String)"/>
        </member>
        <member name="M:LogUtils.ExtensionMethods.FindAll(System.Collections.Generic.IEnumerable{LogUtils.Properties.LogProperties},System.String,LogUtils.Properties.CompareOptions)">
            <inheritdoc cref="M:LogUtils.ExtensionMethods.FindAll(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.String,LogUtils.Properties.CompareOptions)"/>
        </member>
        <member name="M:LogUtils.ExtensionMethods.FindAll(System.Collections.Generic.IEnumerable{LogUtils.Properties.LogProperties},System.Func{LogUtils.Properties.LogProperties,System.Boolean})">
            <inheritdoc cref="M:LogUtils.ExtensionMethods.FindAll(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.Func{LogUtils.Properties.LogProperties,System.Boolean})"/>
        </member>
        <member name="M:LogUtils.ExtensionMethods.FindByTag(System.Collections.Generic.IEnumerable{LogUtils.Properties.LogProperties},System.String)">
            <inheritdoc cref="M:LogUtils.ExtensionMethods.FindByTag(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},System.String)"/>
        </member>
        <member name="M:LogUtils.ExtensionMethods.GetIDs(System.Collections.Generic.IEnumerable{LogUtils.Properties.LogProperties})">
            <summary>
            Returns all <see cref="T:LogUtils.Enums.LogID"/> instances belonging to entries in this enumeration
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.GetProperties(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID})">
            <summary>
            Returns all <see cref="T:LogUtils.Properties.LogProperties"/> instances belonging to entries in this enumeration
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.GetIDs(System.Collections.Generic.IEnumerable{LogUtils.Properties.LogGroupProperties})">
            <summary>
            Returns all <see cref="T:LogUtils.Enums.LogGroupID"/> instances belonging to entries in this enumeration
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.GetProperties(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogGroupID})">
            <inheritdoc cref="M:LogUtils.ExtensionMethods.GetProperties(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID})"/>
        </member>
        <member name="M:LogUtils.ExtensionMethods.GetMembers(System.Collections.Generic.IEnumerable{LogUtils.Properties.LogGroupProperties})">
            <summary>
            Returns all group members belonging to entries in this enumeration
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.GetMemberProperties(System.Collections.Generic.IEnumerable{LogUtils.Properties.LogGroupProperties})">
            <summary>
            Returns all <see cref="T:LogUtils.Properties.LogProperties"/> instance belonging to group members of entries in this enumeration
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.AppendHeader(System.Text.StringBuilder,System.String)">
            <summary>
            Appends a message in between divider spacers
            </summary>
            <param name="builder">The builder to append to</param>
            <param name="header">The content to use as a header</param>
        </member>
        <member name="M:LogUtils.ExtensionMethods.MatchAny(System.String,System.Collections.Generic.IEqualityComparer{System.String},System.String[])">
            <summary>
            Evaluates whether a string is equal to any of the provided values
            </summary>
            <param name="str">The string to evaluate</param>
            <param name="comparer">An IEqualityComparer to use for the evaluation</param>
            <param name="values">The values to compare the string against</param>
            <returns>Whether a match was found</returns>
        </member>
        <member name="M:LogUtils.ExtensionMethods.Bump(System.Version,LogUtils.VersionCode,System.Int32)">
            <summary>
            Bumps provided version to a specified value
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Increment value is negative</exception>
            <exception cref="T:System.NotImplementedException">VersionCode is invalid</exception>
            <exception cref="T:System.NotSupportedException">The Version object doesn't provide the requested version value</exception>
        </member>
        <member name="M:LogUtils.ExtensionMethods.Add``1(System.Collections.Generic.ICollection{System.WeakReference{``0}},``0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>
        </member>
        <member name="M:LogUtils.ExtensionMethods.AddRange``1(System.Collections.Generic.ICollection{System.WeakReference{``0}},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds each item in the provided collection to the ICollection&lt;T&gt;"/>
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.Remove``1(System.Collections.Generic.ICollection{System.WeakReference{``0}},``0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:LogUtils.ExtensionMethods.RemoveWhere``1(System.Collections.Generic.ICollection{System.WeakReference{``0}},System.Predicate{``0})">
            <summary>
            Remove items from the ICollection&lt;T&gt; based on a predicate
            </summary>
        </member>
        <member name="M:LogUtils.ExtensionMethods.RemoveCollectedEntries``1(System.Collections.Generic.ICollection{System.WeakReference{``0}})">
            <summary>
            Remove entries that have been garbage collected
            </summary>
            <returns>The number of removed entries</returns>
        </member>
        <member name="M:LogUtils.ExtensionMethods.GetLocks``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Selects all acquirable lock objects from the enumeration
            </summary>
        </member>
        <member name="F:LogUtils.FileExtensionInfo.MIN_LONG_EXTENSION_LENGTH">
            <summary>
            The minimum amount of characters (including the period) to satisfy the long file extension property
            </summary>
        </member>
        <member name="F:LogUtils.FileExtensionInfo.IsEmpty">
            <summary>
            Is the file extension null, or empty
            </summary>
        </member>
        <member name="F:LogUtils.FileExtensionInfo.IsNormalized">
            <summary>
            Is the file extension in a comparison neutral format (i.e. all lowercase)
            </summary>
        </member>
        <member name="P:LogUtils.FileExtensionInfo.IsSupported">
            <summary>
            Is the file extension supported by LogUtils
            </summary>
        </member>
        <member name="P:LogUtils.FileExtensionInfo.IsLong">
            <summary>
            Does the file extension exceed a set amount of characters determined by the utility
            </summary>
        </member>
        <member name="F:LogUtils.FileExtensionInfo.Extension">
            <summary>
            The value of the file extension
            </summary>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.#ctor">
            <summary>
            Creates a new <see cref="T:LogUtils.FileExtensionInfo"/> object with no extension information
            </summary>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.Normalize">
            <summary>
            Converts the file extension into a comparison neutral format (i.e. all lowercase)
            </summary>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.Equals(LogUtils.FileExtensionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.FromFilename(System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.FileExtensionInfo"/> object from a filename or path containing a filename 
            </summary>
            <exception cref="T:System.ArgumentException">The provided filename contains invalid path characters</exception>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.FromExtension(System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.FileExtensionInfo"/> object from a filename extension 
            </summary>
        </member>
        <member name="F:LogUtils.LongExtensionSupport.Ignore">
            <summary>
            Long file extensions of any form should be ignored
            </summary>
        </member>
        <member name="F:LogUtils.LongExtensionSupport.SupportedOnly">
            <summary>
            Long file extensions that are not listed as a supported file extension are ignored
            </summary>
        </member>
        <member name="F:LogUtils.LongExtensionSupport.Full">
            <summary>
            Long file extensions of any form are allowed
            </summary>
        </member>
        <member name="M:LogUtils.IFlushable.Flush">
            <summary>
            Flushes out the log buffer
            </summary>
        </member>
        <member name="T:LogUtils.ILockable">
            <summary>
            A type that provides an acquirable lock object
            </summary>
        </member>
        <member name="M:LogUtils.ILockable.GetLock">
            <summary>
            Gets an acquirable lock object
            </summary>
        </member>
        <member name="T:LogUtils.ILogger">
            <summary>
            Represents a type used to perform logging
            </summary>
        </member>
        <member name="T:LogUtils.IFormatLogger">
            <summary>
            Represents a type used to perform logging that supports <see cref="T:LogUtils.Formatting.InterpolatedStringHandler"/>
            </summary>
        </member>
        <member name="T:LogUtils.ILogger`1">
            <summary>
            Represents a type used to perform logging
            </summary>
            <typeparam name="T">The type accepted as the message argument</typeparam>
        </member>
        <member name="M:LogUtils.ILogger`1.Log(`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.LogDebug(`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.LogInfo(`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.LogImportant(`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.LogMessage(`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.LogWarning(`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.LogError(`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.LogFatal(`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.Log(UnityEngine.LogType,`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.Log(BepInEx.Logging.LogLevel,`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger`1.Log(LogUtils.Enums.LogCategory,`0)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="T:LogUtils.ILogHandler">
            <summary>
            Represents a type used to process logging requests
            </summary>
        </member>
        <member name="P:LogUtils.ILogHandler.AllowLogging">
            <summary>
            Does this handler accept logging requests (local or remote)
            </summary>
        </member>
        <member name="P:LogUtils.ILogHandler.AllowRemoteLogging">
            <summary>
            Does this handler accept remote logging requests
            </summary>
        </member>
        <member name="P:LogUtils.ILogHandler.AllowRegistration">
            <summary>
            Does this handler register with the log request system
            </summary>
        </member>
        <member name="M:LogUtils.ILogHandler.CanHandle(LogUtils.Enums.LogID,LogUtils.Requests.RequestType)">
            <summary>
            Does this handler accept <see cref="T:LogUtils.Requests.LogRequest"/> instances of a specific log file and request type
            </summary>
        </member>
        <member name="M:LogUtils.ILogHandler.HandleRequest(LogUtils.Requests.LogRequest)">
            <summary>
            Accepts and processes a <see cref="T:LogUtils.Requests.LogRequest"/> instance
            </summary>
        </member>
        <member name="P:LogUtils.ILogFileHandler.AvailableTargets">
            <summary>
            Log files available for use by the handler
            </summary>
        </member>
        <member name="M:LogUtils.ILogFileHandler.GetAccessibleTargets">
            <summary>
            Retrieves all log files that are accessible by the handler
            </summary>
        </member>
        <member name="T:LogUtils.ILogSourceProvider">
            <summary>
            Provides access to an <see cref="T:BepInEx.Logging.ILogSource"/> object
            </summary>
        </member>
        <member name="P:LogUtils.ILogSourceProvider.LogSource">
            <summary>
            The logging source associated with the provider
            </summary>
        </member>
        <member name="T:LogUtils.ILogWriterProvider">
            <summary>
            Provides access to an <see cref="T:LogUtils.ILogWriter"/> object
            </summary>
        </member>
        <member name="M:LogUtils.ILogWriterProvider.GetWriter">
            <summary>
            Gets the <see cref="T:LogUtils.ILogWriter"/> instance managed by the provider
            </summary>
        </member>
        <member name="M:LogUtils.ILogWriterProvider.GetWriter(LogUtils.Enums.LogID)">
            <summary>
            Gets the <see cref="T:LogUtils.ILogWriter"/> instance associated with the provider for a specific log file
            </summary>
        </member>
        <member name="T:LogUtils.IPC.PipeDemo">
            <summary>
            Demonstrates a working PipeServer and client system
            </summary>
        </member>
        <member name="P:LogUtils.IPC.ProcessMonitor.IsConnected">
            <summary>
            This process has control of the PipeServer that all LogUtils instances attempt to establish a connection with
            </summary>
        </member>
        <member name="M:LogUtils.IPC.ProcessMonitor.WaitOnConnectionStatus">
            <summary>
            Block thread until connection status has been verified
            </summary>
        </member>
        <member name="M:LogUtils.ISelectable.SelectFirst">
            <summary>
            Selects the first element
            </summary>
        </member>
        <member name="M:LogUtils.ISelectable.SelectLast">
            <summary>
            Selects the last element
            </summary>
        </member>
        <member name="M:LogUtils.ISelectable.SelectPrev">
            <summary>
            Selects the previous element
            </summary>
        </member>
        <member name="M:LogUtils.ISelectable.SelectNext">
            <summary>
            Selects the next element
            </summary>
        </member>
        <member name="P:LogUtils.Lifetime.TimeRemaining">
            <summary>
            A managed representation of the time remaining before filestream is disposed in milliseconds
            </summary>
        </member>
        <member name="F:LogUtils.Lifetime.UpdateTask">
            <summary>
            Task assigned to update the life span for this object
            </summary>
        </member>
        <member name="M:LogUtils.Lifetime.FromMilliseconds(System.Int32)">
            <summary>
            Constructs a representation of a Lifetime with a given duration in milliseconds
            </summary>
        </member>
        <member name="M:LogUtils.Lifetime.SetDuration(System.Int32)">
            <summary>
            Set the lifetime remaining to a duration in milliseconds
            </summary>
        </member>
        <member name="F:LogUtils.LogFileMover.ReplaceExistingFile">
            <summary>
            Move attempt will replace a file at the destination path when true; fail to move when false
            </summary>
        </member>
        <member name="M:LogUtils.LogFileMover.#ctor(System.String,System.String)">
            <summary>
            Creates an object capable of moving, or copying log files to a new destination
            </summary>
            <param name="sourceLogPath">The full path to the log file that needs to be moved (including filename + ext)</param>
            <param name="destLogPath">The full path to the destination of the log file. Log filename is optional.</param>
        </member>
        <member name="M:LogUtils.LogFileMover.MoveFile">
            <summary>
            Moves a log file from one place to another. Allows file renaming.
            </summary>
        </member>
        <member name="M:LogUtils.LogFileMover.CopyFile">
            <summary>
            Copies a log file from one place to another. Allows file renaming.
            </summary>
        </member>
        <member name="M:LogUtils.LogFileMover.PrepareToMoveFile(LogUtils.LogValidator)">
            <summary>
            Handles FileSystem operations that are necessary before a move/copy operation can be possible
            </summary>
        </member>
        <member name="F:LogUtils.LogFilename.Extension">
            <summary>
            The file extension belonging to the filename
            </summary>
        </member>
        <member name="F:LogUtils.LogFilename.Value">
            <summary>
            The value of the filename without extension
            </summary>
        </member>
        <member name="F:LogUtils.LogFilename.IsValid">
            <summary>
            Does the value represent a valid filename
            </summary>
        </member>
        <member name="M:LogUtils.LogFilename.#ctor(System.String)">
            <summary>
            Constructs a LogFilename instance
            </summary>
            <param name="value">A filename string without path information</param>
            <exception cref="T:System.ArgumentNullException">Value provided is null</exception>
        </member>
        <member name="M:LogUtils.LogFilename.#ctor(System.String,System.String)">
            <summary>
            Constructs a LogFilename instance
            </summary>
            <param name="value">A filename string without path information, or file extension</param>
            <param name="fileExt">A supported file extension to be used along with the filename. May be null</param>
            <exception cref="T:System.ArgumentNullException">Value provided is null</exception>
        </member>
        <member name="M:LogUtils.LogFilename.CompareTo(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.Equals(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.Equals(LogUtils.LogFilename)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.CompareTo(LogUtils.LogFilename)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.WithExtension">
            <summary>
            The filename as a string (including file extension)
            </summary>
        </member>
        <member name="M:LogUtils.LogFilename.ToString">
            <summary>
            The filename as a string (without file extension)
            </summary>
        </member>
        <member name="F:LogUtils.LogFilter.ActiveKeywords">
            <summary>
            List of filter keywords - A filter entry with a keyword must have that keyword in this list in order for the filter to be effective 
            </summary>
        </member>
        <member name="F:LogUtils.LogFilter.FilteredStrings">
            <summary>
            Dictionary of strings that should be ignored when a log attempt is made
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.IsAllowed(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Checks that log request data is allowed to be processed
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.IsAllowed(LogUtils.Enums.LogID,System.String)">
            <summary>
            Checks that a specified log message is allowed to be processed
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.IsAllowed(LogUtils.Enums.LogCategory)">
            <summary>
            Checks that a specified logging context is allowed to be processed
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.ActivateKeyword(System.String)">
            <summary>
            Designates a keyword as active by adding it to <see cref="F:LogUtils.LogFilter.ActiveKeywords"/> collection
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.DeactivateKeyword(System.String)">
            <summary>
            Removes keyword from <see cref="F:LogUtils.LogFilter.ActiveKeywords"/> collection
            </summary>
        </member>
        <member name="M:LogUtils.LogFilterParser.getHeaderData(System.String)">
            <summary>
            Parses out data necessary to process the filter
            </summary>
        </member>
        <member name="T:LogUtils.LogFolderInfo">
            <summary>
            Collects info about log groups and log files, and provides basic folder operation support
            </summary>
        </member>
        <member name="P:LogUtils.LogFolderInfo.FolderPath">
            <summary>
            A fully qualified path that contains log groups or files
            </summary>
        </member>
        <member name="P:LogUtils.LogFolderInfo.Exists">
            <summary>
            Checks that folder path exists
            </summary>
        </member>
        <member name="P:LogUtils.LogFolderInfo.Groups">
            <summary>
            A snapshot of any groups that target this folder path
            </summary>
        </member>
        <member name="P:LogUtils.LogFolderInfo.AllFiles">
            <summary>
            A snapshot of any files that target this folder path (as part of a group, or otherwise)
            </summary>
        </member>
        <member name="P:LogUtils.LogFolderInfo.FilesNotFromFolderGroups">
            <summary>
            A snapshot of any files not found in a folder group that targets this folder path
            (includes both non-folder group files, and files from folder groups that do not target this folder path)
            </summary>
        </member>
        <member name="M:LogUtils.LogFolderInfo.#ctor(System.String)">
            <summary>
            Creates an object for manipulating folders containing log files
            </summary>
            <param name="folderPath">A path (absolute, relative, or partial) to a folder to access information from</param>
            <exception cref="T:System.Security.SecurityException">Insufficient access to specified path</exception>
            <exception cref="T:System.IO.PathTooLongException">Path exceeded allowed maximum character length</exception>
        </member>
        <member name="M:LogUtils.LogFolderInfo.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Creates an object for manipulating folders containing log files
            </summary>
            <param name="folderInfo">A directory object pointing to a desired folder path</param>
            <exception cref="T:System.ArgumentNullException">Folder info was a null value</exception>
            <exception cref="T:System.Security.SecurityException">Insufficient access to specified path</exception>
            <exception cref="T:System.IO.PathTooLongException">Path exceeded allowed maximum character length</exception>
        </member>
        <member name="M:LogUtils.LogFolderInfo.GetSubFolderInfo(System.String)">
            <summary>
            Gets a slice of folder information that applies to a specified subfolder
            </summary>
            <exception cref="T:System.ArgumentException">Folder path provided is not a part of the current folder path</exception>
            <exception cref="T:System.Security.SecurityException">Insufficient access to specified path</exception>
            <exception cref="T:System.IO.PathTooLongException">Path exceeded allowed maximum character length</exception>
        </member>
        <member name="M:LogUtils.LogFolderInfo.GetSubFolderInfo(System.IO.DirectoryInfo)">
            <summary>
            Gets a slice of folder information that applies to a specified subfolder
            </summary>
            <exception cref="T:System.ArgumentException">Folder path provided is not a part of the current folder path</exception>
            <exception cref="T:System.ArgumentNullException">Folder info is a null value</exception>
            <exception cref="T:System.Security.SecurityException">Insufficient access to specified path</exception>
        </member>
        <member name="M:LogUtils.LogFolderInfo.GetPermissions">
            <summary>
            Returns the folder permissions associated with this folder path
            </summary>
        </member>
        <member name="M:LogUtils.LogFolderInfo.Move(System.String,System.Boolean)">
            <summary>
            Attempts to move this folder and its contents to a new path
            </summary>
            <param name="newPath">A fully qualified folder path, or path keyword</param>
            <param name="checkPermissions">Flag helps enhance safe folder operations. Keep value set to true (Recommended)</param>
        </member>
        <member name="M:LogUtils.LogFolderInfo.mergeCurrentFolder(LogUtils.MergeFolderState)">
            <summary>
            The contents of the current folder path will be merged into a destination path of the same name
            </summary>
        </member>
        <member name="M:LogUtils.LogFolderInfo.rebaseAllPaths(System.String,System.Boolean)">
            <summary>
            Changes the base paths of all groups and files associated with this folder path and any subfolders
            </summary>
        </member>
        <member name="M:LogUtils.LogFolderInfo.demandAllLocks">
            <summary>
            Acquire locks for all groups and files
            </summary>
            <returns>A lock scope containing the source of each lock object</returns>
        </member>
        <member name="M:LogUtils.LoggerExtensions.Log(LogUtils.IFormatLogger,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.LogDebug(LogUtils.IFormatLogger,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.LogInfo(LogUtils.IFormatLogger,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.LogImportant(LogUtils.IFormatLogger,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.LogMessage(LogUtils.IFormatLogger,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.LogWarning(LogUtils.IFormatLogger,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.LogError(LogUtils.IFormatLogger,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.LogFatal(LogUtils.IFormatLogger,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.Log(LogUtils.IFormatLogger,UnityEngine.LogType,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.Log(LogUtils.IFormatLogger,BepInEx.Logging.LogLevel,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="M:LogUtils.LoggerExtensions.Log(LogUtils.IFormatLogger,LogUtils.Enums.LogCategory,System.String,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.String,System.Object[])"/>
        </member>
        <member name="T:LogUtils.LoggerBase">
            <summary>
            Base class for specialized, and general purpose logger implementations
            </summary>
        </member>
        <member name="P:LogUtils.LoggerBase.AllowLogging">
            <summary>
            A flag that allows/disallows handling of log requests (local and remote) through this logger 
            </summary>
        </member>
        <member name="P:LogUtils.LoggerBase.AllowRemoteLogging">
            <summary>
            A flag that allows/disallows handling of remote log requests through this logger
            </summary>
        </member>
        <member name="P:LogUtils.LoggerBase.AllowRegistration">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.LoggerBase.Targets">
            <summary>
            Contains all assigned log targets
            </summary>
        </member>
        <member name="P:LogUtils.LoggerBase.LogTargets">
            <summary>
            Contains <see cref="T:LogUtils.Enums.LogID"/> instances (both local and remote) that will be handled in the case of an untargeted log request
            </summary>
        </member>
        <member name="P:LogUtils.LoggerBase.ConsoleTargets">
            <summary>
            Contains <see cref="T:LogUtils.Enums.ConsoleID"/> instances that will be handled by any log request that can be handled by this logger
            </summary>
        </member>
        <member name="P:LogUtils.LoggerBase.LogSource">
            <summary>
            A log source that will be applied by default to log requests that require such information
            </summary>
        </member>
        <member name="F:LogUtils.LoggerBase.IsThreadSafe">
            <summary>
            A flag that indicates whether this logger should take a conservative approach to thread safety when handling new log requests
            </summary>
        </member>
        <member name="F:LogUtils.LoggerBase.RestorePoint">
            <summary>
            Contains a record of logger field values that can be restored on demand
            </summary>
        </member>
        <member name="F:LogUtils.LoggerBase.Writer">
            <summary>
            Writer implementation (responsible for writing to file, or storing messages in the message buffer)
            </summary>
        </member>
        <member name="M:LogUtils.LoggerBase.#ctor(BepInEx.Logging.ILogSource)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Logger"/> instance
            </summary>
            <param name="logSource">The BepInEx log source (typically a <see cref="T:BepInEx.Logging.ManualLogSource"/>) to assign to this logger</param>
        </member>
        <member name="M:LogUtils.LoggerBase.#ctor(LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.LoggerBase.#ctor(BepInEx.Logging.ILogSource)"/>
            <param name="preset">The <see cref="T:LogUtils.Enums.LogID"/>, or <see cref="T:LogUtils.Enums.ConsoleID"/> to target, or handle by request by this logger</param>
        </member>
        <member name="M:LogUtils.LoggerBase.#ctor(System.Boolean,LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.LoggerBase.#ctor(BepInEx.Logging.ILogSource)"/>
            <param name="allowLogging">Whether logger accepts logs by default, or has to be enabled first</param>
            <param name="preset">The <see cref="T:LogUtils.Enums.LogID"/>, or <see cref="T:LogUtils.Enums.ConsoleID"/> to target, or handle by request by this logger</param>
        </member>
        <member name="M:LogUtils.LoggerBase.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.LoggerBase.#ctor(BepInEx.Logging.ILogSource)"/>
            <param name="mode">Changes the technique used to write messages to file</param>
            <param name="preset">The <see cref="T:LogUtils.Enums.LogID"/>, or <see cref="T:LogUtils.Enums.ConsoleID"/> to target, or handle by request by this logger</param>
        </member>
        <member name="M:LogUtils.LoggerBase.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget)">
            <inheritdoc cref="M:LogUtils.LoggerBase.#ctor(BepInEx.Logging.ILogSource)"/>
            <param name="mode">Changes the technique used to write messages to file</param>
            <param name="allowLogging">Whether logger accepts logs by default, or has to be enabled first</param>
            <param name="preset">The <see cref="T:LogUtils.Enums.LogID"/>, or <see cref="T:LogUtils.Enums.ConsoleID"/> to target, or handle by request by this logger</param>
        </member>
        <member name="M:LogUtils.LoggerBase.#ctor(LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.LoggerBase.#ctor(BepInEx.Logging.ILogSource)"/>
            <param name="presets">Include any <see cref="T:LogUtils.Enums.LogID"/>, or <see cref="T:LogUtils.Enums.ConsoleID"/> instances that this logger targets, or handles on request</param>
        </member>
        <member name="M:LogUtils.LoggerBase.#ctor(System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.LoggerBase.#ctor(BepInEx.Logging.ILogSource)"/>
            <param name="allowLogging">Whether logger accepts logs by default, or has to be enabled first</param>
            <param name="presets">Include any <see cref="T:LogUtils.Enums.LogID"/>, or <see cref="T:LogUtils.Enums.ConsoleID"/> instances that this logger targets, or handles on request</param>
        </member>
        <member name="M:LogUtils.LoggerBase.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.LoggerBase.#ctor(BepInEx.Logging.ILogSource)"/>
            <param name="mode">Changes the technique used to write messages to file</param>
            <param name="presets">Include any <see cref="T:LogUtils.Enums.LogID"/>, or <see cref="T:LogUtils.Enums.ConsoleID"/> instances that this logger targets, or handles on request</param>
        </member>
        <member name="M:LogUtils.LoggerBase.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc cref="M:LogUtils.LoggerBase.#ctor(BepInEx.Logging.ILogSource)"/>
            <param name="mode">Changes the technique used to write messages to file</param>
            <param name="allowLogging">Whether logger accepts logs by default, or has to be enabled first</param>
            <param name="presets">Include any <see cref="T:LogUtils.Enums.LogID"/>, or <see cref="T:LogUtils.Enums.ConsoleID"/> instances that this logger targets, or handles on request</param>
        </member>
        <member name="M:LogUtils.LoggerBase.LogUnresolvedTarget(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.Boolean,LogUtils.Requests.LogRequest.Factory.Callback)">
            <summary>
            An intermediate logging layer that resolves the type of the target to determine if it should be treated as a singular or batched log request
            </summary>
        </member>
        <member name="M:LogUtils.LoggerBase.LogUnresolvedTarget(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.Boolean,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.LoggerBase.LogUnresolvedTarget(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.Boolean,LogUtils.Requests.LogRequest.Factory.Callback)"/>
        </member>
        <member name="M:LogUtils.LoggerBase.LogBase(LogUtils.Requests.LogRequest)">
            <summary>
            Passes a log request to a writer, or request handler
            </summary>
            <remarks>Through normal code paths, this code may receive already submitted requests, but these requests should always be local</remarks>
        </member>
        <member name="M:LogUtils.LoggerBase.CanHandle(LogUtils.Enums.LogID,LogUtils.Requests.RequestType)">
            <summary>
            Determines if the specified <see cref="T:LogUtils.Enums.LogID"/> can be handled by this logger with the specified <see cref="T:LogUtils.Requests.RequestType"/>
            </summary>
        </member>
        <member name="M:LogUtils.LoggerBase.HandleRequest(LogUtils.Requests.LogRequest)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.LoggerBase.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.LoggerBase.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.Logger"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.LoggerBase.Dispose">
            <inheritdoc cref="M:LogUtils.LoggerBase.Dispose(System.Boolean)"/>
        </member>
        <member name="M:LogUtils.LoggerBase.Finalize">
            <summary/>
        </member>
        <member name="T:LogUtils.LoggerBase.LogRestorePoint">
            <summary>
            A snapshot of the logger's state at a certain point in time
            </summary>
        </member>
        <member name="F:LogUtils.LoggerBase.LogRestorePoint.AllowLogging">
            <summary>
            Cached state for AllowLogging field
            </summary>
        </member>
        <member name="F:LogUtils.LoggerBase.LogRestorePoint.AllowRemoteLogging">
            <summary>
            Cached state for AllowRemoteLogging field
            </summary>
        </member>
        <member name="F:LogUtils.LoggerBase.LogRestorePoint.LogTargets">
            <summary>
            Cached state for Targets field
            </summary>
        </member>
        <member name="M:LogUtils.LoggerBase.ProcessBatch(LogUtils.Requests.LogRequest)">
            <summary>
            Processes and logs a previously initiated batch of log reqeusts
            </summary>
        </member>
        <member name="F:LogUtils.LoggerBase.LogProcessor._logHandler">
            <summary>
            The <see cref="T:LogUtils.ILogHandler"/> that is responsible for handling processed log requests
            </summary>
        </member>
        <member name="M:LogUtils.LoggerBase.OnRegister">
            <summary>
            Event is invoked when the logger is registered
            </summary>
        </member>
        <member name="M:LogUtils.LoggerBase.OnUnregister">
            <summary>
            Event is invoked when the logger becomes unregistered
            </summary>
        </member>
        <member name="M:LogUtils.LoggerBase.OnNewRequest(LogUtils.Requests.LogRequest)">
            <summary>
            Event is invoked each time a <see cref="T:LogUtils.Requests.LogRequest"/> is submitted by the current logger
            </summary>
        </member>
        <member name="T:LogUtils.LoggingMode">
            <summary>
            Represents the write implementation mode
            </summary>
        </member>
        <member name="F:LogUtils.LoggingMode.Inherit">
            <summary>
            Specifies that a shared default instance should be used
            </summary>
        </member>
        <member name="F:LogUtils.LoggingMode.Normal">
            <summary>
            Specifies that a standard <see cref="T:LogUtils.LogWriter"/> should be used
            </summary>
        </member>
        <member name="F:LogUtils.LoggingMode.Queue">
            <summary>
            Specifies that a <see cref="T:LogUtils.QueueLogWriter"/> should be used
            </summary>
            <remarks>Emulates Jolly Coop logging</remarks>
        </member>
        <member name="F:LogUtils.LoggingMode.Timed">
            <summary>
            Specifies that a <see cref="T:LogUtils.TimedLogWriter"/> should be used
            </summary>
            <remarks>Emulates BepInEx logging</remarks>
        </member>
        <member name="F:LogUtils.LogGroupBuilder.Name">
            <summary>
            Unique identifying value for the group.
            </summary>
            <value>If this field is not set, the log group may not by registered.</value>
        </member>
        <member name="F:LogUtils.LogGroupBuilder.Path">
            <summary>
            Default folder location (including folder name) of log group files.
            </summary>
            <value>This should be a fully qualified, relative, or partial path where group files will be stored. Leave empty to not associate with any path.</value>
        </member>
        <member name="F:LogUtils.LogGroupBuilder.ModIDHint">
            <summary>
            The plugin ID that identifies a mod specific folder location to associate with the group path. 
            </summary>
            <value>This should be set if you want to log to a location inside the Mods directory. Leave empty for any other location.</value>
        </member>
        <member name="M:LogUtils.LogGroupBuilder.GetID">
            <summary>
            Creates a new unregistered <see cref="T:LogUtils.Enums.LogGroupID"/> instance based on set build parameters.
            </summary>
        </member>
        <member name="M:LogUtils.LogGroupBuilder.GetRegisteredID">
            <summary>
            Creates a new registered <see cref="T:LogUtils.Enums.LogGroupID"/> instance based on set build parameters.
            </summary>
            <exception cref="T:System.InvalidOperationException">"Name field was not set."</exception>
        </member>
        <member name="F:LogUtils.LogGroupMover.TargetPath">
            <summary>
            The path that files will be moved to
            </summary>
        </member>
        <member name="F:LogUtils.LogGroupMover.FailProtocol">
            <summary>
            The behavior that results from being unable to complete a move operation
            </summary>
        </member>
        <member name="F:LogUtils.LogGroupMover.FolderCreationProtocol">
            <summary>
            The behavior that results from encountering a path that doesn't exist
            </summary>
        </member>
        <member name="F:LogUtils.LogGroupMover.AllowEmptyFolders">
            <summary>
            When false the mover will avoid creating an empty folder when given no files to move 
            </summary>
        </member>
        <member name="F:LogUtils.LogGroupMover.PreserveFolderStructure">
            <summary>
            The structure of the folder hierarchy of a folder group will be kept
            </summary>
        </member>
        <member name="F:LogUtils.LogGroupMover.IgnoreOutOfFolderFiles">
            <summary>
            Controls whether or not the move operation applies to group files targetting a path other than the group folder path
            </summary>
        </member>
        <member name="P:LogUtils.LogGroupMover.Conditions">
            <summary>
            Optional conditions to check before a file is moved
            </summary>
        </member>
        <member name="M:LogUtils.LogGroupMover.#ctor">
            <summary>
            Create a object for moving groups of log files
            </summary>
        </member>
        <member name="M:LogUtils.LogGroupMover.#ctor(System.String)">
            <summary>
            Create a object for moving groups of log files
            </summary>
            <param name="targetPath">The path that files will be moved to</param>
        </member>
        <member name="M:LogUtils.LogGroupMover.Move(LogUtils.Enums.LogGroupID)">
            <summary>
            Moves log group files to a target path. If required, group path will be updated to reflect the new path.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> is null</exception>
            <exception cref="T:System.InvalidOperationException">Target path isn't set, or is invalid</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The directory was unable to be created</exception>
            <exception cref="T:System.IO.IOException">General IO exceptions (probably directory not found)</exception>
            <exception cref="T:System.UnauthorizedAccessException">
            File is in use within the group folder that LogUtils cannot move
            - OR - LogUtils does not have permission to perform this operation
            </exception>
        </member>
        <member name="M:LogUtils.LogGroupMover.Move(LogUtils.Enums.LogGroupID,LogUtils.MoveBehavior)">
            <summary>
            Moves log group files to a target path. If specified, group path will be updated to reflect the new path.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> is null</exception>
            <exception cref="T:System.InvalidOperationException">Target path isn't set, or is invalid - OR - group does not support specified move operation</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The directory was unable to be created</exception>
            <exception cref="T:System.IO.IOException">General IO exceptions (probably directory not found)</exception>
            <exception cref="T:System.UnauthorizedAccessException">
            File is in use within the group folder that LogUtils cannot move
            - OR - LogUtils does not have permission to perform this operation
            </exception>
        </member>
        <member name="M:LogUtils.LogGroupMover.MoveFolder(LogUtils.Enums.LogGroupID)">
            <summary>
            Moves a log group folder, and its contents to a target path
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> is null</exception>
            <exception cref="T:System.InvalidOperationException">Target path isn't set, or is invalid - OR - group does not support specified move operation</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The directory was unable to be created</exception>
            <exception cref="T:System.IO.IOException">General IO exceptions (probably directory not found)</exception>
            <exception cref="T:LogUtils.PermissionDeniedException">
            LogUtils does not have permission from the log controller to move this folder
            - OR - It is unsafe to move this folder</exception>
            <exception cref="T:System.UnauthorizedAccessException">
            File is in use within the group folder that LogUtils cannot move
            - OR - LogUtils does not have permission to perform this operation
            </exception>
        </member>
        <member name="M:LogUtils.LogGroupMover.getFilesToMove(LogUtils.Enums.LogGroupID)">
            <summary>
            Applies filter conditions to group members
            </summary>
        </member>
        <member name="F:LogUtils.MoveBehavior.FilesAndGroup">
            <summary>The current path of all files, and the group will be changed</summary>
        </member>
        <member name="F:LogUtils.MoveBehavior.FilesOnly">
            <summary>The current path of all files will be changed; group metadata will be unaffected</summary>
        </member>
        <member name="F:LogUtils.FolderCreationProtocol.FailToCreate">
            <summary>Fail procedure activates when some part of the path doesn't exist</summary>
        </member>
        <member name="F:LogUtils.FolderCreationProtocol.EnsurePathExists">
            <summary>Attempt to create missing directories when some part of the path doesn't exist</summary>
        </member>
        <member name="F:LogUtils.FolderCreationProtocol.CreateFolder">
            <summary>Creates the parent directory only. Fail procedure activates when more than one directory specified in the the path doesn't exist</summary>
        </member>
        <member name="F:LogUtils.Properties.Custom.CustomLogProperty.IsLogRule">
            <summary>
            A field that indicates that this property is convertible into a LogRule instance
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Custom.CustomLogProperty.IsEnabled">
            <summary>
            A field that indicates whether property functionality should be applied
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Custom.CustomLogProperty.Name">
            <summary>
            The string that will be used as header information
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Custom.CustomLogProperty.Value">
            <summary>
            The value of the property converted to a string
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogProperty.CheckEnabled(System.String)">
            <summary>
            An overridable method that allows custom parsing of the value to determine the enable state for this property
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogProperty.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructs a CustomLogProperty
            </summary>
            <param name="name">A string to be used as header information</param>
            <param name="value">The default, or current value assigned to this property converted to a string</param>
            <param name="isRule">Whether or not this data is associated with a custom LogRule object</param>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogProperty.CreateRule">
            <summary>
            An overridable method used in conjunction with IsLogRule for constructing custom LogRule implementations 
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogProperty.Clone">
            <summary>
            An overridable method that creates a copy of the current class instance
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogPropertyCollection.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.BepInExHeaderRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Properties.Formatting.DelegatedLogRule">
            <summary>
            A LogRule that stores its apply logic inside of a delegate
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Formatting.DelegatedLogRule.Callback">
            <summary>
            Invoked when rule is applied
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.DelegatedLogRule.#ctor(System.String,LogUtils.Properties.Formatting.LogRule.ApplyDelegate,System.Boolean)">
            <summary>
            Create a DelegatedLogRule instance
            </summary>
            <param name="name">The name associated with the LogRule. (Make it unique)</param>
            <param name="applyCallback">The delegate to assign as the rule logic</param>
            <param name="enabled">Whether the rule is applied</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.DelegatedLogRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ErrorsOnlyHeaderRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRule.Owner">
            <summary>
            The containing collection instance of a LogRule. Only one collection allowed per instance
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRule.ReadOnly">
            <summary>
            Is persistent state protected from modifications
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRule.Name">
            <summary>
            An unique string that identifies a particular LogRule. LogRules with the same value in this field will be treated as interchangable within the LogRuleCollection class
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRule.Priority">
            <summary>
            The default priority of a LogRule. Rules are applied in order of priority from lowest to highest
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRule.TemporaryOverride">
            <summary>
            The instance stored in this field takes priority over the LogRule that contains it
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.Restore">
            <summary>
            Change recent rule modifications back to pre-change values
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs a new LogRule instance
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.Apply(LogUtils.Formatting.LogMessageFormatter,System.String@,LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Applies format logic to a message
            </summary>
            <param name="formatter">The applicable formatter instance</param>
            <param name="message">The message to format</param>
            <param name="logEventData">Data associated with the message event</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Applies format logic to a message
            </summary>
            <param name="formatter">The applicable formatter instance</param>
            <param name="message">The message to format</param>
            <param name="logEventData">Data associated with the message event</param>
            <returns>The message after rule formatting is applied</returns>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.Clone">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Properties.Formatting.LogRule.ApplyDelegate">
            <summary>
            Delegate signature for applying a <see cref="T:LogUtils.Properties.Formatting.LogRule"/>
            </summary>
            <param name="formatter">The applicable formatter instance</param>
            <param name="message">The message to format</param>
            <param name="logEventData">Data associated with the message event</param>
            <returns>The message after rule formatting is applied</returns>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ShowCategoryRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ShowCategoryRule.GetPriority">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Properties.Formatting.ShowLineCountRule.RuleColor">
            <summary>
            The color that applies to the line count rule
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ShowLineCountRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ShowLineCountRule.GetPriority">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Properties.Formatting.LogRuleAttribute">
            <summary>
            An attribute that contains data necessary for LogUtils to construct a LogRule instance.
            </summary>
            <remarks>Methods that use this attribute must have the same signature as <see cref="T:LogUtils.Properties.Formatting.LogRule.ApplyDelegate"/>.</remarks>
            <param name="RuleName">The name of the LogRule represented by this attribute</param>
            <param name="EnabledByDefault">Indicates that the LogRule should start in an active, or inactive state</param>
            <param name="Priority">The process order priority of the LogRule</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleAttribute.#ctor(System.String,System.Boolean,System.Single)">
            <summary>
            An attribute that contains data necessary for LogUtils to construct a LogRule instance.
            </summary>
            <remarks>Methods that use this attribute must have the same signature as <see cref="T:LogUtils.Properties.Formatting.LogRule.ApplyDelegate"/>.</remarks>
            <param name="RuleName">The name of the LogRule represented by this attribute</param>
            <param name="EnabledByDefault">Indicates that the LogRule should start in an active, or inactive state</param>
            <param name="Priority">The process order priority of the LogRule</param>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRuleAttribute.RuleName">
            <summary>
            The name of the LogRule represented by this attribute
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRuleAttribute.EnabledByDefault">
            <summary>
            Indicates that the LogRule should start in an active, or inactive state
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRuleAttribute.Priority">
            <summary>
            The process order priority of the LogRule
            </summary>
        </member>
        <member name="T:LogUtils.Properties.Formatting.LogRuleAssemblyAttribute">
            <summary>
            Indicate that assembly contains LogRule definitionx. LogUtils will attempt to activate any reflection loaded LogRules from your assembly.
            </summary>
            <param name="TypeHints">The array of types containing all reflection loaded LogRule members. When left empty, all assembly types will be checked.</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleAssemblyAttribute.#ctor(System.Type[])">
            <summary>
            Indicate that assembly contains LogRule definitionx. LogUtils will attempt to activate any reflection loaded LogRules from your assembly.
            </summary>
            <param name="TypeHints">The array of types containing all reflection loaded LogRule members. When left empty, all assembly types will be checked.</param>
        </member>
        <member name="T:LogUtils.Properties.Formatting.ReflectionLoadedAttribute">
            <summary>
            Indicate that LogUtils should try to activate a LogRule with this attribute through reflection
            </summary>
            <remarks>
            <para>Incorrectly configured attributes may throw a <see cref="T:LogUtils.MissingAttributeException"/>.</para>
            <para>Usage:</para>
            <para>Classes that use this attribute must inherit from <see cref="T:LogUtils.Properties.Formatting.LogRule"/>.</para>
            <para>Methods that use this attribute must have the same signature as <see cref="T:LogUtils.Properties.Formatting.LogRule.ApplyDelegate"/>.</para>
            <para>Methods that use this attribute must also have the <see cref="T:LogUtils.Properties.Formatting.LogRuleAttribute"/>.</para>
            <para>Attribute does nothing without applying the <see cref="T:LogUtils.Properties.Formatting.LogRuleAssemblyAttribute"/> to the executing assembly.</para></remarks>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRuleCollection.ChangeRecord">
            <summary>
            Tracks LogRule state changes
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRuleCollection.TrackChanges">
            <summary>
            Enables/disables change state system
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRuleCollection.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRuleCollection.AllowRuleChanges">
            <summary>
            Gets a value indicating whether rules belonging to this collection should protect their persistent state
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.#ctor(LogUtils.Collections.ReadOnlyProvider)">
            <summary>
            Creates a new <see cref="T:LogUtils.Properties.Formatting.LogRuleCollection"/> instance
            </summary>
            <param name="logRuleReadOnlySource">The binding source for determining the ReadOnly state of  a <see cref="T:LogUtils.Properties.Formatting.LogRule"/> that belongs to this collection</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.ChangeAlert">
            <summary>
            Notify that <see cref="T:LogUtils.Properties.Formatting.LogRule"/> changes are ready to be tracked
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.Add(LogUtils.Properties.Formatting.LogRule)">
            <summary>
            Adds a LogRule instance to the collection of Rules
            </summary>
            <remarks>Do not use this for temporary rule changes, use <see cref="M:LogUtils.Properties.Formatting.LogRuleCollection.SetTemporaryRule(LogUtils.Properties.Formatting.LogRule)"/> instead</remarks>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.Replace(LogUtils.Properties.Formatting.LogRule)">
            <summary>
            Replaces an existing rule with another instance
            </summary>
            <remarks>
            <para>Be warned, running this each time your mod runs will overwrite data being saved, and read from file</para>
            <para>Do not replace existing property data values in a way that might break the parse logic</para>
            <para>Consider using temporary rules instead, and handle saving of the property values through your mod</para>
            <para>In either case, you may want to inherit from the existing property in case a user has changed the property through the file</para>
            </remarks>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.Remove(LogUtils.Properties.Formatting.LogRule)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.Reset">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.CreateOrderedEnumerable``1(System.Func{LogUtils.Properties.Formatting.LogRule,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogTimestampRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogTimestampRule.GetTime(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Gets a <see cref="T:System.DateTime"/> instance to use as a timestamp
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogTimestampRule.GetPriority">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Properties.IPropertyHolder">
            <summary>
            Interface for accessing a <see cref="T:LogUtils.Properties.LogProperties"/> instance
            </summary>
        </member>
        <member name="P:LogUtils.Properties.IPropertyHolder.Properties">
            <summary>
            Contains metadata information (filename, path, etc), and other settings that impact logging behavior, and log file management
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogGroupProperties.FolderPermissions">
            <summary>
            A set of flags indicating activities that are safe, and permissible to happen to a defined group folder
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogGroupProperties.IsFolderGroup">
            <summary>
            Indicates whether log group is associated with a folder path
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogGroupProperties.IsMetadataOptional">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.LogGroupProperties.LastKnownFolderPath">
            <summary>
            The last known folder path representing this log group
            </summary>
            <value>Default value is an empty string when not storing a path</value>
        </member>
        <member name="F:LogUtils.Properties.LogGroupProperties.Members">
            <summary>
            All members associated with this log group
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogGroupProperties.CompareMask">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.CreateID">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.CreateIDHash">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.Properties.LogGroupProperties"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.ChangeFilename(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.ChangePath(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.GetFolderMembers">
            <summary>
            Searches for all group members that are physically located inside the group folder, or otherwise target it
            </summary>
            <remarks>It is possible for a group member to target a different folder path. The easiest way to encounter this behavior is when a log file is already defined at the time of assignment.</remarks>
            <exception cref="T:System.InvalidOperationException">The log group is not associated with a folder</exception>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.GetNonConformingMembers">
            <summary>
            Searches for all group members that do not share the same path as the group
            </summary>
            <remarks>It is possible for a group member to target a different folder path. The easiest way to encounter this behavior is when a log file is already defined at the time of assignment.</remarks>
            <exception cref="T:System.InvalidOperationException">The log group is not associated with a folder</exception>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.DemandFolderAccess">
            <summary>
            Blocks until current thread has exclusive access to groups sharing the current group path, or a subdirectory of the group path (also includes current instance)
            </summary>
            <exception cref="T:System.InvalidOperationException">The log group is not associated with a folder</exception>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.VerifyPermissions(LogUtils.Enums.FileSystem.FolderPermissions)">
            <summary>
            Verify that group has been given the provided folder permissions
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogGroupProperties.VerifyPermissionsRecursive(LogUtils.Enums.FileSystem.FolderPermissions,System.Collections.Generic.HashSet{LogUtils.Properties.LogGroupProperties})">
            <summary>
            Verify that group has been given the provided folder permissions
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.LatestVersion">
            <summary>
            The latest properties version recognized by LogUtils
            </summary>
            <remarks>Major&lt;Reserved for LogUtils&gt; Minor (or less)&lt;Reserved for mod usage&gt;</remarks>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.Rules">
            <summary>
            A prioritized order of process actions that must be applied to a message string before logging it to file 
            </summary>
        </member>
        <member name="E:LogUtils.Properties.LogProperties.OnLogSessionStart">
            <summary>
            Events triggers at the start, or the end of a log session
            </summary>
        </member>
        <member name="E:LogUtils.Properties.LogProperties.OnLogSessionFinish">
            <summary>
            Events triggers at the start, or the end of a log session
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.FileLock">
            <summary>
            Ensures thread safety while accessing the log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.Group">
            <summary>
            The id of the log group associated with this instance (null by default)
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.CompareMask">
            <summary>
            Value is used to filter invalid compare options
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.HandleRecord">
            <summary>
            This field contains the last known <see cref="T:LogUtils.Requests.LogRequest"/> handle state for this <see cref="T:LogUtils.Enums.LogID"/>, particularly the rejection status, and the reason for rejection of the request
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.LogSessionActive">
            <summary>
            The log file has been created, its initialization process has run successfully, and it isn't adding to stale log file data 
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.MessagesHandledThisSession">
            <summary>
            The amount of messages logged to file, or stored in <see cref="F:LogUtils.Properties.LogProperties.WriteBuffer"/> since the last logging session was started
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.PersistentStreamHandles">
            <summary>
            A list of persistent FileStreams known to be open for this log file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.ProcessedWithErrors">
            <summary>
            Indicates that this instance was read from file, but one or more fields could not be processed
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.IsNewInstance">
            <summary>
            A flag that indicates that a low amount of frames (less than or equal to 10) have passed since instance was created
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.InitializedFromFile">
            <summary>
            Indicates that properties once originated from the properties file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.StartupRoutineRequired">
            <summary>
            Indicates that the startup routine for this log file needs to be run when true, and has already run when false
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.WriteBuffer">
            <summary>
            Contains messages that have passed all validation checks, and are waiting to be written to file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.AccessPeriod">
            <summary>
            The earliest period that the log file may start a new log session through a log event
            It is recommended to keep at the earliest possible write period, or a period that is close to when the log file is used by a mod's logger
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.AllowLogging">
            <summary>
            Should the logging system handle requests targeting this log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.CanBeAccessed">
            <summary>
            A flag that indicates whether a log session can be, or already is established
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ID">
            <summary>
            The <see cref="T:LogUtils.Enums.LogID"/> representing this instance
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.CreateID">
            <summary>
            Creates a new <see cref="T:LogUtils.Enums.LogID"/> instance using these properties
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.CreateIDHash">
            <summary>
            Creates a value hash for comparison purposes
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.ConsoleIDs">
            <summary>
            Contains targeted <see cref="T:LogUtils.Enums.ConsoleID"/> instances that receive requests when logging to file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.LogSourceName">
            <summary>
            The name of the BepInEx logging source associated with this log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.Version">
            <summary>
            A string representation of the content state. This is useful for preventing user sourced changes from being overwritten by mods
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.OverwriteLog">
            <summary>
            Affects whether new messages targeting this log file will be appended to an existing file instead of the existing file being removed when LogUtils startup routine activates 
            </summary>
            <remarks>As a result of this feature being active, backups for this file may not be available (depending on how the mod that handles backups is configured)</remarks>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShouldOverwrite">
            <summary>
            Indicates whether the current log file should be replaced with a new file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.IsWriteRestricted">
            <summary>
            A flag, when true, indicates it is not safe to attempt to receive write access, or write directly to the log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.LogsFolderAware">
            <summary>
            When the log file properties are first initialized, the log file can have its path changed to target the Logs folder if it exists, disabled by default
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.LogsFolderEligible">
            <summary>
            A property that informs the utility that the log file should not use the Logs folder
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.Tags">
            <summary>
            An array of value identifiers for a specific log
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.DateTimeFormat">
            <summary>
            A format used to display timestamps in the log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.IntroMessage">
            <summary>
            A message that will be logged at the start of a log session
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.OutroMessage">
            <summary>
            A message that will be logged at the end of a log session
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShowIntroTimestamp">
            <summary>
            A flag that indicates whether a timestamp should be logged at the start of a log session
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShowOutroTimestamp">
            <summary>
            A flag that indicates whether a timestamp should be logged at the end of a log session
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShowLogsAware">
            <summary>
            A flag that determines whether <see cref="P:RainWorld.ShowLogs"/> should affect log processing of a specific log target
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShowCategories">
            <summary>
            Exposes <see cref="T:LogUtils.Properties.Formatting.LogRule"/> that attaches category information to a logged message
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShowLineCount">
            <summary>
            Exposes <see cref="T:LogUtils.Properties.Formatting.LogRule"/> that attaches line count information to a logged message
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShowLogTimestamp">
            <summary>
            Exposes <see cref="T:LogUtils.Properties.Formatting.LogRule"/> that attaches timestamp information to a logged message
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.BeginInit">
            <summary>
            Initialization processes that run before metadata is initialized
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.EndInit">
            <summary>
            Initialization processes that run after metadata is initialized
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.GetLock">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.BeginLogSession">
            <summary>
            Initiates the routine that applies at the start of a log session. Handle initial file write operations through this process
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.EndLogSession">
            <summary>
            Initiates the routine that applies at the end of a log session
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.NotifyPathChanged">
            <summary>
            Triggers the <see cref="F:LogUtils.Events.UtilityEvents.OnPathChanged"/> event
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.NotifyPendingMove(System.String)">
            <summary>
            Triggers the <see cref="F:LogUtils.Events.UtilityEvents.OnMovePending"/> event
            </summary>
            <param name="movePath">The pending log path for this instance (include filename with extension if filename has changed)</param>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.NotifyPendingMoveAborted">
            <summary>
            Triggers the <see cref="F:LogUtils.Events.UtilityEvents.OnMoveAborted"/> event
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.IDHash">
            <summary>
            The hashcode representing the log filepath at the time of instantiation
            </summary>
            <remarks>This value is intended to be a unique identifier for this LogProperties instance, and will not change even if the file metadata changes</remarks>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.WriteHash">
            <summary>
            The hashcode produced by the write string cached when properties are read from file
            </summary>
            <remarks>If the value remains at zero, it means that the properties instance hasn't been updated</remarks>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.HasModifiedData">
            <summary>
            Checks whether this instance has writeable data that hasn't yet been written to file
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.Clone(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.Properties.LogProperties"/> instance inheriting all log independent property values for the current instance
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.Equals(LogUtils.Properties.LogProperties)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.GetPackagedRuleEntries">
            <summary>
            Gets rules that are supported by LogUtils by default for all log files
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.HasFilename(System.String,LogUtils.Properties.CompareOptions)">
            <summary>
            Compares a filename against one, or more filename fields controlled by the properties instance
            </summary>
            <remarks>Filename is not case sensitive; file extension is unused</remarks>
            <param name="filename">The filename to compare</param>
            <param name="compareOptions">Represents options for specific filename fields</param>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.HasFilename(System.String,System.String,LogUtils.Properties.CompareOptions)">
            <inheritdoc cref="M:LogUtils.Properties.LogProperties.HasFilename(System.String,LogUtils.Properties.CompareOptions)"/>
            <param name="filename">The filename to compare</param>
            <param name="relativePathNoFile">The filepath to compare. When set to null, the filepath check will be skipped</param>
            <param name="compareOptions">Represents options for specific filename fields</param>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.HasFolderPath(System.String)">
            <summary>
            Compares a folder path to the original, and current folder path fields
            </summary>
            <param name="relativePathNoFile">The path to compare</param>
            <returns>Returns whether a match was found</returns>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.CreateIDHash(System.String,System.String)">
            <summary>
            Creates an identifiable hashcode representation of a filename, and path
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.GetContainingPath(System.String)">
            <summary>
            Resolves a path, or path keyword into a usable log path
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.ApplyGroupPath(LogUtils.Enums.LogGroupID,System.String)">
            <summary>
            Attempts to create a valid path associated with a log group. In certain situation, this may fail, and return the given path instead.
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.ApplyGroupPath(LogUtils.Enums.LogGroupID,System.String,System.Func{LogUtils.Enums.LogGroupID,System.String})">
            <summary>
            Attempts to create a valid path associated with a log group. In certain situation, this may fail, and return the given path instead.
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.IsMetadataOptional">
            <summary>
            Indicates whether optional metadata is supported for this instance
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.FileExists">
            <summary>
            Indicates whether log file currently exists
            </summary>
            <remarks>Only applies to a log file belonging to a current log session, or a log file with the <see cref="P:LogUtils.Properties.LogProperties.OverwriteLog"/> property set to false</remarks>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.Filename">
            <summary>
            The filename that will be used in the typical write path for the log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.AltFilename">
            <summary>
            The filename that will be used if the write path is the Logs directory. May be null
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ReserveFilename">
            <summary>
            The filename that will serve as the replacement filename if the alternate filename needs to be renamed due to a conflict
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.CurrentFilename">
            <summary>
            The active filename of the log file (without file extension)
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.CurrentFilePath">
            <summary>
            The active filepath of the log file (with filename)
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ReplacementFilePath">
            <summary>
            The path to the log file when it has been slated to be replaced or removed
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.CurrentFolderPath">
            <summary>
            The active full path of the directory containing the log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.FolderPath">
            <summary>
            The full path to the directory containing the log file as recorded from the properties file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.OriginalFolderPath">
            <summary>
            The path that was first assigned when the log file was first registered
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.LastKnownFilePath">
            <summary>
            The path of the last known location of the log file
            </summary>
            <value>Default value is an empty string when not storing a path</value>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.GetFallbackFilename">
            <summary>
            Given the last available current filename, and the property assign AltFilename, this method returns the option not represented as the current path
            </summary>
            <returns>The filename that is either the last available current filename, or the alt filename depending on the assignment of CurrentFilename.
            <br>If all options refer to the current path, or the unused path is not defined - this method returns null</br></returns>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.EnsurePathDoesNotConflict">
            <summary>
            Ensures that current file path info is unique for the current log file
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.ChangeFilename(System.String)">
            <summary>
            Sets the current filename to a specified value.
            </summary>
            <inheritdoc cref="M:LogUtils.Properties.LogProperties.ChangePath(System.String)" select="remarks"/>
            <param name="newFilename">The new filename</param>
            <exception cref="T:System.ArgumentException">The filename is null, empty, or contains invalid characters</exception>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.ChangePath(System.String)">
            <summary>
            Sets the current path to a specified value. Filename field will also be changed if provided.
            </summary>
            <remarks>
            <para>
            For log files:<br/>
            - This will not initiate a file move, or rename any file.
            <br/>
            To move, or rename a log file, use <see cref="M:LogUtils.Helpers.LogFile.Move(LogUtils.Enums.LogID,System.String)"/> instead.
            </para>
            <para>
            For log groups:<br/>
            - This method updates the group path.
            </para>
            </remarks>
            <param name="newPath">The new path</param>
            <exception cref="T:System.ArgumentException">The directory is null, empty, or contains invalid characters</exception>
        </member>
        <member name="F:LogUtils.Properties.LogPropertyData.UnrecognizedFields">
            <summary>
            A subset of <see cref="F:LogUtils.Properties.LogPropertyData.Fields"/> containing field data not recognized by the utility. This will include all custom field data
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogPropertyData.FieldOrderMismatch">
            <summary>
            Stores a flag describing whether the field state read from file matches the expected field order
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogPropertyData.optionalFieldsMissingTotal">
            <summary>
            The number of optional fields expected, but not found
            </summary>
            <remarks>This is not guaranteed to be fully accurate when <see cref="F:LogUtils.Properties.LogPropertyData.FieldOrderMismatch"/> flag is true</remarks>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyData.HasContext(LogUtils.Enums.LogIDType)">
            <summary>
            Checks that log property data is associated with a particular logging context
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyData.GetContext">
            <summary>
            Gets the representation context of the log property data
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyData.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyData.GetID">
            <summary>
            Returns the cached id value or fallback equivalent
            </summary>
            <remarks>Value is provided as it would appear in the property file (without prefixes)</remarks>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyData.GetPrefixedID">
            <summary>
            Returns the cached id value or fallback equivalent with applicable prefixes
            </summary>
            <remarks>Value is provided as it would apply to hashing, and registration of the <see cref="T:ExtEnum`1"/> instance</remarks>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyData.ToString">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Properties.LogPropertyDataProcessor.Results">
            <summary>
            The result of processing LogPropertyData
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyDataProcessor.Process">
            <summary>
            Processes LogPropertyData into a LogProperties result
            </summary>
        </member>
        <member name="T:LogUtils.Properties.LogPropertyFile">
            <summary>
            A class for reading, or writing to the LogProperties file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogPropertyFile.FilePath">
            <summary>
            The full path to the file containing properties for all log files
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyFile.PrepareStream">
            <summary>
            Creates a new filestream if current one is closed, and seeks to the start of the filestream
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyFile.RefreshStream">
            <summary>
            Closes and reopens the filestream
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyFile.CreateFileStream">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyReader.countOptionalFieldsBeforeNextMatch(System.String,System.Int32)">
            <summary>
            Finds the position of a data field header beginning at the start index, and searches until the end of the collection, or the search encounters a non-optional data field entry
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.Count">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.Keys">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.Values">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.Add(System.String)">
            <summary>
            Creates and adds a DictionaryEntry from a formatted property string
            </summary>
            <param name="propertyString">A string with key, and a value separated by ':'</param>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.Add(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.Clear">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.ContainsKey(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.ContainsValue(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.CopyTo(System.Array,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.Remove(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyWriter.Write(LogUtils.Properties.LogProperties[])">
            <summary>
            Writes property data to file. If the content already exists, it is overwritten, if it doesn't exist, it is written at the current stream position.
            </summary>
        </member>
        <member name="P:LogUtils.Properties.PropertyDataController.Properties">
            <summary>
            A cache for currently registered log file property entries
            </summary>
        </member>
        <member name="P:LogUtils.Properties.PropertyDataController.GroupProperties">
            <summary>
            A cache for currently registered log group property entries
            </summary>
        </member>
        <member name="P:LogUtils.Properties.PropertyDataController.AllProperties">
            <summary>
            An enumeration containing currently registered log properties for files, and groups
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.CustomLogProperties">
            <summary>
            A cache for custom property implementations for log files, or log groups
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.UnrecognizedFields">
            <summary>
            Contains any field entries that LogUtils couldn't associate with a recognized property field
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.PropertyFile">
            <summary>
            A handle to the log properties file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.PropertyDataController.Tag">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.HasDuplicateFileEntries">
            <summary>
            A flag that indicates that there are duplicate entries in the LogProperties file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.ForceWriteAll">
            <summary>
            A flag that forces all properties instances to write to file on the next save attempt
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.IsEditGracePeriod">
            <summary>
            The game is within a period of time when ReadOnly can be toggled off for the duration of the period before turning back on at the end of the period
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.StartupRoutineActive">
            <summary>
            A flag that indicates the log replacement process has started and has yet to finish
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.PendingCleanup">
            <summary>
            A list of log files that require a cleanup process to run
            </summary>
        </member>
        <member name="M:LogUtils.Properties.PropertyDataController.GetProperties(LogUtils.Enums.LogID,System.String)">
            <inheritdoc cref="M:LogUtils.Properties.PropertyDataController.GetProperties(LogUtils.Enums.LogID,System.String,System.Collections.Generic.IEnumerable{LogUtils.Properties.LogProperties})"/>
        </member>
        <member name="M:LogUtils.Properties.PropertyDataController.GetProperties(LogUtils.Enums.LogID,System.String,System.Collections.Generic.IEnumerable{LogUtils.Properties.LogProperties})">
            <summary>
            Finds the first detected <see cref="T:LogUtils.Properties.LogProperties"/> instance associated with the given <see cref="T:LogUtils.Enums.LogID"/>, and relative filepath
            </summary>
            <param name="searchTarget">The <see cref="T:LogUtils.Enums.LogID"/> to search for</param>
            <param name="searchPath">The filepath to search for. When set to null or an empty string, any <see cref="T:LogUtils.Enums.LogID"/> match will be returned with custom root being prioritized</param>
            <param name="searchEntries">An enumeration of entries to search</param>
        </member>
        <member name="M:LogUtils.Properties.PropertyDataController.SetPropertiesFromFile">
            <summary>
            Reads properties data from file and creates LogProperties instances from the data
            </summary>
        </member>
        <member name="M:LogUtils.Properties.PropertyDataController.GetUpdateEntries">
            <summary>
            Returns an array of property instances that have data that needs to be written to file
            </summary>
        </member>
        <member name="M:LogUtils.Properties.PropertyDataController.GetFields">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Resources.LogUtils_VersionLoader">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="E:LogUtils.LogsFolder.OnMovePending">
            <summary>
            Event signals that the log directory is about to be moved, or renamed
            </summary>
        </member>
        <member name="E:LogUtils.LogsFolder.OnMoveAborted">
            <summary>
            Event signals that the log directory was unable to be moved, or renamed
            </summary>
        </member>
        <member name="E:LogUtils.LogsFolder.OnMoveComplete">
            <summary>
            Event signals that the log directory has successfully been moved, or renamed
            </summary>
        </member>
        <member name="F:LogUtils.LogsFolder.LOGS_FOLDER_NAME">
            <summary>
            The default directory name
            </summary>
        </member>
        <member name="F:LogUtils.LogsFolder.AvailablePaths">
            <summary>
            A list of valid paths that may contain the log directory
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.ContainingPath">
            <summary>
            The path containing, or selected to contain the log directory
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.CurrentPath">
            <summary>
            The currently selected path (including directory name) of the log directory (whether it exists or not)
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.Name">
            <summary>
            The currently selected directory name
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.Exists">
            <summary>
            Checks that log directory exists at its currently set path
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.Contains(System.String)">
            <summary>
            Checks that the current path is located somewhere inside the current log directory path
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.IsCurrentPath(System.String)">
            <summary>
            Checks a path against the current log directory path
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.IsManagingFiles">
            <summary>
            A flag that indicates whether the log directory contains eligible log files
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.Create">
            <summary>
            Attempts to create a new log directory at the currently set path
            </summary>
            <remarks>This method does nothing when the folder already exists</remarks>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
        </member>
        <member name="M:LogUtils.LogsFolder.Initialize">
            <summary>
            Initializes the log directory path
            </summary>
            <remarks>LogUtils does not create this directory by default</remarks>
        </member>
        <member name="M:LogUtils.LogsFolder.FindLogsDirectory">
            <summary>
            Checks existing path history, and available paths, and returns the first existing directory, or null if none of the directory candidates exist
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.GetContainedLogFiles">
            <summary>
            Returns all registered <see cref="T:LogUtils.Enums.LogID"/> instances representing log files within the current log directory or otherwise target it as a write path
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.GetContainedLogGroups">
            <summary>
            Returns all registered <see cref="T:LogUtils.Enums.LogGroupID"/> instances representing log groups targeting the current log directory or otherwise target it as a write path
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.MoveFilesToFolder">
            <summary>
            Moves eligible log files to current log directory
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.RestoreFiles">
            <summary>
            Restores log files that are part of the current log directory to their original folder paths
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.AddToFolder(LogUtils.Properties.LogProperties)">
            <summary>
            Transfers log files, and folders associated with the properties instance to the Logs folder
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.RemoveFromFolder(LogUtils.Properties.LogProperties)">
            <summary>
            Transfers a log file from the Logs folder (when it exists)
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.SetContainingPath(System.String)">
            <summary>
            Targets a directory path to contain a logs folder
            </summary>
            <param name="path">A valid directory path</param>
        </member>
        <member name="M:LogUtils.LogsFolder.SetPath(System.String)">
            <summary>
            Targets a directory path to become the new logs folder
            </summary>
            <remarks>DO NOT set to any directory you don't want moved around</remarks>
            <param name="path">A valid directory path</param>
        </member>
        <member name="M:LogUtils.LogsFolder.PathHistory.Update">
            <summary>
            Appends a new path entry into the path history file
            </summary>
        </member>
        <member name="T:LogUtils.LogsFolder.PathResult">
            <summary>
            The result of a Logs folder path search
            </summary>
        </member>
        <member name="F:LogUtils.LogsFolder.PathResult.Target">
            <summary>
            The result of a the path search
            </summary>
        </member>
        <member name="F:LogUtils.LogsFolder.PathResult.IsResultFromPathHistory">
            <summary>
            The result is associated with an accurate path record
            </summary>
        </member>
        <member name="F:LogUtils.LogsFolder.Processor">
            <summary>
            Manages subfolders and their associated log groups within the log directory
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.AddGroupsToFolder">
            <summary>
            Attempts to move eligible log groups to Logs folder
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.tryAddFolderGroupFirstPass(LogUtils.Properties.LogGroupProperties)">
            <summary>
            This method is only responsible with moving the existing group folder to the Logs folder directory, or a subfolder within it
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.FolderProcessor.GroupTopLevelEntries">
            <summary>
            Groups entries that should be processed together (because they share the same path, or don't have a path)
            </summary>
        </member>
        <member name="M:LogUtils.LogValidator.GetLastException">
            <summary>
            Retrieves the last handled exception. Handled exception will then be cleared.
            </summary>
        </member>
        <member name="F:LogUtils.LogWriter.Writer">
            <summary>
            Writer used by default for most Logger implementations
            </summary>
        </member>
        <member name="F:LogUtils.LogWriter.JollyWriter">
            <summary>
            Writer used by default for JollyCoop
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.IsCachedWriter(LogUtils.ILogWriter)">
            <summary>
            Is this writer recognized by the assembly to be available for any Logger implementation to use
            </summary>
        </member>
        <member name="F:LogUtils.LogWriter.ShouldCloseWriterAfterUse">
            <summary>
            A flag that prevents StreamWriter from being closed
            </summary>
        </member>
        <member name="F:LogUtils.LogWriter.WriteHandler">
            <summary>
            Primary process delegate for handling a write request
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.WriteFrom(LogUtils.Requests.LogRequest)">
            <summary>
            Processes a write request
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.WriteFromBuffer(LogUtils.Enums.LogID,System.TimeSpan,System.Boolean)">
            <inheritdoc cref="M:LogUtils.IBufferHandler.WriteFromBuffer(LogUtils.Enums.LogID,System.TimeSpan,System.Boolean)"/>
            <returns>A handle to the scheduled write task</returns>
        </member>
        <member name="M:LogUtils.LogWriter.WriteToFile(LogUtils.Requests.LogRequest)">
            <summary>
            Attempts to write the most recently requested message to file
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.TryAssignWriter(LogUtils.Enums.LogID,System.IO.StreamWriter@)">
            <summary>
            Assigns a writer instance for handling a specified log file
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.AssignWriter(LogUtils.Enums.LogID,System.IO.StreamWriter@)">
            <summary>
            Assigns a writer instance for handling a specified log file
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.ApplyRules(LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogWriter.SendToBuffer(LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.ILogWriter.ApplyRules(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Applies rule-defined formatting to a message
            </summary>
        </member>
        <member name="M:LogUtils.ILogWriter.WriteFrom(LogUtils.Requests.LogRequest)">
            <summary>
            Provides a procedure for writing a message to file
            </summary>
        </member>
        <member name="M:LogUtils.IBufferHandler.SendToBuffer(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Provides a procedure for adding a message to the WriteBuffer
            </summary>
            <remarks>Bypasses the log request system - intended to be used as a fallback message handling process</remarks>
        </member>
        <member name="M:LogUtils.IBufferHandler.WriteFromBuffer(LogUtils.Enums.LogID,System.TimeSpan,System.Boolean)">
            <summary>
            Attempts to write content from the message buffer to file after a specified amount of time
            </summary>
            <remarks>Default behavior: Wait time will double on each failed attempt to write to file (up to a maximum of 5000 ms)</remarks>
            <param name="logFile">The file that contains the message buffer</param>
            <param name="waitTime">The initial time to wait before writing to file (when set to zero, write attempt will be immediate)</param>
            <param name="respectBufferState">Allow the buffer state to determine when to make a write attempt</param>
        </member>
        <member name="P:LogUtils.MergeFolderState.FolderDepth">
            <summary>
            The number of folder levels the current source directory is from the topmost source directory
            </summary>
        </member>
        <member name="P:LogUtils.MergeFolderState.CurrentSource">
            <summary>
            The current directory being merged into a new directory
            </summary>
        </member>
        <member name="F:LogUtils.MergeFolderState.DestinationPath">
            <summary>
            The specified path to merge into
            </summary>
        </member>
        <member name="F:LogUtils.MergeFolderState.History">
            <summary>
            The complete history of file system, LogID, and LogGroupID changes since the merge began
            </summary>
        </member>
        <member name="F:LogUtils.MergeHistory.Conflicts">
            <summary>
            A queue containing merge conflicts that require input from the user to resolve
            </summary>
        </member>
        <member name="F:LogUtils.MergeHistory.ConflictHandler">
            <summary>
            Handles all merge conflicts
            </summary>
        </member>
        <member name="F:LogUtils.MergeHistory.HasFailed">
            <summary>
            Indicates whether merge process ran to completion
            </summary>
        </member>
        <member name="F:LogUtils.MergeHistory.Exception">
            <summary>
            Inclues the exception resulting in a failed merge execution. Not all exceptions are able to be exposed through this field yet.
            </summary>
        </member>
        <member name="M:LogUtils.MergeHistory.Restore">
            <summary>
            Restores all merged files, and folders back to their original states
            </summary>
        </member>
        <member name="T:LogUtils.MergeRecord">
            <summary>
            Contains state required to reverse a folder merge operation
            </summary>
        </member>
        <member name="F:LogUtils.MergeRecord.IsCanceled">
            <summary>
            Indicates that operation was never completed
            </summary>
        </member>
        <member name="F:LogUtils.MergeRecord.CurrentPath">
            <summary>
            The path of a file, or folder which has been moved
            </summary>
        </member>
        <member name="F:LogUtils.MergeRecord.OriginalPath">
            <summary>
            The original path of a file, or folder which has been moved
            </summary>
        </member>
        <member name="M:LogUtils.MergeRecord.Restore">
            <summary>
            Contains logic for restoring a file, or folder back to its original path
            </summary>
        </member>
        <member name="F:LogUtils.FolderMoveRecord.GroupRecords">
            <summary>
            All groups affected by a folder move
            </summary>
        </member>
        <member name="F:LogUtils.FolderMoveRecord.FileRecords">
            <summary>
            All files affected by a folder move
            </summary>
        </member>
        <member name="F:LogUtils.FolderMoveRecord.RestoreMode">
            <summary>
            Determines how the current folder should be restored to the original path
            </summary>
        </member>
        <member name="F:LogUtils.LogGroupMoveRecord.Target">
            <summary>
            Field identifies a changed log group
            </summary>
        </member>
        <member name="F:LogUtils.FileMoveRecord.Target">
            <summary>
            Optional field that identifies path as a log file
            </summary>
        </member>
        <member name="P:LogUtils.FileMoveRecord.CanHandleFile">
            <summary>
            Defines whether this record applies to an actual file, or only a targeted path
            </summary>
        </member>
        <member name="F:LogUtils.FolderRestoreMode.FilesOnly">
            <summary>
            Restoration will involve moving individual files to their original location
            </summary>
        </member>
        <member name="F:LogUtils.FolderRestoreMode.EntireFolder">
            <summary>
            Restoration will involve moving folder back to its original location
            </summary>
        </member>
        <member name="P:LogUtils.MessageBuffer.IsBuffering">
            <summary>
            When true, the buffer will be added to instead of writing to file on handling a write request
            </summary>
        </member>
        <member name="T:LogUtils.MissingAttributeException">
            <summary>
            Exception is thrown when an required attribute is not found
            </summary>
        </member>
        <member name="T:LogUtils.PatcherLogEventProcessor">
            <summary>
            Static class responsible for processing log event data stored by VersionLoader, and logging it to file
            </summary>
        </member>
        <member name="M:LogUtils.PatcherLogEventProcessor.GetEventListener">
            <summary>
            Accesses and returns the event listener containing unhandled patcher log events
            </summary>
            <returns>Returns a found listener, otherwise null</returns>
        </member>
        <member name="M:LogUtils.PatcherLogEventProcessor.GetEvents(BepInEx.Logging.ILogListener)">
            <summary>
            Extracts log event data from event listener object
            </summary>
        </member>
        <member name="P:LogUtils.PatcherLogEventProcessor.EventLogger.AllowRemoteLogging">
            <inheritdoc/>
            <value>Always returns false</value>
        </member>
        <member name="M:LogUtils.PatcherLogEventProcessor.EventLogger.#ctor">
            <inheritdocs/>
        </member>
        <member name="T:LogUtils.PermissionDeniedException">
            <summary>
            An exception type used when insufficient permission conditions are present
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:LogUtils.PermissionDeniedException.#ctor(System.String)">
            <summary>
            An exception type used when insufficient permission conditions are present
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="P:LogUtils.PersistenceManager.Tag">
            <inheritdoc/>
        </member>
        <member name="E:LogUtils.PersistenceManager.OnHandleDisposed">
            <summary>
            Invoked when a <see cref="T:LogUtils.PersistentFileHandle"/> instance is disposed
            </summary>
        </member>
        <member name="M:LogUtils.PersistenceManager.Update">
            <summary>
            Required method for <see cref="T:UnityEngine.MonoBehaviour"/> update process
            </summary>
        </member>
        <member name="T:LogUtils.PersistentFileHandle">
            <summary>
            A mod friendly class for handling persistent file stream operations 
            </summary>
        </member>
        <member name="P:LogUtils.PersistentFileHandle.IsClosed">
            <summary>
            Gets whether the underlying filestream has been closed
            </summary>
        </member>
        <member name="F:LogUtils.PersistentFileHandle.Lifetime">
            <summary>
            A managed representation of the time remaining before filestream is disposed in milliseconds
            </summary>
        </member>
        <member name="F:LogUtils.PersistentFileHandle.Stream">
            <summary>
            The underlying filestream if it exists, null otherwise. This stream is always active when the file is present 
            </summary>
            <remarks>Please do not close the stream. Interrupt and resume the stream instead</remarks>
        </member>
        <member name="F:LogUtils.PersistentFileHandle.resumeHandle">
            <summary>
            Contains a reference to the handle responsible for reopening the stream after interruption
            </summary>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.InterruptStream">
            <summary>
            Temporarily closes the stream
            </summary>
            <returns>A <see cref="T:LogUtils.StreamResumer"/> object that supports resuming the stream when file operations are finished</returns>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.NotifyOnInterrupt">
            <summary>
            Notifies that a stream interruption operation has started
            </summary>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.NotifyOnResume">
            <summary>
            Notifies that a stream interruption operation has completed
            </summary>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.CreateFileStream">
            <summary>
            Opens a filestream for the targeted file 
            </summary>
            <exception cref="T:System.IO.IOException">Stream has been interrupted</exception>
        </member>
        <member name="F:LogUtils.PersistentFileHandle.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.PersistentFileHandle"/>
            </summary>
            <param name="disposeState">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.BeginDispose(System.Boolean)">
            <summary>
            Dispose logic that must run at the start of a dispose request
            </summary>
            <inheritdoc cref="M:LogUtils.PersistentFileHandle.Dispose(System.Boolean)" select="param"/>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.EndDispose(System.Boolean)">
            <summary>
            Dispose logic that must run at the end of a dispose request
            </summary>
            <inheritdoc cref="M:LogUtils.PersistentFileHandle.Dispose(System.Boolean)" select="param"/>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.Dispose">
            <inheritdoc cref="M:LogUtils.PersistentFileHandle.Dispose(System.Boolean)"/>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.Finalize">
            <summary/>
        </member>
        <member name="T:LogUtils.StreamResumer">
            <summary>
            A class instantiated by LogUtils for the purpose of resuming a stream that has been interrupted
            </summary>
        </member>
        <member name="P:LogUtils.StreamResumer.Handled">
            <summary>
            Indicates the resumed state has been handled
            </summary>
        </member>
        <member name="M:LogUtils.StreamResumer.Resume">
            <summary>
            Refreshes an interrupted stream
            </summary>
        </member>
        <member name="F:LogUtils.PersistentLogFileHandle.FileID">
            <summary>
            Identifies the target of which the persistent <see cref="T:System.IO.FileStream"/> is managed
            </summary>
        </member>
        <member name="M:LogUtils.PersistentLogFileHandle.InterruptStream">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.PersistentLogFileHandle.NotifyOnInterrupt">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.PersistentLogFileHandle.NotifyOnResume">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.PersistentLogFileHandle.CreateFileStream">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.PersistentLogFileHandle.BeginDispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.PersistentLogFileHandle.EndDispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.PersistentLogFileWriter.Flush">
            <summary>
            Flushes the stream buffer to file
            </summary>
            <exception cref="T:System.ObjectDisposedException">The underlying stream element for this instance has been disposed of</exception>
        </member>
        <member name="M:LogUtils.PersistentLogFileWriter.SetStreamFromHandle">
            <summary>
            Injects file handle stream into the base StreamWriter
            </summary>
        </member>
        <member name="F:LogUtils.PersistentLogFileWriter.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.PersistentLogFileWriter.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.PersistentLogFileWriter"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.PersistentLogFileWriter.Finalize">
            <summary/>
        </member>
        <member name="T:LogUtils.Policy.CachedConfigEntry`1">
            <summary>
            ConfigEntry wrapper class
            </summary>
            <remarks>Provides an extra class controlled place to store data values that wont be accessed, or modified upon a config save, or reload operation</remarks>
        </member>
        <member name="P:LogUtils.Policy.CachedConfigEntry`1.Config">
            <summary>
            The config instance that contains this entry
            </summary>
        </member>
        <member name="E:LogUtils.Policy.CachedConfigEntry`1.ValueChanged">
            <summary>
            Event invoked when value has changed from its last set value
            </summary>
        </member>
        <member name="P:LogUtils.Policy.CachedConfigEntry`1.Value">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Policy.CachedConfigEntry`1.BoxedValue">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Policy.CachedConfigEntry`1.IsMarked">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.#ctor(BepInEx.Configuration.ConfigEntry{`0})">
            <summary>
            Creates a new <see cref="T:LogUtils.Policy.CachedConfigEntry`1"/> instance
            </summary>
            <param name="baseEntry">The config entry to wrap around</param>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.Mark">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.Unmark">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.ResetToDefault(LogUtils.Policy.SaveOption)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.SetValue(`0,LogUtils.Policy.SaveOption)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.SetValueFromBase">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.SetValueSilently(`0,LogUtils.Policy.SaveOption)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.UpdateBaseEntry">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Policy.CachedConfigEntry`1.ValueChangedEventHandler">
            <summary>
            Method signature for ValueChanged event
            </summary>
            <param name="entry">The changed entry</param>
            <param name="oldValue">The last value of the entry</param>
        </member>
        <member name="P:LogUtils.Policy.DebugPolicy.DebugMode">
            <summary>
            Enables, or disables LogUtils development build
            </summary>
        </member>
        <member name="P:LogUtils.Policy.DebugPolicy.ShowDebugLog">
            <summary>
            Enables, or disables the LogUtils debug log file
            </summary>
        </member>
        <member name="P:LogUtils.Policy.DebugPolicy.ShowActivityLog">
            <summary>
            Enables, or disables the LogUtils activity log file
            </summary>
        </member>
        <member name="P:LogUtils.Policy.DebugPolicy.AssertsEnabled">
            <summary>
            Affects whether test cases apply, or LogUtils based assert statements have an effect
            </summary>
        </member>
        <member name="M:LogUtils.Policy.DebugPolicy.UpdateAllowConditions">
            <summary>
            Activate, or deactivate development build specific log files based on several criteria
            </summary>
        </member>
        <member name="T:LogUtils.Policy.IConfigEntry">
            <summary>
            Exposes members for setting, or updating a config value
            </summary>
        </member>
        <member name="P:LogUtils.Policy.IConfigEntry.IsMarked">
            <summary>
            Indicates that an entry has been marked for special handling (such as during save operations)
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.Mark">
            <summary>
            Marks an entry for special handling (such as during save operations)
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.Unmark">
            <summary>
            Unmarks an entry for special handling (such as during save operations)
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.ResetToDefault(LogUtils.Policy.SaveOption)">
            <summary>
            Assigns the default value to the value cache
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.SetValueFromBase">
            <summary>
            Assigns value stored in the base config entry in the value cache
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.UpdateBaseEntry">
            <summary>
            Updates config entry with cached data
            </summary>
        </member>
        <member name="T:LogUtils.Policy.IConfigEntry`1">
            <inheritdoc cref="T:LogUtils.Policy.IConfigEntry"/>
        </member>
        <member name="P:LogUtils.Policy.IConfigEntry`1.Value">
            <summary>
            The current config value
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry`1.SetValue(`0,LogUtils.Policy.SaveOption)">
            <summary>
            Assigns a new value to value cache
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry`1.SetValueSilently(`0,LogUtils.Policy.SaveOption)">
            <summary>
            Assigns a new value to value cache without throwing a value changed event
            </summary>
        </member>
        <member name="P:LogUtils.Policy.LogRequestPolicy.ShowRejectionReasons">
            <summary>
            A flag that affects whether a detected <see cref="T:LogUtils.Requests.RejectionReason"/> is logged to file when they occur
            </summary>
        </member>
        <member name="T:LogUtils.Policy.PatcherPolicy">
            <summary>
            Global LogUtils related setting flags pertaining to Patcher behavior
            </summary>
        </member>
        <member name="P:LogUtils.Policy.PatcherPolicy.HasAskedForPermission">
            <summary>
            Indicates whether the user should be prompted for permission to deploy the patcher
            </summary>
        </member>
        <member name="P:LogUtils.Policy.PatcherPolicy.ShouldDeploy">
            <summary>
            Indicates that the patcher is able to be deployed
            </summary>
        </member>
        <member name="P:LogUtils.Policy.PatcherPolicy.ShowPatcherLog">
            <summary>
            Indicates that extra information should be provided in a separate log file
            </summary>
        </member>
        <member name="P:LogUtils.Policy.TestCasePolicy.PreferExpectationsAsFailures">
            <summary>
            A flag that affects whether failed expectations qualify as a failure result
            </summary>
        </member>
        <member name="P:LogUtils.Policy.TestCasePolicy.FailuresAreAlwaysReported">
            <summary>
            A flag that affects whether all failure results are reported, or only the unexpected ones
            </summary>
        </member>
        <member name="P:LogUtils.Policy.TestCasePolicy.ReportVerbosity">
            <summary>
            This field affects the level of detail revealed in the test case report
            </summary>
        </member>
        <member name="T:LogUtils.Policy.UtilityConfig">
            <summary>
            A container for utility settings, and user preferences
            </summary>
        </member>
        <member name="F:LogUtils.Policy.UtilityConfig.CONFIG_PATH">
            <summary>
            Path to the LogUtils core config file
            </summary>
        </member>
        <member name="P:LogUtils.Policy.UtilityConfig.Item(BepInEx.Configuration.ConfigDefinition)">
            <summary>
            Retrieves a cached config entry
            </summary>
        </member>
        <member name="P:LogUtils.Policy.UtilityConfig.Item(System.String,System.String)">
            <inheritdoc cref="P:LogUtils.Policy.UtilityConfig.Item(BepInEx.Configuration.ConfigDefinition)"/>
        </member>
        <member name="M:LogUtils.Policy.UtilityConfig.ReloadCache">
            <summary>
            Assigns values stored in the config to their associated policy
            </summary>
        </member>
        <member name="M:LogUtils.Policy.UtilityConfig.ResetToDefaults(LogUtils.Policy.SaveOption)">
            <summary>
            Assigns the default value for all config entries
            </summary>
        </member>
        <member name="M:LogUtils.Policy.UtilityConfig.TrySave">
            <summary>
            Process safe method of saving entry values to the config file
            </summary>
        </member>
        <member name="M:LogUtils.Policy.UtilityConfig.TryReload">
            <summary>
            Process safe method of reading entry values from the config file
            </summary>
            <remarks>This method does not affect the value cache. To assign values to cache, also invoke <see cref="M:LogUtils.Policy.UtilityConfig.ReloadCache"/>.</remarks>
        </member>
        <member name="T:LogUtils.Policy.SaveOption">
            <summary>
            Represents options for saving config entries to file
            </summary>
        </member>
        <member name="T:LogUtils.QueueLogWriter">
            <summary>
            This writer class imitates logging functionality exhibited by JollyCoop logger mainly in that all log messages are
            placed in a queue and logged at the end of a Rain World frame
            </summary>
        </member>
        <member name="M:LogUtils.QueueLogWriter.ApplyRules(LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.QueueLogWriter.WriteToBuffer(LogUtils.Requests.LogRequest)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.QueueLogWriter.EnqueueMessage(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Adds a message to the logging queue
            </summary>
        </member>
        <member name="M:LogUtils.QueueLogWriter.WriteToFile(LogUtils.Requests.LogRequest)">
            <summary>
            Operation is not supported by this write implementation
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:LogUtils.QueueLogWriter.PrepareLogFile(LogUtils.Enums.LogID)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.QueueLogWriter.Flush">
            <summary>
            Writes all messages in the queue to file
            </summary>
        </member>
        <member name="M:LogUtils.QueueLogWriter.OnWriteException(LogUtils.Enums.LogID,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.RainWorldDirectory.PathFinder">
            <summary>
            Converts partial, and non-partial Rain World file or directory paths into a normalized equivalent form within the Rain World directory  
            </summary>
            <exception cref="T:System.ArgumentNullException">Property was set to a null value</exception>
        </member>
        <member name="F:LogUtils.RainWorldDirectory.FolderTree">
            <summary>
            Hardcoded tree of directory names associated with a vanilla Rain world installation 
            </summary>
        </member>
        <member name="F:LogUtils.RainWorldDirectory.customRoot">
            <summary>
            Shortcut accessor for StreamingAssets path
            </summary>
        </member>
        <member name="M:LogUtils.RainWorldDirectory.LocateRoot(System.String)">
            <summary>
            Locates the fully qualified root path associated with a provided path
            </summary>
            <param name="path">The path to check</param>
            <returns>Value returned will either be the Rain World root path, StreamingAssets path, BepInEx root path, or null if path does not belong to a Rain World root path</returns>
        </member>
        <member name="M:LogUtils.RainWorldDirectory.GetDirectoryCategory(System.String)">
            <summary>
            Evaluates a directory path, determining whether it belongs to the game, mod sourced, or unknown, and returns the result
            </summary>
        </member>
        <member name="F:LogUtils.PathCategory.NotRooted">
            <summary>
            Path is not part of Rain World folder
            </summary>
        </member>
        <member name="F:LogUtils.PathCategory.Game">
            <summary>
            Path points to a game-installed directory, or is part of mergedmods directory
            </summary>
        </member>
        <member name="F:LogUtils.PathCategory.ModRequiredFolder">
            <summary>
            Path points to a top-level directory inside the mods directory, or similar directory for mods, or a required mod subdirectory
            </summary>
        </member>
        <member name="F:LogUtils.PathCategory.ModSourced">
            <summary>
            Path is not a game-installed directory, not associated with a mod's directory structure, and is defined within the Rain World directory or a mod-specific directory
            </summary>
        </member>
        <member name="T:LogUtils.RainWorldInfo">
            <summary>
            A static class for storing Rain World associated data
            </summary>
        </member>
        <member name="F:LogUtils.RainWorldInfo.SHOW_LOGS_ACTIVE_PERIOD">
            <summary>
            A period during which it is safe to evaluate RainWorld.ShowLogs because it is guaranteed to be initialized at this time
            </summary>
        </member>
        <member name="F:LogUtils.RainWorldInfo.STARTUP_CUTOFF_PERIOD">
            <summary>
            The period during which it becomes too late to initiate the startup routine (such as for replacing log files)
            </summary>
        </member>
        <member name="F:LogUtils.RainWorldInfo.LastReportedException">
            <summary>
            Contains last reported errors logged to a specific log file
            </summary>
        </member>
        <member name="P:LogUtils.RainWorldInfo.MergeProcessComplete">
            <summary>
            A flag indicating merge folder is ready to access
            TODO: Refine this check to be more accurate
            </summary>
        </member>
        <member name="F:LogUtils.RainWorldInfo.LatestSetupPeriodReached">
            <summary>
            The latest point in the initialization process that Rain World has reached since the application began
            </summary>
            <remarks>Do not modify directly, use <see cref="M:LogUtils.RainWorldInfo.NotifyOnPeriodReached(LogUtils.SetupPeriod)"/> instead</remarks>
        </member>
        <member name="T:LogUtils.SetupPeriod">
            <summary>
            A stage in the Rain World initialization process
            </summary>
        </member>
        <member name="F:LogUtils.SetupPeriod.Pregame">
            <summary>The period of time before Rain World initializes</summary>
        </member>
        <member name="F:LogUtils.SetupPeriod.RWAwake">
            <summary>The period of time when RainWorld.Awake is called</summary>
        </member>
        <member name="F:LogUtils.SetupPeriod.PreMods">
            <summary>The period of time when PreModsInit is called</summary>
        </member>
        <member name="F:LogUtils.SetupPeriod.ModsInit">
            <summary>The period of time when ModsInit is called</summary>
        </member>
        <member name="F:LogUtils.SetupPeriod.PostMods">
            <summary>The period of time when PostModsInit is called</summary>
        </member>
        <member name="F:LogUtils.SetupPeriod.LatePostMods">
            <summary>A special case period beyond PostModsInit that is invoked only when no other periods states are applicable when LogUtils initializes</summary>
        </member>
        <member name="M:LogUtils.Requests.LinkedLogRequestCollection.SortRequests">
            <summary>
            Returns an <see cref="T:System.Linq.IOrderedEnumerable`1"/> that sorts <see cref="T:LogUtils.Requests.LogRequest"/> instances by <see cref="T:LogUtils.Enums.LogID"/> (by value and path)
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LinkedLogRequestCollection.GroupRequests">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> that sorts <see cref="T:LogUtils.Requests.LogRequest"/> instances by <see cref="T:LogUtils.Enums.LogID"/> (by value and path) into partitioned groups for each different kind
            </summary>
        </member>
        <member name="T:LogUtils.Requests.LogRequest">
            <summary>
            A class for storing log details until a logger is available to process the request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.UNABLE_TO_RETRY_RANGE">
            <summary>
            Rejection codes up to and including this value are not recoverable. A <see cref="T:LogUtils.Requests.LogRequest"/> instance that is rejected in this range will not be handled again
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.Host">
            <summary>
            The log handler that has taken responsibility for handling the write process for this request
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequest.IsCompleteOrInvalid">
            <summary>
            Request has been handled, and no more attempts to process the request should be made
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.LogCallback">
            <summary>
            This field is primarily used by <see cref="T:LogUtils.Requests.LogRequestHandler"/> to communicate with unregistered loggers 
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.Sender">
            <summary>
            The log handler that was responsible for submitting the request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.Submitted">
            <summary>
            Whether this request has once been submitted through the log request system
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequest.IsFileRequest">
            <summary>
            A flag indicating whether the request targets a log file
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequest.IsTargetingConsole">
            <summary>
            Indicates that a <see cref="T:LogUtils.Enums.ConsoleID"/> instance is the current target for this request (of which there may be multiple targets)
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.#ctor(LogUtils.Requests.RequestType,LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Requests.LogRequest"/> instance
            </summary>
            <param name="type">The identifying request category (affects how request is handled)</param>
            <param name="data">Data used to construct a log message</param>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.ResetTarget">
            <summary>
            Reset the console target status back to its value set on construction
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.NotifyComplete(LogUtils.Enums.ConsoleID)">
            <summary>
            Notify that the specified <see cref="T:LogUtils.Enums.ConsoleID"/> instance no longer needs to be processed
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.NotifyComplete(System.Collections.Generic.IEnumerable{LogUtils.Enums.ConsoleID})">
            <summary>
            Notify that these <see cref="T:LogUtils.Enums.ConsoleID"/> instances no longer needs to be processed
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.NotifyOnChange">
            <summary>
            Raises an event when the <see cref="T:LogUtils.Requests.LogRequest"/> status, or the rejection reason changes. Currently does not raise when <see cref="M:LogUtils.Requests.LogRequest.ResetStatus"/> is invoked
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Requests.LogRequest.Factory">
            <summary>
            A class for constructor helper methods, and method signatures for creating <see cref="T:LogUtils.Requests.LogRequest"/> objects
            </summary>
        </member>
        <member name="T:LogUtils.Requests.LogRequest.Factory.Callback">
            <summary>
            A delegate signature for creating a <see cref="T:LogUtils.Requests.LogRequest"/> instance
            </summary>
            <param name="requestType">The type of <see cref="T:LogUtils.Requests.LogRequest"/> to make</param>
            <param name="target">The log destination identifier</param>
            <param name="category">The logging context to use</param>
            <param name="messageObj">The object representation of the logged message</param>
            <param name="shouldFilter">Whether a filter should be applied when message is handled</param>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.Factory.Create(LogUtils.Requests.RequestType,LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.Boolean)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Requests.LogRequest"/> instance
            </summary>
            <inheritdoc cref="T:LogUtils.Requests.LogRequest.Factory.Callback" section="param"/>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.Factory.CreateDataCallback(System.EventArgs)">
            <summary>
            Creates a callback that will create a new <see cref="T:LogUtils.Requests.LogRequest"/> instance with the provided event data when invoked
            </summary>
        </member>
        <member name="T:LogUtils.Requests.RejectionReason">
            <summary>
            Describes the reason why a <see cref="T:LogUtils.Requests.LogRequest"/> instance could not be handled
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.None">
            <summary>
            Default state
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.AccessDenied">
            <summary>
            All loggers available to handle the log request are private
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.LogDisabled">
            <summary>
            The <see cref="T:LogUtils.Enums.LogID"/> is not enabled, <see cref="T:LogUtils.Logger"/> is not accepting log requests, or <see cref="T:LogUtils.Enums.LogID"/> is <see cref="P:RainWorld.ShowLogs"/> aware and the value is false
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.FailedToWrite">
            <summary>
            Attempt to log failed due to an error
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.ExceptionAlreadyReported">
            <summary>
            Attempt to log the same Exception two, or more times to the same log file
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.FilterMatch">
            <summary>
            Attempt to log a string that is stored in <see cref="F:LogUtils.LogFilter.FilteredStrings"/>
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.PathMismatch">
            <summary>
            The path information for the <see cref="T:LogUtils.Enums.LogID"/> accepted by a <see cref="T:LogUtils.Logger"/> does not match the path information of the <see cref="T:LogUtils.Enums.LogID"/> in the request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.NotAllowedToHandle">
            <summary>
            A log request was sent to a logger that cannot handle the request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.WaitingOnOtherRequests">
            <summary>
            Attempt to handle log request was prevented, because an earlier request could not be handled
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.LogUnavailable">
            <summary>
            No logger is available that accepts the <see cref="T:LogUtils.Enums.LogID"/>, or the <see cref="T:LogUtils.Logger"/> accepts the <see cref="T:LogUtils.Enums.LogID"/>, but enforces a build period on the log file that is not yet satisfied
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.ShowLogsNotInitialized">
            <summary>
            Attempt to log to a <see cref="P:RainWorld.ShowLogs"/> aware log before the property is initialized
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.RequestProcessLock">
            <summary>
            This lock object marshals control over submission of <see cref="T:LogUtils.Requests.LogRequest"/> instances, and the processing of requests stored in <see cref="F:LogUtils.Requests.LogRequestHandler.UnhandledRequests"/>. When there is a need to
            process a request directly from that collection, it is recommended to use this lock object to achieve thread safety
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequestHandler.Tag">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Requests.LogRequestHandler.AvailableLoggers">
            <summary>
            A list of loggers available to handle local or remote log requests
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.UnhandledRequests">
            <summary>
            Contains <see cref="T:LogUtils.Requests.LogRequest"/> objects that are submitted and waiting to be handled
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.HandleOnNextAvailableFrame">
            <summary>
            Contains <see cref="T:LogUtils.Requests.LogRequest"/> objects that need to be submitted on the next available frame
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequestHandler.CurrentRequest">
            <summary>
            The request currently being handled. The property is cleared when request has been properly handled, or the request has been swapped out to another request
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequestHandler.PendingRequest">
            <summary>
            The latest request that has yet to be handled
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.CheckForHandledRequests">
            <summary>
            A flag that can be used to do a full check to discard handled, or no longer valid requests
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.RecursionCheckCounter">
            <summary>
            A counter used to prevent recursive <see cref="T:LogUtils.Requests.LogRequest"/> submissions
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.BeginCriticalSection">
            <summary>
            Acquires the lock necessary for entering a critical state pertaining to <see cref="T:LogUtils.Requests.LogRequest"/> handling
            </summary>
            <returns>A disposable scope object purposed for leaving a critical state</returns>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.EndCriticalSection">
            <summary>
            Releases the lock used to enter a critical state
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.ConsumeRequestCounter(LogUtils.Enums.LogID)">
            <summary>
            Consumes a request counter for the specified log file if a counter is present
            </summary>
            <returns>A counter value was detected and consumed</returns>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.GetRequestFromAPI(LogUtils.Enums.LogID,System.Boolean)">
            <summary>
            Invoked by external API callbacks to get a request sent through the LogUtils API, and processed by the external API
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.Submit(LogUtils.Requests.LogRequest,System.Boolean)">
            <summary>
            Submit a request - Treated as an active pending log request unless the request itself did not qualify for submission. A request must meet the following conditions: 
            <br>I. No rejection reasons were found during initial processing of the request</br>
            <br>II. Under the situation that there is a reason to reject, that reason is not severe enough to prevent future attempts to process the request</br>
            <br>Submitted request may be retrieved through <see cref="P:LogUtils.Requests.LogRequestHandler.CurrentRequest"/> under the above conditions, or from the return value</br>
            </summary>
            <param name="request">The request to be processed</param>
            <param name="handleSubmission">Whether a log attempt should be made on the request</param>
            <returns>This method returns the same request given to it under any condition. The return value is more reliable than checking <see cref="P:LogUtils.Requests.LogRequestHandler.CurrentRequest"/>, which may be null</returns>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.Register(LogUtils.ILogHandler)">
            <summary>
            Enables log handler communication with the log request system
            </summary>
            <remarks>Registration is required to use the log request system for both local and remote requests</remarks>
            <exception cref="T:System.InvalidOperationException">The logger is not allowed to be registered</exception>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.Unregister(LogUtils.ILogHandler)">
            <summary>
            Disables log handler communication with the log request system
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.ProcessRequests(LogUtils.Enums.CompositeLogTarget)">
            <summary>
            Attempts to handle all unhandled log requests associated with the provided <see cref="T:LogUtils.Enums.LogID"/> instances in the order they were submitted
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.ProcessRequests(LogUtils.Enums.LogID)">
            <summary>
            Attempts to handle all unhandled log requests associated with a single <see cref="T:LogUtils.Enums.LogID"/> instance in the order they were submitted
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.ProcessRequests">
            <summary>
            Attempts to handle unhandled requests 
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.RequestMayBeCompleteOrInvalid(LogUtils.Requests.LogRequest)">
            <summary>
            Clean up process for requests that need to be removed from the request handling system
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.DiscardStatus.Keep">
            <summary>
            Don't discard
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.DiscardStatus.Soft">
            <summary>
            Remove from CurrentRequest
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.DiscardStatus.Hard">
            <summary>
            Remove from UnhandledRequests and CurrentRequest
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.DiscardHandledRequests">
            <summary>
            Checks all requests stored in <see cref="F:LogUtils.Requests.LogRequestHandler.UnhandledRequests"/>, removing any that have been completed, or are no longer valid
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.SanitizeCurrentRequest">
            <summary>
            Ensures that <see cref="P:LogUtils.Requests.LogRequestHandler.CurrentRequest"/> represents a pending unrejected request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.LoggerSelection.AccessTarget">
            <summary>
            The access specification used to assign the handler
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequestRecord.LastUpdated">
            <summary>
            The last time the reason was updated (defaults to 0 prior to the first update)
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestRecord.Reset">
            <summary>
            Resets the state back to original values
            </summary>
        </member>
        <member name="T:LogUtils.Requests.Validation.GameRequestValidator">
            <summary>
            Used to validate game-specific log requests
            </summary>
        </member>
        <member name="M:LogUtils.Requests.Validation.RequestValidator.ShowLogsValidation(LogUtils.Enums.LogID)">
            <summary>
            Checks that the <see cref="P:RainWorld.ShowLogs"/> property is applicable to the provided <see cref="T:LogUtils.Enums.LogID"/> instance, and returns the applicable <see cref="T:LogUtils.Requests.RejectionReason"/> when it does
            </summary>
        </member>
        <member name="M:LogUtils.Requests.Validation.RequestValidator.ShowLogsViolation">
            <summary>
            Gets the applicable <see cref="T:LogUtils.Requests.RejectionReason"/> for a <see cref="P:RainWorld.ShowLogs"/> aware log request
            </summary>
        </member>
        <member name="M:LogUtils.Requests.Validation.IRequestValidator.GetResult(LogUtils.Requests.LogRequest)">
            <summary>
            Evaluates a <see cref="T:LogUtils.Requests.LogRequest"/> object
            </summary>
            <param name="request">The request to evaluate</param>
            <returns>The processed handle state based on logger specific validation rules</returns>
        </member>
        <member name="T:LogUtils.SharedDataHandler">
            <summary>
            This class maintains a list of data inside of a MonoBehavior for easy access from multiple mod sources
            </summary>
        </member>
        <member name="P:LogUtils.SharedDataHandler.Tag">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.SharedDataHandler.Find(System.Type,System.String)">
            <summary>
            Finds the first IShareable with a given tag under the specified type
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
            <param name="tag">The search tag</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.FindAll(System.Type,System.String)">
            <summary>
            Finds all IShareable instances with a given tag under the specified type
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
            <param name="tag">The search tag</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.RegisterData(LogUtils.IShareable)">
            <summary>
            Assigns an IShareable to the data list of its own type
            </summary>
            <param name="data">Data to store under a registered type</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.RegisterData(System.Type,LogUtils.IShareable)">
            <summary>
            Assigns an IShareable to the data list of the specified type
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
            <param name="data">Data to store under a registered type</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.RegisterType(System.Type)">
            <summary>
            Assigns a list for data of the specified type
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.ReplaceData(System.Type,LogUtils.IShareable)">
            <summary>
            Assigns an IShareable to the data list of the specified type, existing data will be overwritten
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
            <param name="data">Data to store under a registered type</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.GetField``1(System.String,``0)">
            <summary>
            Retrieves a registered SharedField instance with the specified tag, and optional initial value
            </summary>
            <typeparam name="T">The type of data that will be stored in the field</typeparam>
            <param name="tag">The search tag</param>
            <param name="initValue">A value to be optionally set on creation of the SharedField</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.GetField``1(System.Type,System.String,``0)">
            <summary>
            Retrieves a registered SharedField instance with the specified tag, and optional initial value
            </summary>
            <typeparam name="T">The type of data that will be stored in the field</typeparam>
            <param name="tag">The search tag</param>
            <param name="type">The desired type to associate IShareables with</param>
            <param name="initValue">A value to be optionally set on creation of the SharedField</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.GetOrAssign(LogUtils.IShareable)">
            <summary>
            Retrieves an IShareable with an existing data tag, or stores, and returns the given one if it does not yet exist
            This method uses the data type to retrieve the data
            </summary>
            <param name="data">The data to check for, or retrieve</param>
            <returns>The associated shared data object</returns>
        </member>
        <member name="M:LogUtils.SharedDataHandler.GetFields">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.SharedField`1.Tag">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.SharedField`1.CheckTag(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.IShareable.Tag">
            <summary>
            An identifying string used for lookup and storage of objects through a SharedDataHandler
            </summary>
        </member>
        <member name="M:LogUtils.IShareable.CheckTag(System.String)">
            <summary>
            Checks that a tag matches a given input string
            </summary>
            <param name="tag">The input to compare to</param>
            <returns>Whether a match has been found</returns>
        </member>
        <member name="P:LogUtils.TempFolder.OrphanedFiles">
            <summary>
            Contains paths pertaining to files within the temp folder flagged as orphaned; usually an indication that the file was unable to be moved from the directory
            </summary>
        </member>
        <member name="P:LogUtils.TempFolder.SafeToDelete">
            <summary>
            Checks whether deletion of the temp folder minimizes risk of unwanted data loss
            </summary>
        </member>
        <member name="P:LogUtils.TempFolder.Path">
            <summary>
            Full path to LogUtils temporary folder
            </summary>
        </member>
        <member name="M:LogUtils.TempFolder.CreateDirectoryFor(System.String)">
            <summary>
            Creates the directory structure for a given file, or directory path
            </summary>
            <param name="path">A file, or directory path</param>
            <returns>The created directory path, or null if path could not be created</returns>
        </member>
        <member name="M:LogUtils.TempFolder.MapPathToFolder(System.String)">
            <summary>
            Maps a path, filename, or directory to a location within the Temp folder, and returns the resulting path string
            </summary>
            <param name="path">A path, filename, or directory name to locate</param>
            <returns>A fully qualified path inside the Temp folder</returns>
            <remarks>No attempt is made to ensure path exists within the Temp folder</remarks>
        </member>
        <member name="M:LogUtils.TempFolder.Access">
            <summary>
            Signal that a process intends to access and use LogUtils defined temporary folder. While accessing, LogUtils guarantees that the folder wont be moved, or deleted
            through the <see cref="T:LogUtils.TempFolder"/> public API. Call <see cref="M:LogUtils.TempFolder.RevokeAccess"/> to signal that your process no longer needs to access the Temp folder.
            </summary>
            <remarks>For each time this method is called, a following <see cref="M:LogUtils.TempFolder.RevokeAccess"/> must also be called.</remarks>
        </member>
        <member name="M:LogUtils.TempFolder.RevokeAccess">
            <summary>
            Signal that a process no longer needs to access any data located inside of the LogUtils defined temporary folder. Do not call this unless your process
            already has access. Doing so may corrupt/remove data being used by other processes that require this temporary folder.
            </summary>
        </member>
        <member name="M:LogUtils.TempFolder.OrphanAllFiles">
            <summary>
            Does an inventory of all files inside the temp folder (when it exists), and marks each file as orphaned
            </summary>
        </member>
        <member name="T:LogUtils.Templates.LoggerTemplate">
            <summary>
            Illustrates the standardized method order implementation of the ILogger interface
            </summary>
        </member>
        <member name="T:LogUtils.Templates.LoggingAdapter">
            <summary>
            An example class demonstration on how to encapsulate, and use a LogUtils instance without the assembly being aware that LogUtils is available at runtime.
            A fallback implementation is used in the case that LogUtils is unavailable. Be aware that a fallback implementation should bear the same responsibilities
            associated with maintaining a custom log file in the situation that LogUtils cannot perform such functions for the user.
            </summary>
        </member>
        <member name="M:LogUtils.Templates.LoggingAdapter.LogUtilsAccess.UnsafeAccess">
            <summary>
            Attempt to initialize LogUtils assembly
            </summary>
            <exception cref="T:System.TypeLoadException">An assembly dependency is unavailable, or is of the wrong version</exception>
        </member>
        <member name="T:LogUtils.Templates.LoggingAdapter.LogUtilsAccess.LogUtilsAdapter">
            <summary>
            Wrapper class for a LogUtils Logger instance
            </summary>
        </member>
        <member name="M:LogUtils.Templates.LoggingAdapter.CreateLogger">
            <summary>
            Creates a logger employing a safe encapsulation technique
            </summary>
        </member>
        <member name="T:LogUtils.Templates.IMyLogger">
            <summary>
            Interface provides a safe boundary with and a compatible interface for a LogUtils logger instance
            </summary>
        </member>
        <member name="T:LogUtils.Threading.AdapterLock">
            <summary>
            A lock type that acts as a wrapper around a provided lock object
            </summary>
        </member>
        <member name="M:LogUtils.Threading.AdapterLock.#ctor(System.Object)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Threading.AdapterLock"/> object
            </summary>
            <param name="lockObject">An object that will be used for locking</param>
            <exception cref="T:System.ArgumentNullException">Lock object is a null value.</exception>
            <exception cref="T:LogUtils.Threading.LockInvocationException">An exception was thrown during a lock monitoring event.</exception>
        </member>
        <member name="M:LogUtils.Threading.AdapterLock.#ctor(System.Object,System.Object)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Threading.AdapterLock"/> object
            </summary>
            <param name="lockObject">An object that will be used for locking</param>
            <param name="context">An object that identifies this instance</param>
            <exception cref="T:System.ArgumentNullException">Lock object is a null value.</exception>
            <exception cref="T:LogUtils.Threading.LockInvocationException">An exception was thrown during a lock monitoring event.</exception>
        </member>
        <member name="M:LogUtils.Threading.AdapterLock.#ctor(System.Object,LogUtils.Threading.Lock.ContextProvider)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Threading.AdapterLock"/> object
            </summary>
            <param name="lockObject">An object that will be used for locking</param>
            <param name="contextProvider">A callback that returns a context on demand</param>
            <exception cref="T:System.ArgumentNullException">Lock object is a null value.</exception>
            <exception cref="T:LogUtils.Threading.LockInvocationException">An exception was thrown during a lock monitoring event.</exception>
        </member>
        <member name="M:LogUtils.Threading.CombinationLock`1.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Threading.FileLock.FileContext">
            <summary>
            The associated log file context
            </summary>
        </member>
        <member name="P:LogUtils.Threading.FileLock.LastActivity">
            <summary>
            The last known file change/access activity that resulted in acquiring the file lock  
            </summary>
        </member>
        <member name="T:LogUtils.Threading.InvalidStateException">
            <summary>
            Exception is thrown when an object is in an invalid state for the current operation
            </summary>
        </member>
        <member name="F:LogUtils.Threading.InvalidStateException.DEFAULT_MESSAGE">
            <summary>
            Message that will be used by default if one is not specified
            </summary>
        </member>
        <member name="F:LogUtils.Threading.InvalidStateException.DEFAULT_MESSAGE_FORMAT">
            <summary>
            Message that will be used by default if one is not specified, and <see cref="T:LogUtils.Threading.Task"/> is provided
            </summary>
        </member>
        <member name="M:LogUtils.Threading.InvalidStateException.#ctor">
            <summary/>
        </member>
        <member name="M:LogUtils.Threading.InvalidStateException.#ctor(LogUtils.Threading.Task)">
            <summary/>
        </member>
        <member name="M:LogUtils.Threading.InvalidStateException.#ctor(System.String)">
            <summary/>
        </member>
        <member name="M:LogUtils.Threading.InvalidStateException.#ctor(System.String,System.Exception)">
            <summary/>
        </member>
        <member name="M:LogUtils.Threading.InvalidStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary/>
        </member>
        <member name="T:LogUtils.Threading.Lock">
            <summary>
            A wrapper class for a locked object implementation. API exposes a lockable Scope designed to work with with 'using' keyword, does not work well with 'lock'
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Lock.ActiveCount">
            <summary>
            The number of acquired locks yet to be released
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Lock.Context">
            <summary>
            Information assigned to identify the lock instance
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Lock.IsAcquiredByCurrentThread">
            <summary/>
        </member>
        <member name="F:LogUtils.Threading.Lock.SuppressNextRelease">
            <summary>
            Suppresses the next Release attempt made on this lock 
            </summary>
        </member>
        <member name="E:LogUtils.Threading.Lock.OnEvent">
            <summary>
            Listens to lock monitoring events, (such as a lock being created, acquired, or released)
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Lock.#ctor">
            <summary>
            Constructs a new <see cref="T:LogUtils.Threading.Lock"/> object
            </summary>
            <exception cref="T:LogUtils.Threading.LockInvocationException">An exception was thrown during a lock monitoring event.</exception>
        </member>
        <member name="M:LogUtils.Threading.Lock.#ctor(System.Object)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Threading.Lock"/> object
            </summary>
            <param name="context">An object that identifies this instance</param>
            <exception cref="T:LogUtils.Threading.LockInvocationException">An exception was thrown during a lock monitoring event.</exception>
        </member>
        <member name="M:LogUtils.Threading.Lock.#ctor(LogUtils.Threading.Lock.ContextProvider)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Threading.Lock"/> object
            </summary>
            <param name="contextProvider">A callback that returns a context on demand</param>
            <exception cref="T:LogUtils.Threading.LockInvocationException">An exception was thrown during a lock monitoring event.</exception>
        </member>
        <member name="M:LogUtils.Threading.Lock.Acquire">
            <summary>
            Acquires a lock on the current thread
            </summary>
            <exception cref="T:LogUtils.Threading.LockInvocationException">An exception was thrown during a lock monitoring event.</exception>
        </member>
        <member name="M:LogUtils.Threading.Lock.Release">
            <summary>
            Releases a lock monitored on the current thread
            </summary>
            <exception cref="T:LogUtils.Threading.LockInvocationException">An exception was thrown during a lock monitoring event.</exception>
            <exception cref="T:System.Threading.SynchronizationLockException">"The current thread does not own the lock for the specified object."</exception>
        </member>
        <member name="T:LogUtils.Threading.Lock.Scope">
            <summary>
            A disposable type that will release a lock on the current thread on dispose
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Lock.Scope.Dispose">
            <summary>
            Releases a lock acquired by the calling thread
            </summary>
            <exception cref="T:System.Threading.SynchronizationLockException">The calling thread does not have any active locks to release</exception>
        </member>
        <member name="T:LogUtils.Threading.Lock.ContextProvider">
            <summary>
            A callback used to provide a context on demand
            </summary>
        </member>
        <member name="T:LogUtils.Threading.LockInvocationException">
            <summary>
            An <see cref="T:System.Exception"/> type that is thrown when an exception is captured from a lock monitoring event
            </summary>
        </member>
        <member name="P:LogUtils.Threading.LogTasker.ThreadID">
            <summary>
            The managed thread ID of the LogTasker thread
            </summary>
        </member>
        <member name="P:LogUtils.Threading.LogTasker.WaitingOnSignal">
            <summary>
            Task thread is waiting on another thread to signal it to continue
            </summary>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.StartBatching">
            <summary>
            Allows tasks to be scheduled in an uninterrupted sequence
            </summary>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.Schedule(LogUtils.Threading.Task)">
            <summary>
            Schedules a task to run on a background thread
            </summary>
            <param name="task">Task to run</param>
            <exception cref="T:System.ArgumentNullException">Exception that throws when passing in a null task</exception>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.ScheduleBefore(LogUtils.Threading.Task,LogUtils.Threading.Task)">
            <summary>
            Schedules a task to run before another task on a background thread
            </summary>
            <param name="task">Task to run</param>
            <param name="taskOther">Task that should run after</param>
            <exception cref="T:LogUtils.Threading.TaskNotFoundException">Exception that throws if the targeted task does not exist</exception>
            <exception cref="T:System.ArgumentNullException">Exception that throws when passing in a null task</exception>
            <exception cref="T:System.ArgumentException">Exception that throws if the task instances are the same</exception>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.ScheduleAfter(LogUtils.Threading.Task,LogUtils.Threading.Task)">
            <summary>
            Schedules a task to run after another task on a background thread
            </summary>
            <param name="task">Task to run</param>
            <param name="taskOther">Task that should run before</param>
            <exception cref="T:LogUtils.Threading.TaskNotFoundException">Exception that throws if the targeted task does not exist</exception>
            <exception cref="T:System.ArgumentNullException">Exception that throws when passing in a null task</exception>
            <exception cref="T:System.ArgumentException">Exception that throws if the task instances are the same</exception>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.EndTask(LogUtils.Threading.Task,System.Boolean)">
            <summary>
            Sets the task state to Aborted, or Complete
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Task.Name">
            <summary>
            A string used to identify a task in logging events
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Task.ID">
            <summary>
            A value assigned to a task during initialization to distinguish it from other tasks
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Task.Handle">
            <summary>
            Exposes the <see cref="T:System.Threading.Tasks.Task"/> used in asynchronous task operation
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Task.Run">
            <summary>
            Task operation invoked by this task
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Task.State">
            <summary>
            The current task completion state
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Task.IsRunning">
            <summary>
            Checks whether an async task operation has been scheduled and has yet to be completed
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Task.IsSynchronous">
            <summary>
            Checks whether task operation runs synchronously with other tasks
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Task.IsCompleteOrCanceled">
            <summary>
            Checks whether a task is in a completion state
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Task.PossibleToRun">
            <summary>
            Checks whether task operation is possible to run based on the current task state
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Task.WaitTimeInterval">
            <summary>
            The time to wait in between task runs
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Task.HasRunOnce">
            <summary>
            Checks whether task has run at least once
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Task.IsContinuous">
            <summary>
            When true, task will run more than one time, instead of once
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.#ctor(System.Action,System.Int32)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Threading.Task"/> object
            </summary>
            <param name="runTask">Task operation to store and execute later</param>
            <param name="waitTimeInMS">Timespan to wait to execute task operation when scheduled</param>
            <exception cref="T:System.ArgumentNullException">Task operation is null</exception>
            <remarks>Pass this object into <see cref="T:LogUtils.Threading.LogTasker"/> to run a task on a background thread</remarks>
        </member>
        <member name="M:LogUtils.Threading.Task.#ctor(System.Action,System.TimeSpan)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Threading.Task"/> object
            </summary>
            <param name="runTask">Task operation to store and execute later</param>
            <param name="waitTime">Timespan to wait to execute task operation when scheduled</param>
            <exception cref="T:System.ArgumentNullException">Task operation is null</exception>
            <remarks>Pass this object into <see cref="T:LogUtils.Threading.LogTasker"/> to run a task on a background thread</remarks>
        </member>
        <member name="M:LogUtils.Threading.Task.#ctor(LogUtils.Threading.TaskProvider,System.TimeSpan)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Threading.Task"/> object
            </summary>
            <param name="runTaskAsync">A delegate that provides a <see cref="T:System.Threading.Tasks.Task"/> operation to store and execute later</param>
            <param name="waitTime">Timespan to wait to execute task operation when scheduled</param>
            <exception cref="T:System.ArgumentNullException">Task operation is null</exception>
            <remarks>Pass this object into <see cref="T:LogUtils.Threading.LogTasker"/> to run a task on a background thread</remarks>
        </member>
        <member name="M:LogUtils.Threading.Task.GetAsyncHandle">
            <summary>
            Get an awaitable handle that will complete when the task ends
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.RunOnce">
            <summary>
            Runs the task a single time
            </summary>
            <exception cref="T:System.InvalidOperationException">The task is already completed, or canceled OR the task is running on another thread, and task concurrency is not allowed</exception>
        </member>
        <member name="M:LogUtils.Threading.Task.RunOnceAndEnd(System.Boolean)">
            <summary>
            Runs the task a single time before terminating
            </summary>
            <param name="force">Should this task bypass the scheduling process (in the case of an unsubmitted task)</param>
            <exception cref="T:System.InvalidOperationException">The task is already completed, or canceled OR the task is running on another thread, and task concurrency is not allowed</exception>
            <exception cref="T:LogUtils.Threading.InvalidStateException">The state has failed, or has been marked as complete</exception>
        </member>
        <member name="M:LogUtils.Threading.Task.Cancel">
            <summary>
            Task will no longer run - asynchronous operations that support cancel operations will be notified
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.Complete">
            <summary>
            Task will no longer run - asynchronous operations started by the task may still continue
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.RunBefore(LogUtils.Threading.Task)">
            <summary>
            Positions this task before another task in the task run list
            </summary>
            <param name="otherTask">The task that shall run after</param>
            <exception cref="T:LogUtils.Threading.TaskNotFoundException">Exception that throws if the targeted task does not exist</exception>
            <exception cref="T:System.ArgumentException">Exception that throws if the task instances are the same</exception>
        </member>
        <member name="M:LogUtils.Threading.Task.RunAfter(LogUtils.Threading.Task)">
            <summary>
            Positions this task after another task in the task run list
            </summary>
            <param name="otherTask">The task that shall run before</param>
            <exception cref="T:LogUtils.Threading.TaskNotFoundException">Exception that throws if the targeted task does not exist</exception>
            <exception cref="T:System.ArgumentException">Exception that throws if the task instances are the same</exception>
        </member>
        <member name="M:LogUtils.Threading.Task.SetID">
            <summary>
            Assigns a randomized identifier value
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.WaitUntil(System.Func{System.Boolean},System.Int32,System.Int32)">
            <summary>
            Blocks until condition is true or timeout occurs.
            </summary>
            <param name="condition">The break condition</param>
            <param name="frequency">The frequency at which the condition will be checked</param>
            <param name="timeout">The timeout in milliseconds</param>
            <exception cref="T:System.TimeoutException">Timeout expired</exception>
        </member>
        <member name="T:LogUtils.Threading.TaskFinalizer">
            <summary>
            A struct wrapper for walking through a multi-step asynchronous process
            </summary>
        </member>
        <member name="P:LogUtils.Threading.TaskFinalizer.Current">
            <summary>
            Gets the currently running, or completed <see cref="T:System.Threading.Tasks.Task"/> object
            </summary>
        </member>
        <member name="M:LogUtils.Threading.TaskFinalizer.CompleteTask">
            <summary>
            Invoke finalizer code on an enumerated task
            </summary>
            <exception cref="T:System.InvalidOperationException">Task execution finalizer has already run</exception>
        </member>
        <member name="P:LogUtils.Threading.TaskHandle.IsValid">
            <summary>
            
            </summary>
        </member>
        <member name="F:LogUtils.Threading.TaskHandle.Task">
            <summary>
            The asynchronous execution task
            </summary>
        </member>
        <member name="F:LogUtils.Threading.TaskHandle.Owner">
            <summary>
            The task that this handle belongs to
            </summary>
        </member>
        <member name="F:LogUtils.Threading.TaskHandle.CancellationToken">
            <summary>
            An object that LogTasker uses to request early termination of a task
            </summary>
        </member>
        <member name="F:LogUtils.Threading.TaskHandle.accessCount">
            <summary>
            The number of unreleased references to this instance
            </summary>
        </member>
        <member name="M:LogUtils.Threading.TaskHandle.Dispose">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.Threading.TaskHandle"/>
            </summary>
        </member>
        <member name="T:LogUtils.Threading.TaskNotFoundException">
            <summary>
            An exception that is thrown when a Task is expected to be found, but the Task could not be located
            </summary>
        </member>
        <member name="F:LogUtils.Threading.ThreadSafeWorker.UseEnumerableWrapper">
            <summary>
            A flag that indicates whether locks should be extracted from the provided enumerable, and placed into an array before work starts
            </summary>
            <remarks>May be set to false if underlying enumerable is unlikely to be modified during work</remarks>
        </member>
        <member name="F:LogUtils.Threading.ThreadSafeWorker.RetryInterval">
            <summary>
            Wait time to retry acquiring the locks (in the case of lock contention) 
            </summary>
        </member>
        <member name="M:LogUtils.Threading.ThreadSafeWorker.DoWorkAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Perform work that must be run asynchronously on a background thread
            </summary>
            <param name="work">Work to be performed</param>
            <param name="cancellationToken">A token for cancelling the task</param>
            <returns>An enumerator to signal the end of work</returns>
        </member>
        <member name="M:LogUtils.Threading.ThreadSafeWorker.LockEnumerator.Acquire">
            <summary>
            Acquires all locks stored in the enumerable
            </summary>
            <exception cref="T:LogUtils.Threading.LockInvocationException"></exception>
        </member>
        <member name="F:LogUtils.TimedLogWriter.WriteTask">
            <summary>
            This task handles writing to file, on a fixed interval off the main thread
            </summary>
        </member>
        <member name="F:LogUtils.TimedLogWriter.INTERVAL_DEFAULT">
            <summary>
            The flush interval in milliseconds
            </summary>
        </member>
        <member name="M:LogUtils.TimedLogWriter.#ctor(System.Int32)">
            <summary>
            Constructs a TimedLogWriter instance
            </summary>
            <param name="writeInterval">The flush interval in milliseconds</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The flush interval is an invalid value</exception>
        </member>
        <member name="M:LogUtils.TimedLogWriter.Flush">
            <summary>
            Flushes the stream buffer to file
            </summary>
            <exception cref="T:System.ObjectDisposedException">The writer has been disposed</exception>
        </member>
        <member name="M:LogUtils.TimedLogWriter.ScheduleFlush">
            <summary>
            Attempts to flush the stream buffer to file on a .NET task thread
            </summary>
        </member>
        <member name="M:LogUtils.TimedLogWriter.TryFlush">
            <summary>
            Attempts to flush the stream buffer to file
            </summary>
        </member>
        <member name="M:LogUtils.TimedLogWriter.WriteToFile(LogUtils.Requests.LogRequest)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.TimedLogWriter.AssignWriter(LogUtils.Enums.LogID,System.IO.StreamWriter@)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.TimedLogWriter.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.TimedLogWriter.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.TimedLogWriter"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.TimedLogWriter.Dispose">
            <inheritdoc cref="M:LogUtils.TimedLogWriter.Dispose(System.Boolean)"/>
        </member>
        <member name="M:LogUtils.TimedLogWriter.Finalize">
            <summary/>
        </member>
        <member name="F:LogUtils.Timers.EventScheduler.scheduledEvents">
            <summary>
            Maintain a strong list of ScheduledEvents to prevent their associated FrameTimers from disposing
            </summary>
        </member>
        <member name="P:LogUtils.Timers.EventScheduler.Tag">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.AddEvent(LogUtils.Timers.ScheduledEvent)">
            <summary>
            Adds a ScheduledEvent to be managed by the current instance
            </summary>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.AddTimer(LogUtils.Timers.FrameTimer)">
            <summary>
            Adds a timer to be managed by the current instance
            </summary>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.Schedule(System.Action,System.Int32,System.Int32)">
            <summary>
            Schedules an event delegate to be invoked periodically after a specified number of frames 
            </summary>
            <param name="action">The delegate to invoke</param>
            <param name="frameInterval">The number of frames in between event invocations</param>
            <param name="invokeLimit">The maximum number of invocations to attempt</param>
            <returns>An object containing the event state</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The frame interval is an invalid value</exception>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.Schedule(System.Action,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Schedules an event delegate to be invoked periodically after a specified number of frames 
            </summary>
            <param name="action">The delegate to invoke</param>
            <param name="frameInterval">The number of frames in between event invocations</param>
            <param name="syncToRainWorld">When true, event will be handled in MainLoopProcess.Update instead of through EventScheduler.Update</param>
            <param name="invokeLimit">The maximum number of invocations to attempt</param>
            <returns>An object containing the event state</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The frame interval is an invalid value</exception>
        </member>
        <member name="F:LogUtils.Timers.EventScheduler.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing an <see cref="T:LogUtils.Timers.EventScheduler"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.Dispose">
            <inheritdoc cref="M:LogUtils.Timers.EventScheduler.Dispose(System.Boolean)"/>
        </member>
        <member name="P:LogUtils.Timers.ScheduledEvent.InvokeCount">
            <summary>
            The number of times this event has been fired
            </summary>
        </member>
        <member name="F:LogUtils.Timers.ScheduledEvent.InvokeLimit">
            <summary>
            The amount of times event may be invoked
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.Event">
            <summary>
            Contains a reference to a ScheduledEvent for timers created by an EventScheduler
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.IsSynchronous">
            <summary>
            Should this timer be synced with the current RainWorld process or attempt to update on every available frame
            </summary>
        </member>
        <member name="P:LogUtils.Timers.FrameTimer.Released">
            <summary>
            The FrameTimer equivalent of a disposed flag
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.SyncHandler">
            <summary>
            Stores delegate information that will run when an synchronous event is handled
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.ElapsedTicks">
            <summary>
            Number of allowed frame updates since timer was last started
            </summary>
        </member>
        <member name="M:LogUtils.Timers.FrameTimer.Start">
            <summary>
            Allows frame counter to update
            </summary>
        </member>
        <member name="M:LogUtils.Timers.FrameTimer.Stop">
            <summary>
            Prevents frame counter from updating
            </summary>
        </member>
        <member name="M:LogUtils.Timers.FrameTimer.Release">
            <summary>
            Activate timer dispose procedure
            </summary>
        </member>
        <member name="M:LogUtils.Timers.FrameTimer.Restart">
            <summary>
            Resets frame counter back to zero and resumes updating the frame counter
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.OnRelease">
            <summary>
            Invoked when a FrameTimer instance signals that it should no longer be updated by the scheduler
            </summary>
        </member>
        <member name="T:LogUtils.Timers.PollingTimer">
            <summary>
            Class hides base methods. It is recommended to not use this class while casted by the <see cref="T:System.Timers.Timer"/> base class
            </summary>
        </member>
        <member name="P:LogUtils.Timers.PollingTimer.Started">
            <summary>
            The timer is available and is actively running
            </summary>
        </member>
        <member name="F:LogUtils.Timers.PollingTimer.Tag">
            <summary>
            Used to attach identifying information
            </summary>
        </member>
        <member name="F:LogUtils.Timers.PollingTimer.TrackingPollTime">
            <summary>
            Should the timer record the time of poll signals
            </summary>
        </member>
        <member name="F:LogUtils.Timers.PollingTimer.lastPollTime">
            <summary>
            The last time the timer was signaled (in ticks)
            </summary>
        </member>
        <member name="P:LogUtils.Timers.PollingTimer.PollFlagged">
            <summary>
            The poll state since the last elapsed time interval
            </summary>
        </member>
        <member name="E:LogUtils.Timers.PollingTimer.OnSignal">
            <summary>
            Activated when timer is signaled
            </summary>
        </member>
        <member name="E:LogUtils.Timers.PollingTimer.OnTimeout">
            <summary>
            Activated when an entire polling interval passes without receiving a poll signal
            </summary>
        </member>
        <member name="M:LogUtils.Timers.PollingTimer.#ctor(System.Double)">
            <summary>
            Constructs a new <see cref="T:LogUtils.Timers.PollingTimer"/> instance
            </summary>
            <param name="checkInterval">The time window in which a polling flag must be set</param>
        </member>
        <member name="M:LogUtils.Timers.PollingTimer.Signal">
            <summary>
            Notifies the timer that it shouldn't raise an event on the next timed interval
            </summary>
        </member>
        <member name="M:LogUtils.Timers.PollingTimer.Start">
            <inheritdoc cref="M:System.Timers.Timer.Start"/>
            <exception cref="T:System.ObjectDisposedException">Attempted to access object after it was disposed</exception>
        </member>
        <member name="M:LogUtils.Timers.PollingTimer.Stop">
            <inheritdoc cref="M:System.Timers.Timer.Stop"/>
        </member>
        <member name="M:LogUtils.Timers.PollingTimer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.UtilityComponent">
            <summary>
            Base class for UnityEngine components used by the assembly
            </summary>
        </member>
        <member name="P:LogUtils.UtilityComponent.Version">
            <summary>
            The version of a component is the same as its assembly version. In the situation of multiple loaded assemblies,
            this version may not match other loaded assemblies
            </summary>
        </member>
        <member name="P:LogUtils.UtilityComponent.Tag">
            <summary>
            A tag used for identification purposes (Not the same field as <see cref="P:UnityEngine.Component.tag"/>)
            </summary>
        </member>
        <member name="M:LogUtils.UtilityComponent.GetFields">
            <summary>
            Returns field values stored by the component using the field name as the key 
            </summary>
        </member>
        <member name="M:LogUtils.UtilityConsts.DataFields.IsRecognizedField(System.String)">
            <summary>
            Case sensitive comparison of a string against known utility DataFields
            </summary>
        </member>
        <member name="M:LogUtils.UtilityConsts.LogNames.NameMatch(System.String)">
            <summary>
            Evaluates whether given name is a match to a game log filename
            </summary>
        </member>
        <member name="F:LogUtils.UtilityConsts.ExceptionDataKey.CONTEXT">
            <summary>Reserved for general data storage, especially identification data.</summary>
        </member>
        <member name="F:LogUtils.UtilityConsts.ExceptionDataKey.TARGET_PATH">
            <summary>Reserved for data that identifies a targeted file, or directory path.</summary>
            <remarks>Caution: Data may be incomplete, or contain invalid characters.</remarks>
        </member>
        <member name="F:LogUtils.UtilityConsts.ExceptionDataKey.SOURCE_PATH">
            <summary>Reserved for data that identifies a file, or directory path that represents an initial state.</summary>
            <remarks>Caution: Data may be incomplete, or contain invalid characters.</remarks>
        </member>
        <member name="F:LogUtils.UtilityConsts.ExceptionDataKey.DESTINATION_PATH">
            <summary>Reserved for data that identifies a file, or directory path that represents a transition, or destination state.</summary>
            <remarks>Caution: Data may be incomplete, or contain invalid characters.</remarks>
        </member>
        <member name="F:LogUtils.UtilityCore.Build">
            <summary>
            The active build environment for the assembly
            </summary>
        </member>
        <member name="P:LogUtils.UtilityCore.IsControllingAssembly">
            <summary>
            The assembly responsible for loading core resources for the utility
            </summary>
        </member>
        <member name="P:LogUtils.UtilityCore.IsInitialized">
            <summary>
            The initialized state for the assembly. This does NOT indicate that another version of the assembly has initialized,
            and every assembly must go through the init process
            </summary>
        </member>
        <member name="P:LogUtils.UtilityCore.InitializedWithErrors">
            <summary>
            The initialized state encountered a problem during initialization
            </summary>
        </member>
        <member name="F:LogUtils.UtilityCore.initializingInProgress">
            <summary>
            The initialization process is in progress for the current assembly
            </summary>
        </member>
        <member name="F:LogUtils.UtilityCore.Config">
            <inheritdoc cref="T:LogUtils.Policy.UtilityConfig"/>
        </member>
        <member name="F:LogUtils.UtilityCore.DataHandler">
            <summary>
            Handles cross-mod data storage for the utility
            </summary>
        </member>
        <member name="F:LogUtils.UtilityCore.RequestHandler">
            <summary>
            Handles log requests between different loggers
            </summary>
        </member>
        <member name="M:LogUtils.UtilityCore.EnsureInitializedState">
            <summary>
            Ensures that core functionality is in a proper and useable state by ensuring the initialization procedure has run
            </summary>
        </member>
        <member name="M:LogUtils.UtilityCore.LoadComponents">
            <summary>
            Creates, or establishes a reference to an existing instance of necessary utility components
            </summary>
        </member>
        <member name="F:LogUtils.UtilityLogger.activityLogger">
            <summary>
            Activity logger is responsible for reporting file behavior associated with log related files
            </summary>
        </member>
        <member name="F:LogUtils.UtilityLogger.writeTask">
            <summary>
            Used to maintain the high performance write implementation
            </summary>
        </member>
        <member name="P:LogUtils.UtilityLogger.PerformanceMode">
            <summary>
            Enables a write buffer that intercepts all debug logs and writes them to file off the main thread
            </summary>
        </member>
        <member name="M:LogUtils.UtilityLogger.CreateLogger(System.String,LogUtils.Formatting.StringProvider)">
            <summary>
            Creates a logger that LogUtils can use to log to files directly (without using LogIDs, or the log request system) - not intended for users of LogUtils
            </summary>
        </member>
        <member name="M:LogUtils.UtilityLogSource.Dispose">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.UtilityLogSource"/>
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>
            Backported attribute
            </summary>
        </member>
    </members>
</doc>

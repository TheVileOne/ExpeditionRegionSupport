<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LogUtils</name>
    </assembly>
    <members>
        <member name="T:LogUtils.BackupListener">
            <summary>
            Provides a means for mods to listen for log backup opportunity signals
            </summary>
        </member>
        <member name="E:LogUtils.BackupListener.Feed">
            <summary>
            Allows subscribers access to all recent, and future backup records
            </summary>
        </member>
        <member name="F:LogUtils.BackupListener.EventRecord.LogFile">
            <summary>
            Backup target
            </summary>
        </member>
        <member name="F:LogUtils.BackupListener.EventRecord.SourcePath">
            <summary>
            The primary source path to the temporary file
            </summary>
        </member>
        <member name="F:LogUtils.BackupListener.EventRecord.BackupPaths">
            <summary>
            A list of source paths for log backups created by other mods (use in case the file is no longer at the primary source path)
            </summary>
        </member>
        <member name="F:LogUtils.ChangeState.FieldState">
            <summary>
            The value of the field when the state was created
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Capacity">
            <summary>
            The amount of nodes managed by the node leaser
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.First">
            <inheritdoc cref="P:System.Collections.Generic.LinkedList`1.First"/>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Last">
            <inheritdoc cref="P:System.Collections.Generic.LinkedList`1.Last"/>
        </member>
        <member name="F:LogUtils.Collections.BufferedLinkedList`1.AllowModificationsDuringIteration">
            <summary>
            Enable or disable collection modification protection
            </summary>
            <remarks>This is essentially deprecated</remarks>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.#ctor(System.Int32)">
            <summary>
            Construct a BufferedLinkedList object
            </summary>
            <param name="capacity">The amount of nodes to maintain in the leaser by default</param>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnsureCapacity">
            <summary>
            Ensure that there are always nodes available in the node leaser
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.AddFirst(`0)">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.AddFirst(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.AddLast(`0)">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.AddLast(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.AddBefore(System.Collections.Generic.LinkedListNode{`0},`0)">
            <summary>
            Adds the specified value to a new node before the specified existing node
            </summary>
            <returns>The node storing the specified value</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},`0)">
            <summary>
            Adds the specified value to a new node after the specified existing node
            </summary>
            <returns>The node storing the specified value</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Find(`0)">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.Find(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.FindLast(`0)">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.FindLast(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Remove(System.Collections.Generic.LinkedListNode{`0})">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.Remove(System.Collections.Generic.LinkedListNode{`0})"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.RemoveFirst">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.RemoveLast">
            <inheritdoc cref="M:System.Collections.Generic.LinkedList`1.RemoveLast"/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Where(System.Func{`0,System.Boolean})">
            <summary>
            Performs a Where query using the given predicate
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.GetLinkedListEnumerator">
            <summary>
            Returns an enumerator specially designed to enumerate through this collection
            </summary>
        </member>
        <member name="T:LogUtils.Collections.BufferedLinkedList`1.Enumerator">
            <summary>
            The specialized enumerator for BufferedLinkedList
            </summary>
        </member>
        <member name="F:LogUtils.Collections.BufferedLinkedList`1.Enumerator.refNode">
            <summary>
            This is the node that controls the reference to the Current node
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Enumerator.CurrentNode">
            <summary>
            The LinkedListNode associated with Current
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Enumerator.#ctor(LogUtils.Collections.BufferedLinkedList{`0})">
            <summary>
            Constructs an Enumerator struct
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Enumerator.Dispose">
            <summary>
            Resets enumerator to a default state
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.Enumerator.Reset">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper">
            <summary>
            A simple wrapper for handling an IEnumerable similarly to an ILinkedListEnumerable despite not having the same functionality as one
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.CurrentNode">
            <summary>
            Not implemented by design - data is unavailable
            </summary>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.Current">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Constructs an EnumeratorWrapper struct
            </summary>
            <param name="enumerator">The enumerator that is intended to be wrapped</param>
            <exception cref="T:System.ArgumentNullException">Enumerator is null</exception>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.Dispose">
            <summary>
            Resets enumerator to a default state
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.EnumeratorWrapper.Reset">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerableWrapper.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerable.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerable.GetLinkedListEnumerator">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.CurrentNode">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.Current">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.Dispose">
            <summary>
            Resets enumerator to a default state
            </summary>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:LogUtils.Collections.BufferedLinkedList`1.WhereEnumerator.Reset">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ILinkedListEnumerable`1.GetLinkedListEnumerator">
            <summary>
            Returns an enumerator designed to iterate through a LinkedList
            </summary>
        </member>
        <member name="P:LogUtils.Collections.ILinkedListEnumerator`1.CurrentNode">
            <summary>
            The LinkedListNode associated with Current
            </summary>
        </member>
        <member name="T:LogUtils.Collections.ValueCollection`1">
            <summary>
            A hashset wrapper class with built-in ReadOnly support from a bindable source
            </summary>
            <remarks>Class is mainly designed to keep user changes to LogProperties safe from modification </remarks>
        </member>
        <member name="P:LogUtils.Collections.ValueCollection`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Collections.ValueCollection`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Collections.ValueCollection`1.Values">
            <summary>
            The underlying dataset
            </summary>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.#ctor(LogUtils.Collections.ReadOnlyProvider)">
            <summary>
            Creates a new <see cref="T:LogUtils.Collections.ValueCollection`1"/> instance
            </summary>
            <param name="readOnlySource">The binding source for determining the ReadOnly state of the collection</param>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Reset">
            <summary>
            Changes collection back to its initial state
            </summary>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.ValueCollection`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.Add(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.RemoveCollectedEntries">
            <summary>
            Remove entries that have been collected by the Garbage Collector
            </summary>
        </member>
        <member name="M:LogUtils.Collections.WeakReferenceCollection`1.UnsafeCount">
            <summary>
            Returns the count of all entries in the collection, reference collected, or otherwise
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.AdapterServices.Convert(BepInEx.Logging.ManualLogSource)">
            <summary>
            Creates a wrapper object that can interface with a ManualLogSource
            </summary>
            <exception cref="T:System.ArgumentNullException">Provided source is null</exception>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.BepInExAdapter">
            <summary>
            Adapter service for converting the BepInEx logging system to the system that LogUtils operates
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExAdapter.AdaptLoggingSystem">
            <summary>
            Transitions the BepInEx logging system, and data over to the system operated by LogUtils
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExAdapter.CleanBepInExFolder">
            <summary>
            Detects, and removes log file copies in the original BepInEx logs folder directory
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExAdapter.RetroactivelyApplyRules(System.String)">
            <summary>
            Applies log rules to already logged messages, overwriting the existing file with the new changes
            </summary>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.BepInExInfo">
            <summary>
            Contains references to state controlled by BepInEx
            </summary>
        </member>
        <member name="P:LogUtils.Compatibility.BepInEx.BepInExInfo.ManagerObject">
            <summary>
            The GameObject that contains the game, and all modded assemblies
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.Close(BepInEx.Logging.ILogListener)">
            <summary>
            Removes listener from BepInEx Listeners collection, and disposes the listener instance
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.Find``1">
            <summary>
            Finds the first ILogListener of a given type, or null if not found
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.GetPlugin(System.Reflection.Assembly)">
            <summary>
            Gets the plugin instance associated with the provided assembly
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.GetPluginInfo(System.Reflection.Assembly)">
            <summary>
            Gets the PluginInfo instance associated with the provided assembly
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExInfo.GetPluginMetadata(System.Reflection.Assembly)">
            <summary>
            Gets the plugin metadata associated with the provided assembly
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.BepInExLogger.Source">
            <summary>
            BepInEx derived logging interface
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogDebug(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogInfo(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogImportant(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogMessage(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogWarning(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogError(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.LogFatal(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(System.String,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.BepInExLogger.Log(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.Config">
            <summary>
            Config values inherited from BepInEx
            </summary>
            <remarks>Changing these settings may not have an effect on LogUtils functionality</remarks>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.Base">
            <summary>
            Contains the BepInEx Core config instance
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.AllowConsole">
            <summary>
            Config setting affecting whether the a console is displayed when BepInEx loads
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.AllowLoggingToFile">
            <summary>
            Config setting affecting whether any logs make it to file, error logging excluded
            </summary>
            <remarks>Needs implementation</remarks>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.AllowUnityLogging">
            <summary>
            Config setting enabling, or disabling Unity logging
            </summary>
            <remarks>LogUtils provides this functionality through the properties file. Config option is unnecessary</remarks>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.AppendLogEntries">
            <summary>
            Config setting affecting whether the BepInEx log file gets replaced when BepInEx loads
            </summary>
            <remarks>LogUtils doesn't support this behavior yet</remarks>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Config.SendUnityLogsToOutputLog">
            <summary>
            Config setting affecting whether Unity logs also appear in the BepInEx output log file
            </summary>
            <remarks>LogUtils doesn't support this yet</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.Config.InitializeEntries">
            <summary>
            Config setting affecting whether Unity logs appear in the BepInEx console
            </summary>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.IExtendedLogSource">
            <summary>
            Represents a type that implements both ILogger, and ILogSource
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Writer">
            <summary>
            This writer handles all BepInEx log traffic for Rain World
            </summary>
        </member>
        <member name="F:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.utilityRequestsInProcess">
            <summary>
            Stores LogUtils requests until they are able to be handled
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Dispose">
            <inheritdoc cref="M:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Dispose(System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Compatibility.BepInEx.Listeners.DiskLogListener.Finalize">
            <summary/>
        </member>
        <member name="T:LogUtils.Compatibility.BepInEx.ManualLogSourceWrapper">
            <summary>
            A class dedicated to translating a ManualLogSource to an IExtendedLogSource
            </summary>
        </member>
        <member name="T:LogUtils.Compatibility.DotNet.DotNetLogger">
            <summary>
            A logger type that implements Microsoft's ILogger interface 
            </summary>
            <remarks>Allows you to use Microsoft's logging interface in addition to existing Logger provided functions</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.#ctor">
            <summary>
            Creates a new DotNetLogger instance
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.BeginScope``1(``0)">
            <summary>
            Currently not implemented
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.DotNetLogger.Log``1(Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,``0,System.Exception,System.Func{``0,System.Exception,System.String})">
            <summary>
            Logs a message using Microsoft's ILogger interface
            </summary>
            <typeparam name="TState">The type belonging to the provided message object state</typeparam>
            <param name="logLevel">The specified logging context</param>
            <param name="eventID">Extra identifying information associated with the log event</param>
            <param name="state">The message object</param>
            <param name="exception"></param>
            <param name="formatter"></param>
        </member>
        <member name="M:LogUtils.Compatibility.DotNet.LoggerUtils.GetEquivalentCategory(Microsoft.Extensions.Logging.LogLevel)">
            <summary>
            Converts a LogLevel enum to its LogCategory equivalent value
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityDoorstop.AddToWhitelist(System.String)">
            <summary>
            Adds a filename entry to whitelist.txt
            </summary>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityDoorstop.RemoveFromWhitelist(System.String)">
            <summary>
            Removes a filename entry to whitelist.txt
            </summary>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="P:LogUtils.Compatibility.Unity.UnityLogEventArgs.Context">
            <summary>
            Unity object - typically given to provide context to the log message
            </summary>
        </member>
        <member name="P:LogUtils.Compatibility.Unity.UnityLogEventArgs.Tag">
            <summary>
            Unity tag - typically given to provide context to the log message
            </summary>
        </member>
        <member name="T:LogUtils.Compatibility.Unity.UnityLogger">
            <summary>
            A logger that exclusively writes directly through Unity's logging API
            </summary>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.EnsureLogTypeCapacity(System.Int32)">
            <summary>
            Ensures that the maximum LogType value able to be processed by the Unity logger is at least the specified capacity value
            </summary>
            <param name="capacity">The desired maximum FilterType value as an integer</param>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.Log(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogDebug(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogInfo(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogImportant(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogMessage(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogWarning(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogError(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.LogFatal(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.Log(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.Log(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.Log(System.String,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="M:LogUtils.Compatibility.Unity.UnityLogger.Log(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <remarks>Utilizes Unity's logging API</remarks>
        </member>
        <member name="T:LogUtils.Logger">
            <summary>
            Allows you to log messages to file, or a console using the write implementation of your choosing
            </summary>
        </member>
        <member name="M:LogUtils.Logger.LogBase(UnityEngine.LogType,System.String,System.Object,UnityEngine.Object)">
            <summary>
            This method receives all log API calls that make use of Unity specific logging arguments for this logger
            </summary>
        </member>
        <member name="P:LogUtils.Logger.AllowLogging">
            <summary>
            A flag that allows/disallows handling of log requests (local and remote) through this logger 
            </summary>
        </member>
        <member name="P:LogUtils.Logger.AllowRemoteLogging">
            <summary>
            A flag that allows/disallows handling of remote log requests through this logger
            </summary>
        </member>
        <member name="P:LogUtils.Logger.AllowRegistration">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Logger.Targets">
            <summary>
            Contains all assigned log targets
            </summary>
        </member>
        <member name="P:LogUtils.Logger.LogTargets">
            <summary>
            Contains a list of LogIDs (both local and remote) that will be handled in the case of an untargeted log request
            </summary>
        </member>
        <member name="P:LogUtils.Logger.ConsoleTargets">
            <summary>
            Contains a list of ConsoleIDs that will be handled by any log request that can be handled by this logger
            </summary>
        </member>
        <member name="P:LogUtils.Logger.LogSource">
            <summary>
            A log source that will be applied by default to log requests that require such information
            </summary>
        </member>
        <member name="F:LogUtils.Logger.IsThreadSafe">
            <summary>
            A flag that indicates whether this logger should take a conservative approach to thread safety when handling new log requests
            </summary>
        </member>
        <member name="F:LogUtils.Logger.RestorePoint">
            <summary>
            Contains a record of logger field values that can be restored on demand
            </summary>
        </member>
        <member name="F:LogUtils.Logger.Writer">
            <summary>
            Writer implementation (responsible for writing to file, or storing messages in the message buffer)
            </summary>
        </member>
        <member name="M:LogUtils.Logger.#ctor(BepInEx.Logging.ILogSource)">
            <summary>
            Constructs a logger instance
            </summary>
            <param name="logSource">The BepInEx log source (typically a ManualLogsource) to assign to this logger</param>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.Enums.ILogTarget)">
            <summary>
            Constructs a logger instance
            </summary>
            <param name="preset">The LogID, or ConsoleID to target, or handle by request by this logger</param>
        </member>
        <member name="M:LogUtils.Logger.#ctor(System.Boolean,LogUtils.Enums.ILogTarget)">
            <summary>
            Constructs a logger instance
            </summary>
            <param name="allowLogging">Whether logger accepts logs by default, or has to be enabled first</param>
            <param name="preset">The LogID, or ConsoleID to target, or handle by request by this logger</param>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget)">
            <summary>
            Constructs a logger instance
            </summary>
            <param name="mode">Changes the technique used to write messages to file</param>
            <param name="preset">The LogID, or ConsoleID to target, or handle by request by this logger</param>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.Enums.ILogTarget[])">
            <summary>
            Constructs a logger instance
            </summary>
            <param name="presets">Include any LogIDs, or ConsoleIDs that this logger targets, or handles on request</param>
        </member>
        <member name="M:LogUtils.Logger.#ctor(System.Boolean,LogUtils.Enums.ILogTarget[])">
            <summary>
            Constructs a logger instance
            </summary>
            <param name="allowLogging">Whether logger accepts logs by default, or has to be enabled first</param>
            <param name="presets">Include any LogIDs, or ConsoleIDs that this logger targets, or handles on request</param>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget[])">
            <summary>
            Constructs a logger instance
            </summary>
            <param name="mode">Changes the technique used to write messages to file</param>
            <param name="presets">Include any LogIDs, or ConsoleIDs that this logger targets, or handles on request</param>
        </member>
        <member name="M:LogUtils.Logger.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget[])">
            <summary>
            Constructs a logger instance
            </summary>
            <param name="mode">Changes the technique used to write messages to file</param>
            <param name="allowLogging">Whether logger accepts logs by default, or has to be enabled first</param>
            <param name="presets">Include any LogIDs, or ConsoleIDs that this logger targets, or handles on request</param>
        </member>
        <member name="M:LogUtils.Logger.LogUnresolvedTarget(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.Boolean,LogUtils.Requests.LogRequest.Factory.Callback)">
            <summary>
            Log targets that may be composite need to be resolved before logging can occur
            </summary>
        </member>
        <member name="M:LogUtils.Logger.LogUnresolvedTarget(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.Boolean,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Logger.LogUnresolvedTarget(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.Boolean,LogUtils.Requests.LogRequest.Factory.Callback)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBase(LogUtils.Requests.LogRequest)">
            <summary>
            Passes a log request to a writer, or request handler
            </summary>
            <remarks>Through normal code paths, this code may receive already submitted requests, but these requests should always be local</remarks>
        </member>
        <member name="M:LogUtils.Logger.CanHandle(LogUtils.Enums.LogID,LogUtils.Requests.RequestType)">
            <summary>
            Determines if the specified LogID can be handled by this logger with the specified RequestType
            </summary>
        </member>
        <member name="M:LogUtils.Logger.HandleRequest(LogUtils.Requests.LogRequest)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Logger.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.Logger.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.Logger"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.Logger.Dispose">
            <inheritdoc cref="M:LogUtils.Logger.Dispose(System.Boolean)"/>
        </member>
        <member name="M:LogUtils.Logger.Finalize">
            <summary/>
        </member>
        <member name="T:LogUtils.Logger.LogRestorePoint">
            <summary>
            A snapshot of the logger's state at a certain point in time
            </summary>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.String,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.String,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.String,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.String,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(UnityEngine.LogType,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.String,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(UnityEngine.LogType,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.String,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogBepEx(LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogUnity(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogExp(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogJolly(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.String,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.String,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(LogUtils.Enums.ILogTarget,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,System.String,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},BepInEx.Logging.LogLevel,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.String,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,System.ConsoleColor)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Logger.ProcessBatch(LogUtils.Requests.LogRequest)">
            <summary>
            Processes and logs a previously initiated batch of log reqeusts
            </summary>
        </member>
        <member name="F:LogUtils.Logger.LogProcessor._logHandler">
            <summary>
            The handler that is responsible for handling processed log requests
            </summary>
        </member>
        <member name="M:LogUtils.Logger.OnRegister">
            <summary>
            Event is invoked when the logger is registered
            </summary>
        </member>
        <member name="M:LogUtils.Logger.OnUnregister">
            <summary>
            Event is invoked when the logger becomes unregistered
            </summary>
        </member>
        <member name="M:LogUtils.Logger.OnNewRequest(LogUtils.Requests.LogRequest)">
            <summary>
            Event is invoked each time a LogRequest is submitted by the current logger
            </summary>
        </member>
        <member name="T:LogUtils.Console.AnsiColorConverter">
            <summary>
            This class converts color information into an ANSI color code
            </summary>
        </member>
        <member name="F:LogUtils.Console.AnsiColorConverter.ANSI_TERMINATOR_CHAR">
            <summary>
            The presence of this char indicates an ANSI color code has terminated
            </summary>
        </member>
        <member name="F:LogUtils.Console.AnsiColorConverter.ANSI_ESCAPE_CHAR">
            <summary>
            Escape character for an ANSI color code
            </summary>
        </member>
        <member name="M:LogUtils.Console.AnsiColorConverter.ApplyFormat(System.String,UnityEngine.Color)">
            <summary>
            Surrounds a message with ANSI codes necessary to display the message in the console with a specified color, and reset back to the default color at the end of the message
            </summary>
        </member>
        <member name="M:LogUtils.Console.AnsiColorConverter.AnsiToForeground(UnityEngine.Color)">
            <summary>
            Converts a UnityEngine.Color to an ANSI escape code for foreground color.
            </summary>
        </member>
        <member name="M:LogUtils.Console.AnsiColorConverter.AnsiBackground(UnityEngine.Color)">
            <summary>
            Converts a UnityEngine.Color to an ANSI escape code for background color.
            </summary>
        </member>
        <member name="F:LogUtils.Console.AnsiColorConverter.AnsiReset">
            <summary>
            ANSI reset code to restore default console color.
            </summary>
        </member>
        <member name="T:LogUtils.Console.ConsoleColorMap">
            <summary>
            This class provides helper methods for converting ConsoleColor enums to their corresponding Unity color, and vice versa
            </summary>
        </member>
        <member name="F:LogUtils.Console.ConsoleColorMap.DefaultConsoleColor">
            <summary>
            The primary color used for text in the console
            </summary>
        </member>
        <member name="P:LogUtils.Console.ConsoleColorMap.DefaultColor">
            <summary>
            The primary color used for text in the console
            </summary>
        </member>
        <member name="F:LogUtils.Console.ConsoleColorMap.ColorMap">
            <summary>
            A map of ConsoleColor values to their associated Unity color
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.GetColor(System.ConsoleColor)">
            <summary>
            Gets the Unity color mapped to a specified ConsoleColor code
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.GetColor(LogUtils.Enums.LogGroup)">
            <summary>
            Gets the Unity color mapped to a specified LogGroup
            </summary>
            <remarks>Aligned with the colors assigned for BepInEx.LogLevel</remarks>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.GetConsoleColor(LogUtils.Enums.LogGroup)">
            <summary>
            Gets the ConsoleColor mapped to a specified LogGroup
            </summary>
            <remarks>Aligned with the colors assigned for BepInEx.LogLevel</remarks>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(UnityEngine.Color)">
            <summary>
            Finds the nearest compatible ConsoleColor for the given color
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(System.Drawing.Color)">
            <inheritdoc cref="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(UnityEngine.Color)"/>
        </member>
        <member name="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(System.Byte,System.Byte,System.Byte)">
            <inheritdoc cref="M:LogUtils.Console.ConsoleColorMap.ClosestConsoleColor(UnityEngine.Color)"/>
        </member>
        <member name="P:LogUtils.Console.ConsoleLogWriter.Formatter">
            <summary>
            Applies text-based message format changes
            </summary>
        </member>
        <member name="F:LogUtils.Console.ConsoleLogWriter.Rules">
            <summary>
            Collection of associated message format rules
            </summary>
        </member>
        <member name="P:LogUtils.Console.ConsoleLogWriter.Stream">
            <summary>
            The active write stream for writers that use one
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.ApplyRules(LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.AssignStreamWriter">
            <summary>
            Gets a valid stream writer instance
            </summary>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.SendToBuffer(LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.WriteFrom(LogUtils.Requests.LogRequest)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Console.ConsoleLogWriter.WriteFromBuffer(LogUtils.Enums.LogID,System.TimeSpan,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Console.LogConsole">
            <summary>
            This class is responsible for accessing the BepInEx console
            </summary>
        </member>
        <member name="F:LogUtils.Console.LogConsole.ANSIColorSupport">
            <summary>
            Indicates whether the host machine supports ANSI color codes
            </summary>
        </member>
        <member name="F:LogUtils.Console.LogConsole.WriteLock">
            <summary>
            This lock is used for interacting with BepInEx log console
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.FindWriter(LogUtils.Enums.ConsoleID,System.Boolean)">
            <summary>
            Finds the writer associated with a given ConsoleID
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.FindWriters(System.Collections.Generic.IEnumerable{LogUtils.Enums.ConsoleID},System.Boolean)">
            <summary>
            Finds all writers associated with the given ConsoleIDs
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.AddWriter(LogUtils.Console.ConsoleLogWriter)">
            <summary>
            Registers a <see cref="T:LogUtils.Console.ConsoleLogWriter"/> instance
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.SetConsoleColor(System.ConsoleColor)">
            <summary>
            Fallback method for adjusting text color in the console
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.SetEnabledState(System.Boolean)">
            <summary>
            Sets the enabled state for the BepInEx console (when it is supported) 
            </summary>
        </member>
        <member name="M:LogUtils.Console.LogConsole.WriteLine(LogUtils.Enums.LogCategory,System.String)">
            <summary>
            Writes a message to the BepInEx console (when enabled)
            </summary>
            <param name="category">The category associated with the message</param>
            <param name="message">The message to write</param>
        </member>
        <member name="M:LogUtils.Console.LogConsole.WriteLine(System.String)">
            <inheritdoc cref="M:LogUtils.Console.LogConsole.WriteLine(LogUtils.Enums.LogCategory,System.String)"/>
        </member>
        <member name="T:LogUtils.Diagnostics.AssertHandler">
            <summary>
            This type defines behavior for handling assert results 
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.AssertHandler.Default">
            <summary>
            Default assert handling implementation
            </summary>
            <remarks>Possible to customize</remarks>
        </member>
        <member name="P:LogUtils.Diagnostics.AssertHandler.IsEnabled">
            <summary/>
        </member>
        <member name="M:LogUtils.Diagnostics.AssertHandler.Handle(LogUtils.Diagnostics.Condition.Result)">
            <summary>
            Process a condition result
            </summary>
            <param name="result">The result to evaluate</param>
            <exception cref="T:UnityEngine.Assertions.AssertionException">Throws when AssertBehavior.Throw is set, and assert fails</exception>
        </member>
        <member name="M:LogUtils.Diagnostics.AssertHandler.Clone">
            <summary>
            Creates a shallow copy of this instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.AssertHandler.Clone(LogUtils.Diagnostics.AssertBehavior)">
            <summary>
            Creates a shallow copy of this instance with the provided behavior
            </summary>
            <param name="behavior"></param>
            <returns></returns>
        </member>
        <member name="F:LogUtils.Diagnostics.AssertHandler.MessageFormatter.FailResponse">
            <summary>
            The message that appears by default when an assert fails
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.AssertHandler.MessageFormatter.PassResponse">
            <summary>
            The message that appears by default when an assert passes (and pass state is allowed to be reported)
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.AssertBehavior">
            <summary>
            The activity that occurs on an assert result
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Assert">
            <summary>
            This class provides methods for making assert statements
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,System.Func{``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,System.Func{``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,``0,System.Func{``0,``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,``0,System.Func{``0,``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},System.Delegate,LogUtils.Diagnostics.Assert.EvaluationCriteria,System.Object[])">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},System.Delegate,LogUtils.Diagnostics.Assert.EvaluationCriteria,System.Object[])"/>
        </member>
        <member name="T:LogUtils.Diagnostics.Assert.EvaluationCriteria">
            <summary>
            Represents the expected condition state
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(``0)">
            <summary>
            Creates a structure for asserting the state of a specified value
            </summary>
            <param name="value">Value to be used as an assert target</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0)"/>
            <param name="value">Value to be used as an assert target</param>
            <param name="behavior">Represents options for handling assert behavior</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0)"/>
            <param name="value">Value to be used as an assert target</param>
            <param name="handler">The exclusive handler to receive the assert result</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(System.Nullable{``0},LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.AssertBehavior)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.That``1(System.Nullable{``0},LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Assert.That``1(``0,LogUtils.Diagnostics.IConditionHandler)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsFalse(LogUtils.Diagnostics.Condition{System.Boolean})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsFalse(LogUtils.Diagnostics.Condition{System.Boolean})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsFalse(LogUtils.Diagnostics.Condition{System.Nullable{System.Boolean}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsFalse(LogUtils.Diagnostics.Condition{System.Boolean})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsTrue(LogUtils.Diagnostics.Condition{System.Boolean})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsTrue(LogUtils.Diagnostics.Condition{System.Boolean})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsTrue(LogUtils.Diagnostics.Condition{System.Nullable{System.Boolean}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsTrue(LogUtils.Diagnostics.Condition{System.Boolean})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.ICollection{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IList{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.List{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.HasItems``1(LogUtils.Diagnostics.Condition{``0[]})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.ICollection{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IList{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.List{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{``0[]})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEqualTo``1(LogUtils.Diagnostics.Condition{System.IComparable{``0}},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{System.IComparable{``0}},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.SByte},System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.SByte},System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.SByte},System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.SByte},System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.SByte},System.SByte,System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Byte},System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Byte},System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Byte},System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Byte},System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Byte},System.Byte,System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int16},System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int16},System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int16},System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int16},System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Int16},System.Int16,System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.UInt16},System.UInt16,System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.UInt32},System.UInt32,System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int64},System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int64},System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int64},System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int64},System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Int64},System.Int64,System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.UInt64},System.UInt64,System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Single},System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Single},System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Single},System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Single},System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Single},System.Single,System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Double},System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Double},System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Double},System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Double},System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Double},System.Double,System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Decimal},System.Decimal,System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}},System.SByte,System.SByte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.SByte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}},System.Byte,System.Byte)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Byte}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}},System.Int16,System.Int16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}},System.UInt16,System.UInt16)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt16}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}},System.Int32,System.Int32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}},System.UInt32,System.UInt32)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt32}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}},System.Int64,System.Int64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Int64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}},System.UInt64,System.UInt64)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.UInt64}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}},System.Single,System.Single)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Single}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}},System.Double,System.Double)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Double}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsBetween(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}},System.Decimal,System.Decimal)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNegative(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositive(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Nullable{System.Decimal}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.SByte},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.SByte},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.SByte},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.SByte},System.Nullable{System.SByte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Byte},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Byte},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Byte},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Byte},System.Nullable{System.Byte})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int16},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int16},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int16},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int16},System.Nullable{System.Int16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt16},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt16},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt16},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt16},System.Nullable{System.UInt16})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Nullable{System.Int32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int64},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int64},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int64},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int64},System.Nullable{System.Int64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.UInt64},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt64},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.UInt64},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.UInt64},System.Nullable{System.UInt64})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Double},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Double},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Double},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Double},System.Nullable{System.Double})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Decimal},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Decimal},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThan(LogUtils.Diagnostics.Condition{System.Decimal},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Decimal},System.Nullable{System.Decimal})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}},System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEqualTo``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}},System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotNull``1(LogUtils.Diagnostics.Condition{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotNull``1(LogUtils.Diagnostics.Condition{``0})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotNull``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotNull``1(LogUtils.Diagnostics.Condition{``0})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNotThisInstance``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotThisInstance``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNull``1(LogUtils.Diagnostics.Condition{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNull``1(LogUtils.Diagnostics.Condition{``0})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsNull``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNull``1(LogUtils.Diagnostics.Condition{``0})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsSameInstance``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsSameInstance``1(LogUtils.Diagnostics.Condition{``0},``0)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.IsEmpty(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.IsEmpty(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.Contains(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.Contains(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.ContainsOnly(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.ContainsOnly(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Assert.DoesNotContain(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.DoesNotContain(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="T:LogUtils.Diagnostics.Extensions.Assert">
            <summary>
            This class provides methods for making assert statements to additional types
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsGreaterThan``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsGreaterThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsLessThan``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsLessThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.Assert.IsBetween``1(LogUtils.Diagnostics.Condition{``0},``0,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThan``1(LogUtils.Diagnostics.Condition{``0}@,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0}@,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThan``1(LogUtils.Diagnostics.Condition{``0}@,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0}@,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeBetween``1(LogUtils.Diagnostics.Condition{``0}@,``0,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeZero``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustNotBeZero``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeNegative``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBePositive``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBePositiveOrZero``1(LogUtils.Diagnostics.Condition{``0}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThan``1(LogUtils.Diagnostics.Condition{``0}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThan``1(LogUtils.Diagnostics.Condition{``0}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThanOrEqualTo``1(LogUtils.Diagnostics.Condition{``0}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThan``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeGreaterThanOrEqualTo``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThan``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeLessThanOrEqualTo``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,System.Nullable{``0})">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeBetween``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@,``0,``0)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeZero``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustNotBeZero``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBeNegative``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBePositive``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="M:LogUtils.Diagnostics.Extensions.AssertHelper.MustBePositiveOrZero``1(LogUtils.Diagnostics.Condition{System.Nullable{``0}}@)">
            <inheritdoc cref="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})"/>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition`1.Value">
            <summary>
            Contains the state of the condition to evaluate
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition`1.Result">
            <summary>
            The pass/fail state of the condition
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Condition`1.ShouldProcess">
            <summary>
            Indicates whether more processing is necessary to produce a condition result
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition`1.ExpectPass">
            <summary>
            Indicates that the result should expicitly indicate the expected, or unexpected state, assuming passing as the expected state
            </summary>
            <remarks>Only effective when you use a handler that defers result processing such as DeferredAssertHandler</remarks>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition`1.ExpectFail">
            <summary>
            Indicates that the result should expicitly indicate the expected, or unexpected state, assuming failing as the expected state
            </summary>
            <remarks>Only effective when you use a handler that defers result processing such as DeferredAssertHandler</remarks>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean)">
            <summary>
            Asserts that the input value is true
            </summary>
            <remarks>Default handle behavior is to log a message when the asserted value is not true</remarks>
            <param name="condition">The condition to evaluate</param>
            <returns>true, when the condition is true, otherwise false</returns>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean,LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean)"/>
            <param name="condition">The condition to evaluate</param>
            <param name="behavior">The expected behavior of the assert</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean,LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.Assert(System.Boolean)"/>
            <param name="condition">The condition to evaluate</param>
            <param name="handler">The exclusive handler to receive the assert result</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean)">
            <summary>
            Asserts that the input value is false
            </summary>
            <remarks>Default handle behavior is to log a message when the asserted value is true</remarks>
            <param name="condition">The condition to evaluate</param>
            <returns>true, when the condition is false, otherwise false</returns>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean,LogUtils.Diagnostics.AssertBehavior)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean)"/>
            <param name="condition">The condition to evaluate</param>
            <param name="behavior">The expected behavior of the assert</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean,LogUtils.Diagnostics.IConditionHandler)">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.AssertFalse(System.Boolean)"/>
            <param name="condition">The condition to evaluate</param>
            <param name="handler">The exclusive handler to receive the assert result</param>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Message.Descriptors">
            <summary>
            When applicable, this contains descriptor terms used to format result messages
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Message.Raw">
            <summary>
            Message with no formatting applied
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Message.Tags">
            <summary>
            A set of strings to be appended to the end of the message for result reports
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Message.#ctor(System.String)">
            <summary>
            Constructs a response message
            </summary>
            <param name="message">The raw unformatted message string</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Message.#ctor(System.String,System.String[])">
            <inheritdoc cref="M:LogUtils.Diagnostics.Condition.Message.#ctor(System.String)"/>
            <param name="message">The raw unformatted message string</param>
            <param name="formatValues">Values to use for formatting the raw string</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Message.SetDescriptors(System.String[],System.Boolean)">
            <summary>
            Replace the current format arguments with a new set of arguments
            </summary>
            <param name="descriptors">The new format arguments</param>
            <param name="throwIfDescriptorCountDoesNotMatch">A flag to remind mod users to update the raw string, before changing the number of format arguments</param>
            <exception cref="T:System.ArgumentException">The argument provided has an improper length</exception>
        </member>
        <member name="P:LogUtils.Diagnostics.Condition.Result.nextID">
            <summary>
            Value to be assigned to the next created Result instance
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Result.ID">
            <summary>
            Value used for identification of the result (non-zero based)
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Condition.Result.IsUnexpected">
            <summary>
            Checks that there is an expected outcome and the result is consistent with that outcome
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Result.Expectation">
            <summary>
            Optional field that can be used to change how a result outcome is interpreted by comparing it to an expected outcome (e.g. fail may not always be treated as a fail)
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Condition.Result.Handlers">
            <summary>
            The handlers responsible for handling the assertion result
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Result.CompileMessageTags">
            <summary>
            Compiles a set of supported tags for the purpose of appending to a condition response message
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Result.PassedWithExpectations">
            <summary>
            Checks that a result is consistent with a set expectation, or if it has passed when none is set
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Result.ToString">
            <summary>
            Gets the result string
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Condition.Result.ResetCount">
            <summary>
            Change the next result ID to zero
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Debug.LogFrameReportThreshold">
            <summary>
            The maximum amount of time (in milliseconds) that a logging thread update can experience without triggering a slow update report message
            Set to 25 by default (time windows shorter than this will be subject to context switching delays)
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Debug.LogRequestInfo(LogUtils.Enums.LogID,System.Collections.Generic.IEnumerable{LogUtils.Requests.LogRequest})">
            <summary>
            Logs requests to file in a report style format
            </summary>
            <param name="reportFile">The log file to write the report to</param>
            <param name="requests">The objects to log</param>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.BeginEnumeration">
            <summary>
            Enumerates through a string provider if available
            </summary>
            <exception cref="T:System.NullReferenceException">Provider is null</exception>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.ResetState">
            <summary>
            Resets state to before enumerating process began
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogCurrent">
            <summary>
            Attempts to log currently provided string
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.LogNext">
            <summary>
            Moves to next provided string, and attempts to log it
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DebugLogger.Dispose">
            <summary>
            Resets enumerator to a default state
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.DeferredAssertHandler.Current">
            <summary>
            Peeks at the current result in the result queue
            </summary>
            <exception cref="T:System.InvalidOperationException">The result queue is empty</exception>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.Handle(LogUtils.Diagnostics.Condition.Result)">
            <summary>
            Enqueues the result in a result queue for future handling
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.HandleAll">
            <summary>
            Handles all results
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.HandleAll(LogUtils.Diagnostics.DeferredAssertHandler.HandleCondition)">
            <summary>
            Handles all results
            </summary>
            <remarks>When delegate returns true, result is handled normally, when false result is discarded</remarks>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.HandleCurrent">
            <summary>
            Handles the currently enumerated result
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.DeferredAssertHandler.HandleCurrent(LogUtils.Diagnostics.DeferredAssertHandler.HandleCondition)">
            <summary>
            Handles the currently enumerated result
            </summary>
            <remarks>When delegate returns true, result is handled normally, when false result is discarded</remarks>
        </member>
        <member name="P:LogUtils.Diagnostics.IConditionHandler.IsEnabled">
            <summary>
            Determines whether result should be handled or ignored
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.IConditionHandler.Handle(LogUtils.Diagnostics.Condition.Result)">
            <summary>
            Apply post-processing logic to a condition result
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.LogPropertyFactory.Create(System.String,System.Boolean)">
            <summary>
            Create an instance of a LogProperties for testing purposes
            </summary>
            <param name="path">The path to use for the instance</param>
            <param name="register">Whether or not instance should be added to the PropertyDataController</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.LogPropertyFactory.Create(System.String,System.Boolean,System.Boolean)">
            <summary>
            Create an instance of a LogProperties for testing purposes
            </summary>
            <param name="path">The path to use for the instance</param>
            <param name="advanceEnumeration">Affects whether a new string is provided, or the latest one</param>
            <param name="register">Whether or not instance should be added to the PropertyDataController</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.LogPropertyFactory.Dispose">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.Diagnostics.Tests.Components.LogPropertyFactory"/>
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.Components.TestEnum">
            <summary>
            A bare-structured implementation of a SharedExtEnum
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Components.TestLogID.CycleAccess">
            <summary>
            Cycle to the next LogAccess enum value
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.ITestable">
            <summary>
            Simple interface to make an object compatible with a TestSuite instance
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.ITestable.Name">
            <summary>
            A descriptive name for the test
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.ITestable.Test">
            <summary>
            Processes test logic, and assertions
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.PostTestAttribute">
            <summary>
            Identifies a method that should be run after testing
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.PreTestAttribute">
            <summary>
            Identifies a method that should be run before testing
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestCase.Group">
            <summary>
            The group that this test case belongs to
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestCase.GroupState">
            <summary>
            A shared state that applies to the top level test case and all of its children
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestCase.IsEnabled">
            <summary/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCase.AssertThat``1(``0)">
            <summary>
            Creates a structure for asserting the state of a specified value
            </summary>
            <param name="value">Value to be used as an assert target</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCase.AssertThat``1(System.Nullable{``0})">
            <summary>
            Creates a structure for asserting the state of a specified value
            </summary>
            <param name="value">Value to be used as an assert target</param>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCase.Dispose">
            <summary>
            Selects a new test case from the parent group
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCase.HasFailed">
            <summary>
            Checks that the test case has a failed outcome
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.TestCase.SharedState">
            <summary>
            State that is capable of being shared between two or more test case instances
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestCase.SharedState.InheritFromTestSuite">
            <summary>
            Should the state of the TestSuit affect the state of this instance
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestCase.SharedState.PropagateToChildren">
            <summary>
            Should children be exposed to this state, or only the most top level instance
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestCaseGroup.AllResults">
            <summary>
            Gets the test results for the test case and any children cases starting with the test group
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestCaseGroup.Count">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCaseGroup.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestCaseGroup.HasFailed">
            <summary>
            Checks that any test cases under the group have failed outcomes, as well as its own asserts
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.TestSuite">
            <summary>
            Simple utility object for storing and running tests
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestSuite.ActiveSuite">
            <summary>
            This is set during the process when tests are being run through a TestSuite instance
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestSuite.Handler">
            <summary>
            The handler to be used for all tests run through this test suite (null by default)
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestSuite.Capacity">
            <summary>
            The size of the inner collection
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tests.TestSuite.Size">
            <summary>
            The current number of collection entries
            </summary>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestSuite.Count">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Diagnostics.Tests.TestSuite.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.#ctor">
            <summary>
            Constructs a new TestSuite instance
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.#ctor(System.Int32)">
            <summary>
            Constructs a new TestSuite instance with a specified default capacity
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.AddTests(System.Reflection.Assembly)">
            <summary>
            Searches for all implementors of the ITestable interface in a given assembly, and adds an instance of the type to the test suite 
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Add(LogUtils.Diagnostics.Tests.ITestable)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Clear">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Contains(LogUtils.Diagnostics.Tests.ITestable)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.CopyTo(LogUtils.Diagnostics.Tests.ITestable[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Remove(LogUtils.Diagnostics.Tests.ITestable)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{LogUtils.Diagnostics.Tests.ITestable})">
            <summary>
            Sorts the elements in a range of elements in an System.Array using the specified IComparer generic interface
            </summary>
            <param name="index">The starting index of the range to sort</param>
            <param name="count">The amount of elements in the range to sort</param>
            <param name="comparer">The IComparer to use</param>
            <exception cref="T:System.ArgumentNullException">Provided comparer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is less than the lower bound of array. -or- count is less than zero.</exception>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.TestSuite.RunTests(System.Func{LogUtils.Diagnostics.Tests.ITestable,System.Boolean})">
            <summary>
            Run tests that match a specific predicate
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.AssertTests.testCollectionDetection">
            <summary>
            Demonstrate the ways collection specific asserts are accessed
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.Utility.AssertTests.CustomCollection">
            <summary>
            Empty class used to test detection of custom collections
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.ExtEnumTests.clearSharedData">
            <summary>
            This should be called after each test that sets shared data to ensure that state transfer isn't a factor in between tests
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tests.Utility.LogCategoryTests.TransferMode">
            <summary>
            TransferMode is primarily useful for checking that registration status propagates correctly to all instances
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.LogConsoleTests.TestColors">
            <summary>
            Sends color debug information to the console
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tests.Utility.LoggerTests.testConflictResolution">
            <summary>
            Tests related to ensuring that LogIDs with equivalent filename, but different paths make it to the correct Logger instances
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.AverageLogRate">
            <summary>
            The average window of time in between write requests
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.SampleFrequency">
            <summary>
            The polling frequency represented as the number of samples required to collect a new sample 
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.LogRateThreshold">
            <summary>
            The minimum rate between received messages considered to be normal, (or perhaps above normal, but not high volume). The value 2.5f represents 1/10th the length of
            a typical RainWorld frame at 40 FPS (25 ms / 10). Values less than this value are considered to be high volume.
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.HighVolumeSustainmentThreshold">
            <summary>
            The amount of consecutive sampling periods exceeding the allowable average rate (of logged messages) allowed before triggering the message buffer
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.PeriodsUnderHighVolume">
            <summary>
            The current amount of consecutive sampling periods exceeding the allowable average rate (of logged messages)
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.LogProfiler.LogRateDecay">
            <summary>
            Average is multiplied by this amount for each period there are no new messages to sample
            </summary>
        </member>
        <member name="T:LogUtils.Diagnostics.Tools.NullChecker">
            <summary>
            A simple struct that helps with identifying sources of null data
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.NullChecker.NullIndex">
            <summary>
            This number represents the item count position of the latest value to be confirmed as null
            </summary>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.NullChecker.DetectionThreshold">
            <summary>
            Allows a limit to be set on null matches detected. Useful for detecting nulls in an object reference chain.
            </summary>
            <remarks>Example: obj.FieldA.FieldB
            <br></br>
            <br>Make sure that you null check each potential null, before trying to pass it into the NullChecker.</br>
            The null-condition operator (?) can be used to make this easier.</remarks>
        </member>
        <member name="M:LogUtils.Diagnostics.Tools.NullChecker.Check(System.Object,System.String)">
            <summary>
            Performs a null check on an object. Resulting feedback is then stored as field data
            </summary>
            <param name="obj">Object to evaluate</param>
            <param name="callerArgumentName">The name of the reference. Leave blank to autocapture argument</param>
        </member>
        <member name="F:LogUtils.Diagnostics.Tools.TestStringProvider.Template">
            <summary>
            The base log string to enumerate on
            </summary>
        </member>
        <member name="M:LogUtils.Diagnostics.Tools.TestStringProvider.StringFactory.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.DirectToFileLogger.Delete">
            <summary>
            Attempts to delete the debug log for the current Rain World process
            </summary>
        </member>
        <member name="M:LogUtils.DirectToFileLogger.DeleteAll">
            <summary>
            Attempts to cleanup stray debug logs that were created by LogUtils belonging to different Rain World processes
            </summary>
        </member>
        <member name="T:LogUtils.DiscreteLogger">
            <summary>
            A logger instance designed to be isolated from remote requests by default
            </summary>
        </member>
        <member name="P:LogUtils.DiscreteLogger.AllowRemoteLogging">
            <inheritdoc/>
            <value>Always returns false</value>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(LogUtils.Enums.ILogTarget[])">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(LogUtils.LoggingMode,LogUtils.Enums.ILogTarget[])">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.DiscreteLogger.#ctor(LogUtils.LoggingMode,System.Boolean,LogUtils.Enums.ILogTarget[])">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,System.Func{``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)">
            <summary>
            Asserts a condition by invoking a delegate using specified values as arguments
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="conditionArg">Condition argument for delegate</param>
            <param name="conditionDelegate">Callback that checks the condition state</param>
            <param name="criteria">The expected state of the condition</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},``0,``0,System.Func{``0,``0,System.Boolean},LogUtils.Diagnostics.Assert.EvaluationCriteria)">
            <summary>
            Asserts a condition by invoking a delegate using specified values as arguments
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="firstArg">First condition argument</param>
            <param name="secondArg">Second condition argument</param>
            <param name="conditionDelegate">Callback that checks the condition state</param>
            <param name="criteria">The expected state of the condition</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.GeneralAssert.EvaluateCondition``1(LogUtils.Diagnostics.Condition{``0},System.Delegate,LogUtils.Diagnostics.Assert.EvaluationCriteria,System.Object[])">
            <summary>
            Asserts a condition by dynamically invoking a delegate
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="dynamicCondition">Delegate that evaluates a condition (must return true or false)</param>
            <param name="criteria">The expected state of the condition</param>
            <param name="dynamicParams">Parameters for evaluating a condition</param>
            <exception cref="T:System.MemberAccessException">
               The caller does not have access to the method represented by the delegate (for
               example, if the method is private). -or- The number, order, or type of parameters
               listed in args is invalid.</exception>
            <exception cref="T:System.ArgumentException">
                The method represented by the delegate is invoked on an object or a class that
                does not support it.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">
                The method represented by the delegate is an instance method and the target object
                is null. -or- One of the encapsulated methods throws an exception.</exception>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsFalse(LogUtils.Diagnostics.Condition{System.Boolean})">
            <summary>
            Asserts that target value must be false
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.BooleanAssert.IsTrue(LogUtils.Diagnostics.Condition{System.Boolean})">
            <summary>
            Asserts that target value must be true
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.DoesNotEqual``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <summary>
            Asserts that the target value must be not equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareObject">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <summary>
            Asserts that the target value must be equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareObject">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotNull``1(LogUtils.Diagnostics.Condition{``0})">
            <summary>
            Asserts that the target value must not be null
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNotThisInstance``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <summary>
            Asserts that the target object refers to a different object than a specified object
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareObject">The object to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsNull``1(LogUtils.Diagnostics.Condition{``0})">
            <summary>
            Asserts that the target value must be null
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.ObjectAssert.IsSameInstance``1(LogUtils.Diagnostics.Condition{``0},``0)">
            <summary>
            Asserts that the target object refers to the same object as a specified object
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareObject">The object to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.HasItems``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Asserts that the target collection must have at least one entry
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.CollectionAssert.IsNullOrEmpty``1(LogUtils.Diagnostics.Condition{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Asserts that the target collection must be null or empty
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsEqualTo``1(LogUtils.Diagnostics.Condition{System.IComparable{``0}},``0)">
            <summary>
            Asserts that the target value must be equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <summary>
            Asserts that the target value must be greater than a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsGreaterThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <summary>
            Asserts that the target value must be greater than or equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThan(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <summary>
            Asserts that the target value must be less than a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsLessThanOrEqualTo(LogUtils.Diagnostics.Condition{System.Int32},System.Int32)">
            <summary>
            Asserts that the target value must be less than or equal to a specified value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="compareValue">The value to compare to</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsBetween(LogUtils.Diagnostics.Condition{System.Int32},System.Int32,System.Int32)">
            <summary>
            Asserts that the target value must be in a given interval
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="minimum">The lower bound</param>
            <param name="maximum">The upper bound</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must be equal to zero
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNotZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must not be equal to zero
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsNegative(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must be negative
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositive(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must be positive
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.NumericAssert.IsPositiveOrZero(LogUtils.Diagnostics.Condition{System.Int32})">
            <summary>
            Asserts that the target value must not be negative
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.IsEmpty(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory})">
            <summary>
            Asserts that the target value's IsEmpty property is set to true
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.Contains(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <summary>
            Asserts that the target value contains a given value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="flag">The flag value to evaluate</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.ContainsOnly(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <summary>
            Asserts that the target value only contains a given value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="flag">The flag value to evaluate</param>
        </member>
        <member name="M:LogUtils.Documentation.AssertDocumentation.OtherAssert.DoesNotContain(LogUtils.Diagnostics.Condition{LogUtils.Enums.CompositeLogCategory},LogUtils.Enums.LogCategory)">
            <summary>
            Asserts that the target value does not contain a given value
            </summary>
            <param name="condition">The data structure that checks and evaluates a result</param>
            <param name="flag">The flag value to evaluate</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)">
            <summary>
            Formats and writes a log message
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)">
            <summary>
            Formats and writes a log message
            </summary>
            <remarks>Accepts multiple targets through the use of bitflag operators (to combine multiple log targets into one)</remarks>
            <param name="target">The specified log file, or console identifier to target</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <summary>
            Formats and writes a log message to multiple log targets
            </summary>
            <param name="targets">The specified log file, or console identifiers to target</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)">
            <summary>
            Formats and writes a log message with a debug context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)">
            <summary>
            Formats and writes a log message with an informational context (typically the default context)
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)">
            <summary>
            Formats and writes a log message with an important context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)">
            <summary>
            Formats and writes a log message with a message context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)">
            <summary>
            Formats and writes a log message with a warning context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)">
            <summary>
            Formats and writes a log message with an error context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)">
            <summary>
            Formats and writes a log message with a fatal context
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)">
            <summary>
            Formats and writes a log message only once
            </summary>
            <remarks>Prevents logging a message more than once</remarks>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message only once with a specified logging context
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)">
            <summary>
            Formats and writes a log message only once
            </summary>
            <remarks>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <para>
            Accepts multiple targets through the use of bitflag operators (to combine multiple log targets into one) <br/>
            When multiple targets are selected, it will log once to each specific target </para>
            </remarks>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message only once with a specified logging context
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)" select="param, remarks"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)">
            <summary>
            Formats and writes a log message to multiple log targets only once
            </summary>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)" select="remarks"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
            <param name="messageColor">The text color to apply to a message</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)"/>
            <param name="target">The specified log file, or console identifier to target</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
            <param name="messageColor">The text color to apply to a message</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <param name="targets">The specified log file, or console identifiers to target</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
            <param name="messageColor">The text color to apply to a message</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogOnce(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget},LogUtils.Enums.LogCategory,System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)">
            <summary>
            Formats and writes a log message to BepInEx
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)">
            <summary>
            Formats and writes a log message to BepInEx with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)">
            <summary>
            Formats and writes a log message to BepInEx with a specified logging context, and logging source
            </summary>
            <param name="source">The source of the logged message (usually a ManualLogSource in a modding context)</param>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.Object)">
            <summary>
            Formats and writes a log message to BepInEx
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)">
            <summary>
            Formats and writes a log message to Unity with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.Object)">
            <summary>
            Formats and writes a log message to Expedition
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message to Expedition with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.Object)">
            <summary>
            Formats and writes a log message to JollyCoop
            </summary>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.Object)">
            <summary>
            Formats and writes a log message to JollyCoop with a specified logging context
            </summary>
            <param name="category">The specified logging context</param>
            <param name="messageObj">The object you want to log (string, interpolated string, object, etc.)</param>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.LogLevel,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object,UnityEngine.Color)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)"/>
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object,UnityEngine.Color)" select="param"/>
        </member>
        <member name="T:LogUtils.Enums.ComparisonLogID">
            <summary>
            A type of LogID designed for comparisons. Not to be used for logging purposes
            </summary>
        </member>
        <member name="M:LogUtils.Enums.ComparisonLogID.#ctor(System.String,System.String)">
            <summary>
            Constructs a lightweight version of a LogID intended for local comparisons rather than logging
            </summary>
            <remarks>This type of LogID is not registered by default, and does not have its own properties (unless an existing LogID already has properties)</remarks>
        </member>
        <member name="T:LogUtils.Enums.CompositeLogCategory">
            <summary>
            A type of LogCategory featuring properties of enum bitflags
            </summary>
            <remarks>LogCategory instances can be combined using overloaded bitflag operators to create a composite instance</remarks>
        </member>
        <member name="F:LogUtils.Enums.CompositeLogCategory.Set">
            <summary>
            Contains the flags that represent the composite instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogCategory.FlagValue">
            <summary>
            The combined bitflag translation of all contained flags within this instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.Deconstruct">
            <summary>
            Breaks the composite ExtEnum back into its component elements
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.FromFlags(BepInEx.Logging.LogLevel[])">
            <summary>
            Combines any number of enum values into a composite LogCategory
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.FromFlags(UnityEngine.LogType[])">
            <summary>
            Combines any number of enum values into a composite LogCategory
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.GetMostRelevantFlags">
            <summary>
            Finds all flags contained within the most relevant LogGroup for the composite instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.Contains(LogUtils.Enums.LogCategory)">
            <summary>
            Checks whether this instance contains the specified flag element
            </summary>
            <param name="flag">The element to look for</param>
            <returns>true, if the flag element is contained by this instance; otherwise, false</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.Contains(LogUtils.Enums.CompositeLogCategory)">
            <summary>
            Checks whether this instance contains all elements specified within the composite flag
            </summary>
            <param name="flags">Contains a set of flags to look for</param>
            <returns>true, if all flag elements are contained by this instance; otherwise, false</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.HasAll(LogUtils.Enums.CompositeLogCategory)">
            <summary>
            Checks whether this instance contains every element of another compatible composite instance
            </summary>
            <param name="flags">Contains a set of flags to look for</param>
            <returns>true, if all flag elements are contained by this instance; otherwise, false</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.HasAny(LogUtils.Enums.CompositeLogCategory)">
            <summary>
            Checks whether this instance contains any element of another compatible composite instance
            </summary>
            <param name="flags">Contains a set of flags to look for</param>
            <returns>true, if at least one flag element is contained by this instance; otherwise, false</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.HasFlag(LogUtils.Enums.LogCategory,LogUtils.Enums.CompositeLogCategory.FlagSearchOptions)">
            <summary>
            Checks whether this instance contains a flag as a whole value, or elements of the flag based on a specified search behavior 
            </summary>
            <param name="flag">Contains a flag, or set of flags to look for</param>
            <param name="searchOptions">Specifies the search behavior when the flag represents multiple elements, has no effect when there is only one element</param>
            <returns>true, when an element has been matched based on the provided search criteria</returns>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogCategory.ToString">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogTarget.Value">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.CompositeLogTarget.IsEnabled">
            <inheritdoc/>
            <remarks>Composite targets are never available to be handled</remarks>
        </member>
        <member name="F:LogUtils.Enums.CompositeLogTarget.Set">
            <summary>
            Contains the flags that represent the composite instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.CompositeLogTarget.GetRequestType(LogUtils.ILogHandler)">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.ConsoleID.IsEnabled">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Enums.LogCategory.LOG_LEVEL_DEFAULT">
            <summary>
            The default conversion type for LogLevel enum
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogCategory.LOG_TYPE_DEFAULT">
            <summary>
            The default conversion type for LogType enum
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.BepInExCategory">
            <summary>
            The category value translated to the category enum used for BepInEx logging
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.UnityCategory">
            <summary>
            The category value translated to the category enum used for Unity logging
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.FlagValue">
            <summary>
            The bitflag translation representing this LogCategory
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.Group">
            <summary>
            The overall logging group defined for this category - used for tasks such as filtering by one or more categories
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogCategory.ConsoleColor">
            <summary>
            The color that will be used in the console, or other write implementation that supports text coloration  
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.#ctor(System.String,System.Nullable{BepInEx.Logging.LogLevel},System.Nullable{UnityEngine.LogType})">
            <summary>
            Constructs a registered LogCategory instance
            </summary>
            <param name="value">The ExtEnum value associated with this instance</param>
            <param name="bepInExEquivalent">
            The enum value to be used when this category is used by the BepInEx logger
            Set to null assigns a custom LogLevel, otherwise will take the value of the LogLevel provided
            </param>
            <param name="unityEquivalent">
            The enum value to be used when this category is used by the Unity logger
            Set to null assigns a custom LogType, otherwise will take the value of the LogType provided
            </param>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs a LogCategory instance
            </summary>
            <param name="value">The ExtEnum value associated with this instance</param>
            <param name="register">Whether or not this instance should be registered as a unique ExtEnum entry</param>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.Register">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.GetUnityLogID(UnityEngine.LogType)">
            <summary>
            Determines if the logging context is general purpose, or targets an exception
            </summary>
            <returns>The proper LogID for the provided logging context</returns>
        </member>
        <member name="F:LogUtils.Enums.LogCategory.CONVERSION_OFFSET">
            <summary>
            The bit-oriented value position of an enum value (LogLevel or LogType) reserved for custom conversions of LogCategory values
            </summary>
            <remarks>Value must be compliant with BepInEx.LogType, which assigns a max value of 63.
            This value must be at least 64 or greater for compatibility purposes</remarks>
        </member>
        <member name="F:LogUtils.Enums.LogCategory.CONVERSION_OFFSET_POWER">
            <summary>
            The power of two used to produce the conversion offset
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.GetEquivalent(BepInEx.Logging.LogLevel)">
            <summary>
            An internal helper that assumes that composite checks have already been handled, and input is not a composite
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategory.GetEquivalent(UnityEngine.LogType)">
            <summary>
            An internal helper that assumes that composite checks have already been handled, and input is not a composite
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryCombiner.Combine(LogUtils.Enums.LogCategory,LogUtils.Enums.LogCategory)">
            <summary>
            Create a composite object out of two component objects
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryCombiner.extractElements(LogUtils.Enums.LogCategory)">
            <summary>
            Extract the component elements from the provided category
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.ByCategory.IsAllowed(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.ByCategory.CompareTo(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.ByGroup.IsAllowed(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.ByGroup.CompareTo(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.BySpecificGroup.IsAllowed(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogCategoryFilter.BySpecificGroup.CompareTo(LogUtils.Enums.LogCategory)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogGroupMap.GetEquivalent(BepInEx.Logging.LogLevel@,System.Boolean)">
            <summary>
            Implementation doesn't account for composites
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogGroupMap.GetEquivalentSlow(BepInEx.Logging.LogLevel@)">
            <summary>
            Implementation accounts for composites
            </summary>
        </member>
        <member name="T:LogUtils.Enums.LogGroup">
            <summary>
            A slightly modified set of values based on BepInEx.Logging.LogLevel
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogID.Properties">
            <summary>
            Contains path information, and other settings that affect logging behavior 
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogID.Access">
            <summary>
            Acts as a permission flag that affects the behavior of loggers, and the handling of logging requests targeting this LogID
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogID.HasLocalAccess">
            <summary>
            Will this LogID be handled as having a local context when passed to a logger
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogID.IsEnabled">
            <summary>
            Controls whether messages targetting this log file can be handled by a logger
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogID.IsInstanceEnabled">
            <summary>
            A flag that controls whether logging should be permitted for this LogID instance
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogID.IsGameControlled">
            <summary>
            A flag that indicates that this represents an existing game-controlled log file
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(System.String,LogUtils.Enums.LogAccess,System.Boolean)">
            <summary>
            Creates a new LogID instance
            </summary>
            <param name="filename">The filename, and optional path to target and use for logging
            The ExtEnum value will be equivalent to the filename portion of this parameter without the file extension
            A filename without a path will default to StreamingAssets directory as a path unless an existing LogID with the specified filename is already registered
            </param>
            <param name="access">Modifier that affects who may access and use the log file
            Set to LogAccess.RemoteAccessOnly UNLESS your mod intends to handle LogRequests for this LogID
            </param>
            <param name="register">Whether or not this LogID is registered as an ExtEnum
            Registration affects whether a LogID gets its own properties that write to file on game close
            An unregistered LogID will still get its own properties, those properties, and changes to those properties wont be saved to file
            DO NOT register a LogID that is temporary, and your mod is designated for public release
            </param>
            <exception cref="T:System.ArgumentNullException">Filename provided is null</exception>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(System.String)">
            <summary>
            Creates a new LogID instance without attempting to create a LogProperties instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new LogID instance using a filename, and assuming a default/preexisting registered path
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.#ctor(System.String,System.String,LogUtils.Enums.LogAccess,System.Boolean)">
            <summary>
            Creates a new LogID instance
            </summary>
            <param name="filename">The filename to target, and use for logging
            The ExtEnum value will be equivalent to the filename without the file extension
            </param>
            <param name="relativePathNoFile">The path to the log file
            Setting to null will default to the StreamingAssets directory as a path unless an existing LogID with the specified filename is already registered</param>
            <param name="access">Modifier that affects who may access and use the log file
            Set to LogAccess.RemoteAccessOnly UNLESS your mod intends to handle LogRequests for this LogID
            </param>
            <param name="register">Whether or not this LogID is registered as an ExtEnum
            Registration affects whether a LogID gets its own properties that write to file on game close
            An unregistered LogID will still get its own properties, those properties, and changes to those properties wont be saved to file
            DO NOT register a LogID that is temporary, and your mod is designated for public release
            </param>
        </member>
        <member name="M:LogUtils.Enums.LogID.Equals(LogUtils.Enums.LogID,System.Boolean)">
            <summary>
            Determines whether the specified LogID is equal to the current LogID
            </summary>
            <param name="idOther">The LogID to compare with the current LogID</param>
            <param name="doPathCheck">Whether the folder path should also be considered in the equality check</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.Find(System.String,System.String)">
            <summary>
            Finds a registered LogID with the given filename, and path
            </summary>
            <remarks>Compares ID, Filename, and CurrentFilename fields</remarks>
            <param name="filename">The filename to search for</param>
            <param name="relativePathNoFile">The filepath to search for. When set to null, any filename match will be returned with custom root being prioritized</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindAll(System.String)">
            <summary>
            Finds all registered LogID with the given filename
            </summary>
            <remarks>Compares ID, Filename, and CurrentFilename fields</remarks>
            <param name="filename">The filename to search for</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindAll(System.String,LogUtils.Properties.CompareOptions)">
            <summary>
            Finds all registered LogID with the given filename
            </summary>
            <param name="filename">The filename to search for</param>
            <param name="compareOptions">Represents options that determine which fields to check against</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.FindByTag(System.String[])">
            <summary>
            Finds all registered LogIDs with the given tags
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogID.IsRegistered(System.String,System.String)">
            <summary>
            Checks whether file, and path combination matches the file and path information of an existing registered LogID
            </summary>
            <param name="filename">The filename to search for</param>
            <param name="relativePathNoFile">The filepath to search for. When set to null, any filename match will be returned with custom root being prioritized</param>
        </member>
        <member name="M:LogUtils.Enums.LogID.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogID.Sanitize(System.String)">
            <summary>
            Converts a filename input into a LogUtils supported filename
            </summary>
            <exception cref="T:System.ArgumentNullException">Filename provided is null</exception>
        </member>
        <member name="F:LogUtils.Enums.LogID.NotUsed">
            <summary>An unregistered LogID designed to be used as a throwaway parameter</summary>
        </member>
        <member name="T:LogUtils.Enums.LogAccess">
            <summary>
            Logger permission values - Assign to a LogID provided to a logger to influence how messages are logged, and handled by that logger
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogAccess.FullAccess">
            <summary>
            LogID can be handled by either local, or remote loggers
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogAccess.RemoteAccessOnly">
            <summary>
            LogID is only able to be handled as a remote request from one logger to another
            </summary>
        </member>
        <member name="F:LogUtils.Enums.LogAccess.Private">
            <summary>
            LogID can only be handled through a local log request
            </summary>
        </member>
        <member name="T:LogUtils.Enums.ILogTarget">
            <summary>
            Shared by implementations that function as a compatible target by a Logger instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.ILogTarget.Value">
            <summary>
            A value string assigned on construction
            </summary>
        </member>
        <member name="P:LogUtils.Enums.ILogTarget.IsEnabled">
            <summary>
            Indicates whether this target is available to be handled
            </summary>
        </member>
        <member name="M:LogUtils.Enums.ILogTarget.GetRequestType(LogUtils.ILogHandler)">
            <summary>
            The RequestType that should be assigned when this target is ready to be handled
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogTargetCollection.AllTargets">
            <summary>
            Creates an independent collection instances containing the same collection items as this instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.LogTargetCollection.Count">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.#ctor">
            <summary>
            Constructs a new target collection containing no targets
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.#ctor(LogUtils.Enums.CompositeLogTarget)">
            <summary>
            Constructs a new target collection containing the elements of the provided composite object
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.#ctor(System.Collections.Generic.IEnumerable{LogUtils.Enums.ILogTarget})">
            <summary>
            Constructs a new target collection containing the elements of the provided IEnumerable
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.Clear">
            <summary>
            Removes all elements from the collection
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.Contains(LogUtils.Enums.ILogTarget)">
            <summary>
            Checks whether the collection contains a given log target
            </summary>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.LogTargetCollection.Clone">
            <summary>
            Creates a new object that is a member deep copy of this instance
            </summary>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.Index">
            <summary>
            Index position in values.entries list for this ExtEnum entry
            </summary>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.BaseIndex">
            <summary>
            The underlying ExtEnum value index (used during the registration process when values are being synced)
            </summary>
        </member>
        <member name="F:LogUtils.Enums.SharedExtEnum`1.ManagedReference">
            <summary>
            A null-safe reference to the SharedExtEnum that any mod can access
            </summary>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.Registered">
            <summary>
            The managed reference associated with this ExtEnum instance has been assigned a valid ExtEnum value index
            </summary>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.Tag">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.Value">
            <summary>
            An identifying string assigned to each ExtEnum
            </summary>
        </member>
        <member name="P:LogUtils.Enums.SharedExtEnum`1.value">
            <inheritdoc cref="P:LogUtils.Enums.SharedExtEnum`1.Value"/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.EntryAt(System.Int32)">
            <summary>
            Retrieves an ExtEnum instance at the specified index
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The index provided is outside the bounds of the collection</exception>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.Parse(System.String)">
            <summary>
            A static means of finding a registered instance, or creating a new instance if there are no registered instances
            </summary>
            <param name="value">Case insensitive value to compare with</param>
            <exception cref="T:System.ArgumentException">The argument provided was not of a valid format</exception>
            <exception cref="T:LogUtils.Enums.ValueNotFoundException">A registered entry was not found with the given value</exception>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.TryParse(System.String,`0@)">
            <summary>
            A static means of finding a registered instance
            </summary>
            <param name="value">Case insensitive value to compare with</param>
            <param name="result">The instance created from the provided value</param>
            <returns>Returns whether a registered instance was found</returns>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.Register">
            <summary>
            Registers the ExtEnum instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.Unregister">
            <summary>
            Unregisters the ExtEnum instance
            </summary>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.CheckTag(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.CompareTo(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.BaseEquals(`0)">
            <summary>
            Indicates whether the current object is equal to another object of the same time (utilizes the base value hashcode comparison to determine equality)
            </summary>
        </member>
        <member name="M:LogUtils.Enums.SharedExtEnum`1.Equals(`0)">
            <summary>
            Indicates whether the current object is equal to another object of the same time (utilizes a customized value hashcode comparison to determine equality)
            </summary>
        </member>
        <member name="T:LogUtils.Enums.ValueNotFoundException">
            <summary>
            Represents an ExtEnum parsing error
            </summary>
        </member>
        <member name="M:LogUtils.Enums.ValueNotFoundException.#ctor(System.String)">
            <summary>
            Represents an ExtEnum parsing error
            </summary>
        </member>
        <member name="F:LogUtils.Events.ConsoleRequestEventArgs.Handled">
            <summary>
            List of ConsoleIDs that were transfered from pending status
            </summary>
        </member>
        <member name="F:LogUtils.Events.ConsoleRequestEventArgs.Pending">
            <summary>
            List of ConsoleIDs waiting to be handled
            </summary>
        </member>
        <member name="P:LogUtils.Events.ConsoleRequestEventArgs.Rules">
            <inheritdoc cref="F:LogUtils.Console.ConsoleLogWriter.Rules"/>
            <remarks>Null when a writer isn't currently assigned</remarks>
        </member>
        <member name="M:LogUtils.Events.LogEventArgs.Clone(LogUtils.Enums.LogID)">
            <summary>
            Clones the current EventArgs assigned with the provided LogID
            </summary>
        </member>
        <member name="M:LogUtils.Events.LogEventArgs.Clone">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Events.LogMovePendingEventArgs.MovePath">
            <summary>
            The new path, may be the same path if the file was only renamed
            </summary>
        </member>
        <member name="F:LogUtils.Events.LogMovePendingEventArgs.NewFilename">
            <summary>
            The pending filename to use when it is different from the current filename, otherwise null
            </summary>
        </member>
        <member name="F:LogUtils.Events.LogRequestEventArgs.ExtraArgs">
            <summary>
            A field for extra arguments - Use in cases when it is inconvenient to replace existing argument data  
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.LogSource">
            <summary>
            Contains source information needed to log through the BepInEx logger
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.Category">
            <summary>
            The log category associated with the message (equivalent to LogType (Unity), and LogLevel (BepInEx))
            </summary>
        </member>
        <member name="F:LogUtils.Events.LogRequestEventArgs.MessageObject">
            <summary>
            An object targeted for logging
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.Message">
            <summary>
            A message targeted for logging
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.MessageColor">
            <summary>
            The color to be used by default for a message
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.Rules">
            <summary>
            The message format rules associated with this message data
            </summary>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.CacheMessageTotal">
            <summary>
             Assigns a value to TotalMessagesLogged that will not change when new messages are logged 
            </summary>
        </member>
        <member name="P:LogUtils.Events.LogRequestEventArgs.PendingConsoleIDs">
            <summary>
            An enumerable containing ConsoleIDs that have yet to handle the message data
            </summary>
        </member>
        <member name="F:LogUtils.Events.LogRequestEventArgs.ShouldFilter">
            <summary>
            Whether this request's message should be filtered after request is successfully handled
            </summary>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,LogUtils.Enums.LogCategory)">
            <summary>
            Creates a new data storage instance for a LogRequest event
            </summary>
            <param name="logID">The targeted log file ID</param>
            <param name="messageData">The message to log</param>
            <param name="category">The category associated with the message</param>
            <exception cref="T:System.NullReferenceException">The LogID, or its properties field is null</exception>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,BepInEx.Logging.LogLevel)">
            <inheritdoc cref="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,UnityEngine.LogType)">
            <inheritdoc cref="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.LogID,System.Object,LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,LogUtils.Enums.LogCategory)">
            <summary>
            Creates a new data storage instance for a LogRequest event
            </summary>
            <param name="consoleID">The targeted console ID</param>
            <param name="messageData">The message to log</param>
            <param name="category">The category associated with the message</param>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,BepInEx.Logging.LogLevel)">
            <inheritdoc cref="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,UnityEngine.LogType)">
            <inheritdoc cref="M:LogUtils.Events.LogRequestEventArgs.#ctor(LogUtils.Enums.ConsoleID,System.Object,LogUtils.Enums.LogCategory)"/>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.FindData``1">
            <summary>
            Finds the first match of a given type, or returns null
            </summary>
        </member>
        <member name="M:LogUtils.Events.LogRequestEventArgs.GetElement">
            <summary>
            Constructs a JollyCoop LogElement struct using stored event data
            </summary>
        </member>
        <member name="F:LogUtils.Events.UtilityEvents.OnNewUpdateSynced">
            <summary>
            Gets invoked every frame from the base Update method of the abstract MainLoopProcess class. This EventHandler will be synced to the framesPerSecond defined by 
            that process
            </summary>
        </member>
        <member name="M:LogUtils.ExceptionInfo.Equals(LogUtils.ExceptionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.ExceptionInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.ExceptionInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.FilteredStringEntry.CheckValidation">
            <summary>
            Checks whether the filter is currently applicable
            </summary>
            <returns>true, when applicable, false otherwise</returns>
        </member>
        <member name="T:LogUtils.Formatting.AnsiColorFormatProvider">
            <summary>
            A type of ColorFormatProvider that replaces color data with ANSI color codes
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.AnsiColorFormatProvider.MessageColor">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.AnsiColorFormatProvider.Format(System.String,System.Object,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.AnsiColorFormatProvider.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.AnsiColorFormatProvider.ResetColor(System.Text.StringBuilder,LogUtils.Formatting.FormatData)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Formatting.EmptyColorFormatProvider">
            <summary>
            A type of ColorFormatProvider that replaces color data with empty strings
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.EmptyColorFormatProvider.MessageColor">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.EmptyColorFormatProvider.ApplyFormat(System.String,UnityEngine.Color)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.EmptyColorFormatProvider.Format(System.String,System.Object,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.EmptyColorFormatProvider.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Formatting.EmptyColorFormatProvider.ResetColor(System.Text.StringBuilder,LogUtils.Formatting.FormatData)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Formatting.FormatData">
            <summary>
            A data class for storing format informations
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatData.Argument">
            <summary>
            The format argument
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.FormatData.IsColorData">
            <summary>
            Checks that Argument is a UnityEngine.Color
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatData.BuildOffset">
            <summary>
            The positional offset between the local build position, and the actual position in the formatted string
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatData.LocalPosition">
            <summary>
            The index position in the local StringBuilder handling the format data
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.FormatData.Position">
            <summary>
            The index position of the format argument in the formatted string
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatData.Range">
            <summary>
            The number of valid chars to apply color formatting
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.Data.Entries">
            <summary>
            Collection of active format data being processed
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.Data.RangeCounter">
            <summary>
            A check on how many characters are needed to satisfy an argument's range requirement
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.Data.BypassColorCancellation">
            <summary>
            Allows color range check to not be reset when an ANSI color code is detected
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.Data.ExpectAnsiCode">
            <summary>
            Ansi color code escape sequence has been detected. Flag ensures that the code itself isn't considered as including colorable characters
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.FormatDataAccess.Data.Clear">
            <summary>
            Set data fields back to default values
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.NodeData.Builder">
            <summary>
            The builder in control of building the formatted string
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.FormatDataAccess.NodeData.Current">
            <summary>
            The format argument currently being processed
            </summary>
        </member>
        <member name="T:LogUtils.Formatting.IColorFormatProvider">
            <summary>
            An interface for handling color data processed through a FormattableString
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.IColorFormatProvider.ApplyFormat(System.String,UnityEngine.Color)">
            <summary>
            Applies color format to a message string
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.IColorFormatProvider.ResetColor(System.Text.StringBuilder,LogUtils.Formatting.FormatData)">
            <summary>
            Resets the text color back to a default value
            </summary>
        </member>
        <member name="P:LogUtils.Formatting.IColorFormatProvider.MessageColor">
            <summary>
            The color that will be used as the default text color for handled messages
            </summary>
        </member>
        <member name="T:LogUtils.Formatting.LogMessageFormatter">
            <summary>
            Applies format logic to message strings
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.LogMessageFormatter.Default">
            <summary>
            The default implementation that applies to most write implementations
            </summary>
        </member>
        <member name="F:LogUtils.Formatting.LogMessageFormatter.ColorFormatter">
            <summary>
            Applies color-based message format changes
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.LogMessageFormatter.#ctor">
            <summary>
            Constructs a LogMessageFormatter instance
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.LogMessageFormatter.#ctor(LogUtils.Formatting.IColorFormatProvider)">
            <summary>
            Constructs a LogMessageFormatter instance
            </summary>
            <param name="colorFormatter">Determines how color format arguments are handled</param>
        </member>
        <member name="M:LogUtils.Formatting.LogMessageFormatter.Format(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Formats message data into a log ready format
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.LogMessageFormatter.ApplyColor(System.String,UnityEngine.Color)">
            <summary>
            Formats color data into a provided message string
            </summary>
        </member>
        <member name="T:LogUtils.Formatting.LogRequestStringFormatter">
            <summary>
            Provides format options for handling internally supported LogRequest fields as arguments
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.StringParser.GetLines(System.String,System.Int32)">
            <summary>
            Splits a string by Newline characters
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.StringParser.Format(System.String[],System.String,System.Int32)">
            <summary>
            Takes an array of strings and returns a string containing the first series of characters up to the value of maxChars
            - or the length of the array if maxChars is less than or equal to zero. The separator string is excluded when counting characters
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.StringParser.TrimNewLine(System.String)">
            <summary>
            Trim the last trailing new line from the given string
            </summary>
        </member>
        <member name="M:LogUtils.Formatting.StringProvider.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.GameHooks.Initialize">
            <summary>
            Generates managed hooks, and applies all hooks used by the utility module
            </summary>
        </member>
        <member name="M:LogUtils.GameHooks.Apply">
            <summary>
            Apply hooks used by the utility module
            </summary>
        </member>
        <member name="M:LogUtils.GameHooks.Reload">
            <summary>
            Releases, and then reapply hooks used by the utility module 
            </summary>
        </member>
        <member name="M:LogUtils.GameHooks.Unload">
            <summary>
            Releases all hooks used by the utility module
            </summary>
        </member>
        <member name="M:LogUtils.GameHooks.RainWorld_PostModsInit(On.RainWorld.orig_PostModsInit,RainWorld)">
            <summary>
            Ends the grace period in which newly initialized properties can be freely modified
            </summary>
        </member>
        <member name="F:LogUtils.GameHooks.disableLogClearing">
            <summary>
            This flag prevents clear log functions from activating for Expedition, and JollyCoop
            </summary>
        </member>
        <member name="T:LogUtils.GameLogger">
            <summary>
            A class for handling game-controlled log content
            </summary>
        </member>
        <member name="F:LogUtils.GameLogger.LogFileInProcess">
            <summary>
            Set to the LogID of a request while it is being handled through an external logging API accessed by a GameLogger instance
            </summary>
        </member>
        <member name="M:LogUtils.GameLogger.CanHandle(LogUtils.Enums.LogID)">
            <summary>
            Checks that provided LogID is game-controlled, the only type of LogID supported by this log handler
            </summary>
        </member>
        <member name="M:LogUtils.GameLogger.GetWriter(LogUtils.Enums.LogID)">
            <summary>
            Retrieves the current LogWriter for a game-controlled log file 
            </summary>
        </member>
        <member name="M:LogUtils.GameLogger.LogBepEx(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogBepEx(BepInEx.Logging.ILogSource,LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogBepEx(BepInEx.Logging.ILogSource,BepInEx.Logging.LogLevel,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogUnity(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogUnity(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogUnity(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogUnity(UnityEngine.LogType,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogExp(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogExp(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogExp(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogJolly(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(System.Object)"/>
        </member>
        <member name="M:LogUtils.GameLogger.LogJolly(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Game.LogJolly(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.Helpers.AssemblyUtils.GetAllTypes">
            <summary>
            Get all types from each assembly in the current domain
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.AssemblyUtils.GetCallingAssembly">
            <summary>
            Get the first calling assembly that is not the executing assembly via a stack trace
            </summary>
            <remarks>Credit for this code goes to WilliamCruisoring</remarks>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ComparerBase`1.Compare(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ComparerBase`1.Equals(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ComparerBase`1.GetHashCode(`0)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ExceptionComparer.MAX_CHARS_DEFAULT">
            <summary>
            The maximum amount of characters to check for exception equality
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ExceptionComparer.MAX_LINES_DEFAULT">
            <summary>
            The maximum amount of new lines to check for exception equality
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ExceptionComparer.MaxLinesToCheck">
            <summary>
            The maximum amount of new lines that can be used to evaluate equality - when set to zero, all lines will be checked
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.Comparers.ExceptionComparer.MaxCharsToCheck">
            <summary>
            The maximum amount of characters that can be used to evaluate equality - when set to zero, no limit will be applied
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExceptionComparer.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates an ExceptionComparer instance
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExceptionComparer.Equals(LogUtils.ExceptionInfo,LogUtils.ExceptionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExceptionComparer.GetHashCode(LogUtils.ExceptionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExtEnumValueComparer`1.Compare(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExtEnumValueComparer`1.Equals(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.ExtEnumValueComparer`1.GetHashCode(`0)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.FilenameComparer.Compare(System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Helpers.Comparers.ComparerBase`1.Compare(`0,`0)"/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.FilenameComparer.Compare(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.FilenameComparer.Equals(System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:LogUtils.Helpers.Comparers.ComparerBase`1.Equals(`0,`0)"/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.FilenameComparer.Equals(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.Compare(LogUtils.Enums.LogID,LogUtils.Enums.LogID)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.LogIDComparer.CompareNullProperties(LogUtils.Enums.LogID,LogUtils.Enums.LogID)">
            <summary>
            Compare LogID instances when one, or both instances has a null properties field
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Comparers.RemoteLoggerComparer.Compare(LogUtils.ILogHandler,LogUtils.ILogHandler)">
            <summary>
            Returns an integer representation of the better candidate for remote logging
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.ExceptionUtils.ExtractAggregate(System.Exception)">
            <summary>
            Takes an exception as input, and returns all InnerExceptions from it when it is an AggregateException, otherwise returns empty set
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.Extensions.ExtensionMethods">
            <summary>
            Class for miscellaneous extension methods
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.ContainsType``1(System.Collections.IEnumerable)">
            <summary>
            Extension method that checks if an enumerable contains an item of a specified type
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.Normalize(System.Collections.Generic.HashSet{LogUtils.Enums.LogCategory})">
            <summary>
            Ensures that set is not null, and invalid entries are not present
            </summary>
            <remarks>This method is null safe, and HashSet will be operated on directly</remarks>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.IsComposite(UnityEngine.LogType)">
            <summary>
            Evaluates whether the enum is composed of two or more distinct flagged values
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.Deconstruct(BepInEx.Logging.LogLevel)">
            <summary>
            Deconstructs an enum into its flagged values
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.Deconstruct(UnityEngine.LogType)">
            <summary>
            Deconstructs an enum into its flagged values
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.GetFlags(UnityEngine.LogType)">
            <summary>
            Extracts any bitflag compatible values, masking all others
            </summary>
            <param name="logType">The LogType to evaluate</param>
            <returns>A LogType only containing bits within the conversion value range if any are present; otherwise defaults to -1</returns>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.CanHandle(LogUtils.ILogHandler,LogUtils.Requests.LogRequest)">
            <summary>
            Does this handler accept this LogRequest
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.CompatibleWith(System.Collections.Generic.IEnumerable{LogUtils.ILogHandler},LogUtils.Enums.LogID,LogUtils.Requests.RequestType)">
            <summary>
            Finds a list of all logger instances that accepts log requests for a specified LogID
            </summary>
            <param name="handlers"></param>
            <param name="logFile">LogID to check</param>
            <param name="requestType">The request type expected</param>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.FindCompatible(System.Collections.Generic.IEnumerable{LogUtils.ILogHandler},LogUtils.Enums.LogID,LogUtils.Requests.RequestType)">
            <summary>
            Find a logger instance that accepts log requests for a specified LogID
            </summary>
            <param name="handlers"></param>
            <param name="logFile">LogID to check</param>
            <param name="requestType">The request type expected</param>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.NearestEquivalent(System.Collections.Generic.IEnumerable{LogUtils.Enums.LogID},LogUtils.Enums.LogID)">
            <summary>
            Finds the best fit candidate in a target collection for a provided log file
            </summary>
            <returns>A LogID contained in the target collection with a matching filename, and/or path (best fit)</returns>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.WriteFromBuffer(LogUtils.ILogWriter,LogUtils.Enums.LogID,System.Boolean)">
            <summary>
            Attempts to write content from the message buffer to file
            </summary>
            <param name="writer"></param>
            <param name="logFile">The file that contains the message buffer</param>
            <param name="respectBufferState">When true no content will be written to file if MessageBuffer.IsBuffering property is set to true</param>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.AppendHeader(System.Text.StringBuilder,System.String)">
            <summary>
            Appends a message in between divider spacers
            </summary>
            <param name="builder">The builder to append to</param>
            <param name="header">The content to use as a header</param>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.MatchAny(System.String,System.Collections.Generic.IEqualityComparer{System.String},System.String[])">
            <summary>
            Evaluates whether a string is equal to any of the provided values
            </summary>
            <param name="str">The string to evaluate</param>
            <param name="comparer">An IEqualityComparer to use for the evaluation</param>
            <param name="values">The values to compare the string against</param>
            <returns>Whether a match was found</returns>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.Bump(System.Version,LogUtils.Helpers.Extensions.VersionCode,System.Int32)">
            <summary>
            Bumps provided version to a specified value
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Increment value is negative</exception>
            <exception cref="T:System.NotImplementedException">VersionCode is invalid</exception>
            <exception cref="T:System.NotSupportedException">The Version object doesn't provide the requested version value</exception>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.Add``1(System.Collections.Generic.ICollection{System.WeakReference{``0}},``0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.AddRange``1(System.Collections.Generic.ICollection{System.WeakReference{``0}},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds each item in the provided collection to the ICollection&lt;T&gt;"/>
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.Remove``1(System.Collections.Generic.ICollection{System.WeakReference{``0}},``0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.RemoveWhere``1(System.Collections.Generic.ICollection{System.WeakReference{``0}},System.Predicate{``0})">
            <summary>
            Remove items from the ICollection&lt;T&gt; based on a predicate
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.Extensions.ExtensionMethods.RemoveCollectedEntries``1(System.Collections.Generic.ICollection{System.WeakReference{``0}})">
            <summary>
            Remove entries that have been garbage collected
            </summary>
            <returns>The number of removed entries</returns>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryTree.#ctor(System.String)">
            <summary>
            Construct a tree data structure using a directory path as a root
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryTree.FindPositionInTree(System.String)">
            <summary>
            Finds the nearest common directory within the root directory to a provided path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryTree.DirectoryTreeNode.Detach">
            <summary>
            Detach node from the parent node
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryTree.DirectoryTreeNode.FindChild(System.String)">
            <summary>
            Find an immediate child node with a given value, otherwise null
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.DirectoryUtils.ParentExists(System.String)">
            <summary>
            Determines if the given path has an existing parent directory
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.FileExtension">
            <summary>
            A helper class for manipulating file extension information
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.FileExtension.SupportedExtensions">
            <summary>
            Case insensitive file extensions that are supports by LogUtils for use in log filenames, or log backup filenames
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.FileExtension.LongExtensionSupport">
            <summary>
            The current standard applied to long file extension handling
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.IsSupported(System.String)">
            <summary>
            Returns true if string contains a file extension listed as a supported extension for the utility
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Match(System.String,System.String)">
            <summary>
            Case insensitive comparison of the file extensions of two filenames
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Remove(System.String)">
            <inheritdoc cref="M:LogUtils.Helpers.FileHandling.FileExtension.Remove(System.String,System.String@)"/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Remove(System.String,System.String@)">
            <summary>
            Removes the file extension from the provided filename
            </summary>
            <param name="filename">The provided filename</param>
            <param name="fileExt">File extension information (including the period), stores an empty string if filename is null, or does not contain a file extension</param>
            <returns>The filename (or path) without the file extension</returns>
            <remarks>Filenames with long extensions may be unaffected by this operation</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Replace(System.String,System.String)">
            <summary>
            Replace the file extension of the provided filename with a provided file extension
            </summary>
            <param name="target">The provided filename</param>
            <param name="fileExt">The file extension to use</param>
            <returns>The filename (or path) with the provided file extension</returns>
            <remarks>Filenames with long extensions may be unaffected by this operation</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileExtension.Transfer(System.String,System.String)">
            <summary>
            Takes the file extension from one filename and applies it to another filename
            </summary>
            <param name="transferFrom">The file extension source</param>
            <param name="transferTo">The file extension replace target</param>
            <returns>The filename (or path) with the applied file extension</returns>
            <remarks>Filenames with long extensions may be unaffected by this operation</remarks>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.FileUtils">
            <summary>
            Helper class for interacting with the file system that is safe and supported by LogUtils
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.FileUtils.BRACKET_FORMAT">
            <summary>
            Used to attach information to a filename
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryDelete(System.String,System.String)">
            <summary>
            Attempts to delete a file at the specified path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryCopy(System.String,System.String,System.Int32)">
            <summary>
            Attempts to copy a file to a specified path 
            </summary>
            <remarks>Any file at the destination path will be overwritten</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryMove(System.String,System.String,System.Int32)">
            <summary>
            Attempts to move a file to a specified path
            </summary>
            <remarks>Any file at the destination path will be overwritten</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryWrite(System.String,System.String[])">
            <summary>
            Attempts to write one or more strings to file
            </summary>
            <remarks>File is created, its contents are overwritten if it already exists</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.TryWrite(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <inheritdoc cref="M:LogUtils.Helpers.FileHandling.FileUtils.TryWrite(System.String,System.String[])"/>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.AppendLine(System.String,System.String)">
            <inheritdoc cref="M:System.IO.File.AppendAllText(System.String,System.String)"/>
            <remarks>
            - Appends a new line after specified string.<br/>
            - Write lock is applied internally for thread safety, but is not safe to run from multiple processes.
            </remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.FileUtils.AppendText(System.String,System.String)">
            <inheritdoc cref="M:System.IO.File.AppendAllText(System.String,System.String)"/>
            <remarks>
            - Write lock is applied internally for thread safety, but is not safe to run from multiple processes.
            </remarks>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.PathResolution">
            <summary>
            Performs helper functions similar to AssetManager path resolution
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.ResolveResults.Exists">
            <summary>
            Does the resolved path exist, or does the result represent a non-existant fallback path
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.ResolveResults.ModOwner">
            <summary>
            Contains the associated mod instance if it exists
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.ResolveResults.Original">
            <summary>
            The original path
            </summary>
        </member>
        <member name="F:LogUtils.Helpers.FileHandling.ResolveResults.Result">
            <summary>
            The portion of the path that was resolved
            </summary>
        </member>
        <member name="P:LogUtils.Helpers.FileHandling.ResolveResults.CombinedResult">
            <summary>
            Gets the complete resolved path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.ContainsDirectory(System.String,System.String,System.Int32)">
            <summary>
            Checks that a directory is contained within a path string
            </summary>
            <param name="path">The path to check</param>
            <param name="dirName">The directory name to search for</param>
            <param name="dirLevelsToCheck">The number of directory separators to check starting from the right</param>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.ContainsOtherPath(System.String,System.String)">
            <summary>
            Checks the second path is contained with the first path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.FindCommonRoot(System.String,System.String)">
            <summary>
            Finds a path string that two provided paths have in common
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.GetRelativePath(System.String,System.String,System.Boolean)">
            <summary>
            Takes two paths and determines how one of the paths relates to the other path
            </summary>
            <param name="targetPath">The path to evaluate</param>
            <param name="relativeTo">The path to check against</param>
            <param name="includeCommonDirectoryInResult">A flag indicating whether to include the most relevant directory in common between the given paths</param>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.Normalize(System.String)">
            <summary>
            Replace all directory separator characters with the default platform-specific directory separator character 
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.PathRootExists(System.String,System.Int32)">
            <summary>
            Checks the path directory and parents of that directory for an existing directory
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.FindExistingPathRoot(System.String,System.Int32)">
            <summary>
            Checks the path directory and parents of that directory for an existing directory
            </summary>
            <returns>The portion of the path that exists</returns>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.PathWithoutFilename(System.String)">
            <summary>
            Returns a path string without the filename (filename must have an extension)
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.PathWithoutFilename(System.String,System.String@)">
            <summary>
            Returns a path string without the filename (filename must have an extension)
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.PrependWithSeparator(System.String)">
            <summary>
            Prepends a single directory separator character to a given path string
            </summary>
            <remarks>This method will remove any existing separator characters at the start of the path</remarks>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.Separate(System.String)">
            <summary>
            Separates a path into its directory and/or file components
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.Unroot(System.String)">
            <summary>
            Check for a path root, and strip it from the path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.IsAbsolute(System.String)">
            <summary>
            Checks that the path given is an absolute path
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FileHandling.PathUtils.PathsAreEqual(System.String,System.String)">
            <summary>
            Evaluates whether paths are logically equivalent
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.FileHandling.PathWrapper">
            <summary>
            Simple wrapper for a path string
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FlagUtils.HasConvertedFlags(System.Int32)">
            <summary>
            Check that the value is within what is considered the conversion value range
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.FlagUtils.HasMultipleFlags(System.Int32)">
            <summary>
            Check that value satisfies a bitflag value requirement - only evaluates positive integers
            </summary>
        </member>
        <member name="T:LogUtils.Helpers.LogFile">
            <summary>
            Contains helper methods for basic file operations involving log files
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.Copy(LogUtils.Enums.LogID,System.String)">
            <summary>
            Creates a copy of a log file
            </summary>
            <param name="logFile">The LogID that accesses the log file path</param>
            <param name="copyPath">The full path to the destination of the log file. Log filename is optional</param>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.Copy(System.String,System.String,System.Boolean)">
            <summary>
            Creates a copy of a log file
            </summary>
            <param name="sourceLogPath">The full path to the log file that needs to be copied (including filename + ext)</param>
            <param name="destLogPath">The full path to the destination of the log file. Log filename is optional</param>
            <param name="overwriteExisting">Specifies the behavior that happens when the file already exists at the destination path</param>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.Move(System.String,System.String,System.Boolean)">
            <summary>
            Moves a log file from one place to another. Allows file renaming
            </summary>
            <param name="sourceLogPath">The full path to the log file that needs to be moved (including filename + ext)</param>
            <param name="destLogPath">The full path to the destination of the log file. Log filename is optional</param>
            <param name="overwriteExisting">Specifies the behavior that happens when the file already exists at the destination path</param>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.Open(LogUtils.Enums.LogID)">
            <summary>
            Opens a FileStream instance for a log file
            </summary>
            <param name="logFile">The LogID that accesses the log file path</param>
            <returns>The opened FileStream, or null if the file could not be opened, or created</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.TryCreate(LogUtils.Enums.LogID)">
            <summary>
            Starts a log file session creating the log file if it doesn't exist
            </summary>
            <param name="logFile">The LogID that accesses the log file path</param>
            <returns>The active state of the log session</returns>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.StartNewSession(LogUtils.Enums.LogID)">
            <summary>
            Ends the current logging session, and starts a new one if allowed to do so 
            </summary>
        </member>
        <member name="M:LogUtils.Helpers.LogFile.GetPersistentLogFiles">
            <summary>
            Retrieves all file handles for log files with at least one persistent FileStream open (file is currently in use), or temporarily closed
            </summary>
        </member>
        <member name="F:LogUtils.FileExtensionInfo.MIN_LONG_EXTENSION_LENGTH">
            <summary>
            The minimum amount of characters (including the period) to satisfy the long file extension property
            </summary>
        </member>
        <member name="F:LogUtils.FileExtensionInfo.IsEmpty">
            <summary>
            Is the file extension null, or empty
            </summary>
        </member>
        <member name="F:LogUtils.FileExtensionInfo.IsNormalized">
            <summary>
            Is the file extension in a comparison neutral format (i.e. all lowercase)
            </summary>
        </member>
        <member name="P:LogUtils.FileExtensionInfo.IsSupported">
            <summary>
            Is the file extension supported by LogUtils
            </summary>
        </member>
        <member name="P:LogUtils.FileExtensionInfo.IsLong">
            <summary>
            Does the file extension exceed a set amount of characters determined by the utility
            </summary>
        </member>
        <member name="F:LogUtils.FileExtensionInfo.Extension">
            <summary>
            The value of the file extension
            </summary>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.#ctor">
            <summary>
            Creates a new <see cref="T:LogUtils.FileExtensionInfo"/> object with no extension information
            </summary>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.Normalize">
            <summary>
            Converts the file extension into a comparison neutral format (i.e. all lowercase)
            </summary>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.Equals(LogUtils.FileExtensionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.FromFilename(System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.FileExtensionInfo"/> object from a filename or path containing a filename 
            </summary>
            <exception cref="T:System.ArgumentException">The provided filename contains invalid path characters</exception>
        </member>
        <member name="M:LogUtils.FileExtensionInfo.FromExtension(System.String)">
            <summary>
            Creates a new <see cref="T:LogUtils.FileExtensionInfo"/> object from a filename extension 
            </summary>
        </member>
        <member name="F:LogUtils.LongExtensionSupport.Ignore">
            <summary>
            Long file extensions of any form should be ignored
            </summary>
        </member>
        <member name="F:LogUtils.LongExtensionSupport.SupportedOnly">
            <summary>
            Long file extensions that are not listed as a supported file extension are ignored
            </summary>
        </member>
        <member name="F:LogUtils.LongExtensionSupport.Full">
            <summary>
            Long file extensions of any form are allowed
            </summary>
        </member>
        <member name="M:LogUtils.IFlushable.Flush">
            <summary>
            Flushes out the log buffer
            </summary>
        </member>
        <member name="T:LogUtils.ILogger">
            <summary>
            Represents a type used to perform logging
            </summary>
        </member>
        <member name="M:LogUtils.ILogger.Log(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.LogDebug(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogDebug(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.LogInfo(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogInfo(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.LogImportant(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogImportant(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.LogMessage(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogMessage(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.LogWarning(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogWarning(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.LogError(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogError(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.LogFatal(System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.LogFatal(System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.Log(UnityEngine.LogType,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.Log(BepInEx.Logging.LogLevel,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.Log(System.String,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="M:LogUtils.ILogger.Log(LogUtils.Enums.LogCategory,System.Object)">
            <inheritdoc cref="M:LogUtils.Documentation.LoggerDocumentation.Standard.Log(LogUtils.Enums.LogCategory,System.Object)"/>
        </member>
        <member name="T:LogUtils.ILogHandler">
            <summary>
            Represents a type used to process logging requests
            </summary>
        </member>
        <member name="P:LogUtils.ILogHandler.AllowLogging">
            <summary>
            Does this handler accept logging requests (local or remote)
            </summary>
        </member>
        <member name="P:LogUtils.ILogHandler.AllowRemoteLogging">
            <summary>
            Does this handler accept remote logging requests
            </summary>
        </member>
        <member name="P:LogUtils.ILogHandler.AllowRegistration">
            <summary>
            Does this handler register with the LogRequest system
            </summary>
        </member>
        <member name="M:LogUtils.ILogHandler.CanHandle(LogUtils.Enums.LogID,LogUtils.Requests.RequestType)">
            <summary>
            Does this handler accept LogRequests of a specific log file and request type
            </summary>
        </member>
        <member name="M:LogUtils.ILogHandler.HandleRequest(LogUtils.Requests.LogRequest)">
            <summary>
            Accepts and processes a LogRequest instance
            </summary>
        </member>
        <member name="P:LogUtils.ILogFileHandler.AvailableTargets">
            <summary>
            Log files available for use by the handler
            </summary>
        </member>
        <member name="M:LogUtils.ILogFileHandler.GetAccessibleTargets">
            <summary>
            Retrieves all log files that are accessible by the handler
            </summary>
        </member>
        <member name="T:LogUtils.ILogSourceProvider">
            <summary>
            Provides access to an ILogSource
            </summary>
        </member>
        <member name="P:LogUtils.ILogSourceProvider.LogSource">
            <summary>
            The logging source associated with the provider
            </summary>
        </member>
        <member name="T:LogUtils.ILogWriterProvider">
            <summary>
            Provides access to an ILogWriter
            </summary>
        </member>
        <member name="M:LogUtils.ILogWriterProvider.GetWriter">
            <summary>
            Gets the log writer managed by the provider
            </summary>
        </member>
        <member name="M:LogUtils.ILogWriterProvider.GetWriter(LogUtils.Enums.LogID)">
            <summary>
            Gets the log writer associated with the provider for a specific log file
            </summary>
        </member>
        <member name="T:LogUtils.IPC.PipeDemo">
            <summary>
            Demonstrates a working PipeServer and client system
            </summary>
        </member>
        <member name="P:LogUtils.IPC.ProcessMonitor.IsConnected">
            <summary>
            This process has control of the PipeServer that all LogUtils instances attempt to establish a connection with
            </summary>
        </member>
        <member name="M:LogUtils.IPC.ProcessMonitor.WaitOnConnectionStatus">
            <summary>
            Block thread until connection status has been verified
            </summary>
        </member>
        <member name="M:LogUtils.ISelectable.SelectFirst">
            <summary>
            Selects the first element
            </summary>
        </member>
        <member name="M:LogUtils.ISelectable.SelectLast">
            <summary>
            Selects the last element
            </summary>
        </member>
        <member name="M:LogUtils.ISelectable.SelectPrev">
            <summary>
            Selects the previous element
            </summary>
        </member>
        <member name="M:LogUtils.ISelectable.SelectNext">
            <summary>
            Selects the next element
            </summary>
        </member>
        <member name="P:LogUtils.Lifetime.TimeRemaining">
            <summary>
            A managed representation of the time remaining before filestream is disposed in milliseconds
            </summary>
        </member>
        <member name="F:LogUtils.Lifetime.UpdateTask">
            <summary>
            Task assigned to update the life span for this object
            </summary>
        </member>
        <member name="M:LogUtils.Lifetime.FromMilliseconds(System.Int32)">
            <summary>
            Constructs a representation of a Lifetime with a given duration in milliseconds
            </summary>
        </member>
        <member name="M:LogUtils.Lifetime.SetDuration(System.Int32)">
            <summary>
            Set the lifetime remaining to a duration in milliseconds
            </summary>
        </member>
        <member name="F:LogUtils.LogFileMover.ReplaceExistingFile">
            <summary>
            Move attempt will replace a file at the destination path when true; fail to move when false
            </summary>
        </member>
        <member name="M:LogUtils.LogFileMover.#ctor(System.String,System.String)">
            <summary>
            Creates an object capable of moving, or copying log files to a new destination
            </summary>
            <param name="sourceLogPath">The full path to the log file that needs to be moved (including filename + ext)</param>
            <param name="destLogPath">The full path to the destination of the log file. Log filename is optional.</param>
        </member>
        <member name="M:LogUtils.LogFileMover.MoveFile">
            <summary>
            Moves a log file from one place to another. Allows file renaming.
            </summary>
        </member>
        <member name="M:LogUtils.LogFileMover.CopyFile">
            <summary>
            Copies a log file from one place to another. Allows file renaming.
            </summary>
        </member>
        <member name="M:LogUtils.LogFileMover.PrepareToMoveFile(LogUtils.LogValidator)">
            <summary>
            Handles FileSystem operations that are necessary before a move/copy operation can be possible
            </summary>
        </member>
        <member name="F:LogUtils.LogFilename.Extension">
            <summary>
            The file extension belonging to the filename
            </summary>
        </member>
        <member name="F:LogUtils.LogFilename.Value">
            <summary>
            The value of the filename without extension
            </summary>
        </member>
        <member name="F:LogUtils.LogFilename.IsValid">
            <summary>
            Does the value represent a valid filename
            </summary>
        </member>
        <member name="M:LogUtils.LogFilename.#ctor(System.String)">
            <summary>
            Constructs a LogFilename instance
            </summary>
            <param name="value">A filename string without path information</param>
            <exception cref="T:System.ArgumentNullException">Value provided is null</exception>
        </member>
        <member name="M:LogUtils.LogFilename.#ctor(System.String,System.String)">
            <summary>
            Constructs a LogFilename instance
            </summary>
            <param name="value">A filename string without path information, or file extension</param>
            <param name="fileExt">A supported file extension to be used along with the filename. May be null</param>
            <exception cref="T:System.ArgumentNullException">Value provided is null</exception>
        </member>
        <member name="M:LogUtils.LogFilename.CompareTo(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.Equals(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.Equals(LogUtils.LogFilename)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.CompareTo(LogUtils.LogFilename)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogFilename.WithExtension">
            <summary>
            The filename as a string (including file extension)
            </summary>
        </member>
        <member name="M:LogUtils.LogFilename.ToString">
            <summary>
            The filename as a string (without file extension)
            </summary>
        </member>
        <member name="F:LogUtils.LogFilter.ActiveKeywords">
            <summary>
            List of filter keywords - A filter entry with a keyword must have that keyword in this list in order for the filter to be effective 
            </summary>
        </member>
        <member name="F:LogUtils.LogFilter.FilteredStrings">
            <summary>
            Dictionary of strings that should be ignored when a log attempt is made
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.IsAllowed(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Checks that log request data is allowed to be processed
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.IsAllowed(LogUtils.Enums.LogID,System.String)">
            <summary>
            Checks that a specified log message is allowed to be processed
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.IsAllowed(LogUtils.Enums.LogCategory)">
            <summary>
            Checks that a specified logging context is allowed to be processed
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.ActivateKeyword(System.String)">
            <summary>
            Designates a keyword as active by adding it to the ActiveKeywords list
            </summary>
        </member>
        <member name="M:LogUtils.LogFilter.DeactivateKeyword(System.String)">
            <summary>
            Removes keyword from the ActiveKeywords list
            </summary>
        </member>
        <member name="M:LogUtils.LogFilterParser.getHeaderData(System.String)">
            <summary>
            Parses out data necessary to process the filter
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Custom.CustomLogProperty.IsLogRule">
            <summary>
            A field that indicates that this property is convertible into a LogRule instance
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Custom.CustomLogProperty.IsEnabled">
            <summary>
            A field that indicates whether property functionality should be applied
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Custom.CustomLogProperty.Name">
            <summary>
            The string that will be used as header information
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Custom.CustomLogProperty.Value">
            <summary>
            The value of the property converted to a string
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogProperty.CheckEnabled(System.String)">
            <summary>
            An overridable method that allows custom parsing of the value to determine the enable state for this property
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogProperty.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructs a CustomLogProperty
            </summary>
            <param name="name">A string to be used as header information</param>
            <param name="value">The default, or current value assigned to this property converted to a string</param>
            <param name="isRule">Whether or not this data is associated with a custom LogRule object</param>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogProperty.CreateRule">
            <summary>
            An overridable method used in conjunction with IsLogRule for constructing custom LogRule implementations 
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogProperty.Clone">
            <summary>
            An overridable method that creates a copy of the current class instance
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Custom.CustomLogPropertyCollection.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.BepInExHeaderRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Properties.Formatting.DelegatedLogRule">
            <summary>
            A LogRule that stores its apply logic inside of a delegate
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Formatting.DelegatedLogRule.Callback">
            <summary>
            Invoked when rule is applied
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.DelegatedLogRule.#ctor(System.String,LogUtils.Properties.Formatting.LogRule.ApplyDelegate,System.Boolean)">
            <summary>
            Create a DelegatedLogRule instance
            </summary>
            <param name="name">The name associated with the LogRule. (Make it unique)</param>
            <param name="applyCallback">The delegate to assign as the rule logic</param>
            <param name="enabled">Whether the rule is applied</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.DelegatedLogRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ErrorsOnlyHeaderRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRule.Owner">
            <summary>
            The containing collection instance of a LogRule. Only one collection allowed per instance
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRule.ReadOnly">
            <summary>
            Is persistent state protected from modifications
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRule.Name">
            <summary>
            An unique string that identifies a particular LogRule. LogRules with the same value in this field will be treated as interchangable within the LogRuleCollection class
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRule.Priority">
            <summary>
            The default priority of a LogRule. Rules are applied in order of priority from lowest to highest
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRule.TemporaryOverride">
            <summary>
            The instance stored in this field takes priority over the LogRule that contains it
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.Restore">
            <summary>
            Change recent rule modifications back to pre-change values
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs a new LogRule instance
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.Apply(LogUtils.Formatting.LogMessageFormatter,System.String@,LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Applies format logic to a message
            </summary>
            <param name="formatter">The applicable formatter instance</param>
            <param name="message">The message to format</param>
            <param name="logEventData">Data associated with the message event</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Applies format logic to a message
            </summary>
            <param name="formatter">The applicable formatter instance</param>
            <param name="message">The message to format</param>
            <param name="logEventData">Data associated with the message event</param>
            <returns>The message after rule formatting is applied</returns>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRule.Clone">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Properties.Formatting.LogRule.ApplyDelegate">
            <summary>
            Delegate signature for applying a LogRule
            </summary>
            <param name="formatter">The applicable formatter instance</param>
            <param name="message">The message to format</param>
            <param name="logEventData">Data associated with the message event</param>
            <returns>The message after rule formatting is applied</returns>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ShowCategoryRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ShowCategoryRule.GetPriority">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Properties.Formatting.ShowLineCountRule.RuleColor">
            <summary>
            The color that applies to the line count rule
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ShowLineCountRule.ApplyRule(LogUtils.Formatting.LogMessageFormatter,System.String,LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.ShowLineCountRule.GetPriority">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Properties.Formatting.LogRuleAttribute">
            <summary>
            An attribute that contains data necessary for LogUtils to construct a LogRule instance.
            </summary>
            <remarks>Methods that use this attribute must have the same signature as <see cref="T:LogUtils.Properties.Formatting.LogRule.ApplyDelegate"/>.</remarks>
            <param name="RuleName">The name of the LogRule represented by this attribute</param>
            <param name="EnabledByDefault">Indicates that the LogRule should start in an active, or inactive state</param>
            <param name="Priority">The process order priority of the LogRule</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleAttribute.#ctor(System.String,System.Boolean,System.Single)">
            <summary>
            An attribute that contains data necessary for LogUtils to construct a LogRule instance.
            </summary>
            <remarks>Methods that use this attribute must have the same signature as <see cref="T:LogUtils.Properties.Formatting.LogRule.ApplyDelegate"/>.</remarks>
            <param name="RuleName">The name of the LogRule represented by this attribute</param>
            <param name="EnabledByDefault">Indicates that the LogRule should start in an active, or inactive state</param>
            <param name="Priority">The process order priority of the LogRule</param>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRuleAttribute.RuleName">
            <summary>
            The name of the LogRule represented by this attribute
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRuleAttribute.EnabledByDefault">
            <summary>
            Indicates that the LogRule should start in an active, or inactive state
            </summary>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRuleAttribute.Priority">
            <summary>
            The process order priority of the LogRule
            </summary>
        </member>
        <member name="T:LogUtils.Properties.Formatting.LogRuleAssemblyAttribute">
            <summary>
            Indicate that assembly contains LogRule definitionx. LogUtils will attempt to activate any reflection loaded LogRules from your assembly.
            </summary>
            <param name="TypeHints">The array of types containing all reflection loaded LogRule members. When left empty, all assembly types will be checked.</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleAssemblyAttribute.#ctor(System.Type[])">
            <summary>
            Indicate that assembly contains LogRule definitionx. LogUtils will attempt to activate any reflection loaded LogRules from your assembly.
            </summary>
            <param name="TypeHints">The array of types containing all reflection loaded LogRule members. When left empty, all assembly types will be checked.</param>
        </member>
        <member name="T:LogUtils.Properties.Formatting.ReflectionLoadedAttribute">
            <summary>
            Indicate that LogUtils should try to activate a LogRule with this attribute through reflection
            </summary>
            <remarks>
            <para>Incorrectly configured attributes may throw a <see cref="T:LogUtils.MissingAttributeException"/>.</para>
            <para>Usage:</para>
            <para>Classes that use this attribute must inherit from <see cref="T:LogUtils.Properties.Formatting.LogRule"/>.</para>
            <para>Methods that use this attribute must have the same signature as <see cref="T:LogUtils.Properties.Formatting.LogRule.ApplyDelegate"/>.</para>
            <para>Methods that use this attribute must also have the <see cref="T:LogUtils.Properties.Formatting.LogRuleAttribute"/>.</para>
            <para>Attribute does nothing without applying the <see cref="T:LogUtils.Properties.Formatting.LogRuleAssemblyAttribute"/> to the executing assembly.</para></remarks>
        </member>
        <member name="F:LogUtils.Properties.Formatting.LogRuleCollection.ChangeRecord">
            <summary>
            Tracks LogRule state changes
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRuleCollection.TrackChanges">
            <summary>
            Enables/disables change state system
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRuleCollection.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.Formatting.LogRuleCollection.AllowRuleChanges">
            <summary>
            Gets a value indicating whether rules belonging to this collection should protect their persistent state
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.#ctor(LogUtils.Collections.ReadOnlyProvider)">
            <summary>
            Creates a new <see cref="T:LogUtils.Properties.Formatting.LogRuleCollection"/> instance
            </summary>
            <param name="logRuleReadOnlySource">The binding source for determining the ReadOnly state of  a <see cref="T:LogUtils.Properties.Formatting.LogRule"/> that belongs to this collection</param>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.ChangeAlert">
            <summary>
            Notify that <see cref="T:LogUtils.Properties.Formatting.LogRule"/> changes are ready to be tracked
            </summary>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.Add(LogUtils.Properties.Formatting.LogRule)">
            <summary>
            Adds a LogRule instance to the collection of Rules
            </summary>
            <remarks>Do not use this for temporary rule changes, use <see cref="M:LogUtils.Properties.Formatting.LogRuleCollection.SetTemporaryRule(LogUtils.Properties.Formatting.LogRule)"/> instead</remarks>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.Replace(LogUtils.Properties.Formatting.LogRule)">
            <summary>
            Replaces an existing rule with another instance
            </summary>
            <remarks>
            <para>Be warned, running this each time your mod runs will overwrite data being saved, and read from file</para>
            <para>Do not replace existing property data values in a way that might break the parse logic</para>
            <para>Consider using temporary rules instead, and handle saving of the property values through your mod</para>
            <para>In either case, you may want to inherit from the existing property in case a user has changed the property through the file</para>
            </remarks>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.Remove(LogUtils.Properties.Formatting.LogRule)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.Reset">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.CreateOrderedEnumerable``1(System.Func{LogUtils.Properties.Formatting.LogRule,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.Formatting.LogRuleCollection.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.LatestVersion">
            <summary>
            The latest properties version recognized by LogUtils
            </summary>
            <remarks>Major&lt;Reserved for LogUtils&gt; Minor (or less)&lt;Reserved for mod usage&gt;</remarks>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.Rules">
            <summary>
            A prioritized order of process actions that must be applied to a message string before logging it to file 
            </summary>
        </member>
        <member name="E:LogUtils.Properties.LogProperties.OnLogSessionStart">
            <summary>
            Events triggers at the start, or the end of a log session
            </summary>
        </member>
        <member name="E:LogUtils.Properties.LogProperties.OnLogSessionFinish">
            <summary>
            Events triggers at the start, or the end of a log session
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.FileLock">
            <summary>
            Ensures thread safety while accessing the log file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.HandleRecord">
            <summary>
            This field contains the last known LogRequest handle state for this LogID, particularly the rejection status, and the reason for rejection of the request
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.LogSessionActive">
            <summary>
            The log file has been created, its initialization process has run successfully, and it isn't adding to stale log file data 
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.MessagesHandledThisSession">
            <summary>
            The amount of messages logged to file, or stored in the WriteBuffer since the last logging session was started
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.PersistentStreamHandles">
            <summary>
            A list of persistent FileStreams known to be open for this log file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.ProcessedWithErrors">
            <summary>
            Indicates that this instance was read from file, but one or more fields could not be processed
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.IsNewInstance">
            <summary>
            A flag that indicates that a low amount of frames (less than or equal to 10) have passed since instance was created
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.SkipStartupRoutine">
            <summary>
            Indicates that the startup routine for this log file should not be run
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.WriteBuffer">
            <summary>
            Contains messages that have passed all validation checks, and are waiting to be written to file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.AccessPeriod">
            <summary>
            The earliest period that the log file may start a new log session through a log event
            It is recommended to keep at the earliest possible write period, or a period that is close to when the log file is used by a mod's logger
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.AllowLogging">
            <summary>
            Should the logging system handle requests targeting this log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.CanBeAccessed">
            <summary>
            A flag that indicates whether a log session can be, or already is established
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ID">
            <summary>
            The LogID associated with the log properties
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.ConsoleIDs">
            <summary>
            List of targeted ConsoleIDs to send requests to when logging to file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.LogSourceName">
            <summary>
            The name of the BepInEx logging source associated with this log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.Version">
            <summary>
            A string representation of the content state. This is useful for preventing user sourced changes from being overwritten by mods
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.IsWriteRestricted">
            <summary>
            A flag, when true, indicates it is not safe to attempt to receive write access, or write directly to the log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.LogsFolderAware">
            <summary>
            When the log file properties are first initialized, the log file can have its path changed to target the Logs folder if it exists, disabled by default
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.LogsFolderEligible">
            <summary>
            A property that informs the utility that the log file should not use the Logs folder
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.Tags">
            <summary>
            An array of value identifiers for a specific log
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.IntroMessage">
            <summary>
            A message that will be logged at the start of a log session
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.OutroMessage">
            <summary>
            A message that will be logged at the end of a log session
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShowIntroTimestamp">
            <summary>
            A flag that indicates whether a timestamp should be logged at the start of a log session
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShowOutroTimestamp">
            <summary>
            A flag that indicates whether a timestamp should be logged at the end of a log session
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ShowLogsAware">
            <summary>
            A flag that controls whether log is allowed to be used when RainWorld.ShowLogs is false
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.BeginLogSession">
            <summary>
            Initiates the routine that applies at the start of a log session. Handle initial file write operations through this process
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.EndLogSession">
            <summary>
            Initiates the routine that applies at the end of a log session
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.NotifyPathChanged">
            <summary>
            Triggers the UtilityEvents.OnPathChanged event for this instance
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.NotifyPendingMove(System.String)">
            <summary>
            Triggers the <see cref="F:LogUtils.Events.UtilityEvents.OnMovePending"/> event
            </summary>
            <param name="movePath">The pending log path for this instance (include filename with extension if filename has changed)</param>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.NotifyPendingMoveAborted">
            <summary>
            Triggers the <see cref="F:LogUtils.Events.UtilityEvents.OnMoveAborted"/> event
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.IDHash">
            <summary>
            The hashcode representing the log filepath at the time of instantiation
            </summary>
            <remarks>This value is intended to be a unique identifier for this LogProperties instance, and will not change even if the file metadata changes</remarks>
        </member>
        <member name="F:LogUtils.Properties.LogProperties.WriteHash">
            <summary>
            The hashcode produced by the write string cached when properties are read from file
            </summary>
            <remarks>If the value remains at zero, it means that the properties instance hasn't been updated</remarks>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.HasModifiedData">
            <summary>
            Checks whether this instance has writeable data that hasn't yet been written to file
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.Equals(LogUtils.Properties.LogProperties)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.HasFilename(System.String,LogUtils.Properties.CompareOptions)">
            <summary>
            Compares a filename against one, or more filename fields controlled by the properties instance
            </summary>
            <remarks>Filename is not case sensitive; file extension is unused</remarks>
            <param name="filename">The filename to compare</param>
            <param name="compareOptions">Represents options for specific filename fields</param>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.HasFilename(System.String,System.String,LogUtils.Properties.CompareOptions)">
            <inheritdoc cref="M:LogUtils.Properties.LogProperties.HasFilename(System.String,LogUtils.Properties.CompareOptions)"/>
            <param name="filename">The filename to compare</param>
            <param name="relativePathNoFile">The filepath to compare. When set to null, the filepath check will be skipped</param>
            <param name="compareOptions">Represents options for specific filename fields</param>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.HasFolderPath(System.String)">
            <summary>
            Compares a folder path to the original, and current folder path fields
            </summary>
            <param name="relativePathNoFile">The path to compare</param>
            <returns>Returns whether a match was found</returns>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.CreateIDHash(System.String,System.String)">
            <summary>
            Creates an identifiable hashcode representation of a filename, and path
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.GetContainingPath(System.String)">
            <summary>
            Resolves a path, or path keyword into a usable log path
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.Filename">
            <summary>
            The filename that will be used in the typical write path for the log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.AltFilename">
            <summary>
            The filename that will be used if the write path is the Logs directory. May be null
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ReserveFilename">
            <summary>
            The filename that will serve as the replacement filename if the alternate filename needs to be renamed due to a conflict
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.CurrentFilename">
            <summary>
            The active filename of the log file (without file extension)
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.CurrentFilePath">
            <summary>
            The active filepath of the log file (with filename)
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.ReplacementFilePath">
            <summary>
            The path to the log file when it has been slated to be replaced or removed
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.CurrentFolderPath">
            <summary>
            The active full path of the directory containing the log file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.FolderPath">
            <summary>
            The full path to the directory containing the log file as recorded from the properties file
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.OriginalFolderPath">
            <summary>
            The path that was first assigned when the log file was first registered
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogProperties.LastKnownFilePath">
            <summary>
            The path of the last known location of the log file
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.GetFallbackFilename">
            <summary>
            Given the last available current filename, and the property assign AltFilename, this method returns the option not represented as the current path
            </summary>
            <returns>The filename that is either the last available current filename, or the alt filename depending on the assignment of CurrentFilename.
            <br>If all options refer to the current path, or the unused path is not defined - this method returns null</br></returns>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.EnsurePathDoesNotConflict">
            <summary>
            Ensures that current file path info is unique for the current log file
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.ChangeFilename(System.String)">
            <summary>
            Allows the filename, or file extension to be changed
            </summary>
            <remarks>This will not initiate a file move, or rename any file</remarks>
            <param name="newFilename">The new filename</param>
            <exception cref="T:System.ArgumentException">The filename is null, empty, or contains invalid characters</exception>
        </member>
        <member name="M:LogUtils.Properties.LogProperties.ChangePath(System.String)">
            <summary>
            Allows the filepath (filename optional) to be changed
            </summary>
            <remarks>This will not initiate a file move, or rename any file</remarks>
            <param name="newPath">The new path</param>
            <exception cref="T:System.ArgumentException">The directory is null, empty, or contains invalid characters</exception>
        </member>
        <member name="F:LogUtils.Properties.LogPropertyData.UnrecognizedFields">
            <summary>
            A subset of the Fields dictionary containing field data not recognized by the utility. This will include all custom field data
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogPropertyData.FieldOrderMismatch">
            <summary>
            Stores a flag describing whether the field state read from file matches the expected field order
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyData.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyData.ToString">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Properties.LogPropertyDataProcessor.Results">
            <summary>
            The result of processing LogPropertyData
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyDataProcessor.Process">
            <summary>
            Processes LogPropertyData into a LogProperties result
            </summary>
        </member>
        <member name="T:LogUtils.Properties.LogPropertyFile">
            <summary>
            A class for reading, or writing to the LogProperties file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.LogPropertyFile.FilePath">
            <summary>
            The full path to the file containing properties for all log files
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyFile.PrepareStream">
            <summary>
            Creates a new filestream if current one is closed, and seeks to the start of the filestream
            </summary>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyFile.RefreshStream">
            <summary>
            Closes and reopens the filestream
            </summary>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.Count">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.Keys">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Properties.LogPropertyStringDictionary.Values">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.Add(System.String)">
            <summary>
            Creates and adds a DictionaryEntry from a formatted property string
            </summary>
            <param name="propertyString">A string with key, and a value separated by ':'</param>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.Add(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.Clear">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.ContainsKey(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.ContainsValue(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.CopyTo(System.Array,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.Remove(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyStringDictionary.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Properties.LogPropertyWriter.Write(LogUtils.Properties.LogProperties[])">
            <summary>
            Writes property data to file. If the content already exists, it is overwritten, if it doesn't exist, it is written at the current stream position.
            </summary>
        </member>
        <member name="P:LogUtils.Properties.PropertyDataController.Tag">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.HasDuplicateFileEntries">
            <summary>
            A flag that indicates that there are duplicate entries in the LogProperties file
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.ForceWriteAll">
            <summary>
            A flag that forces all properties instances to write to file on the next save attempt
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.IsEditGracePeriod">
            <summary>
            The game is within a period of time when ReadOnly can be toggled off for the duration of the period before turning back on at the end of the period
            </summary>
        </member>
        <member name="F:LogUtils.Properties.PropertyDataController.StartupRoutineActive">
            <summary>
            A flag that indicates the log replacement process has started and has yet to finish
            </summary>
        </member>
        <member name="M:LogUtils.Properties.PropertyDataController.GetProperties(LogUtils.Enums.LogID,System.String)">
            <summary>
            Finds the first detected LogProperties instance associated with the given LogID, and relative filepath
            </summary>
            <param name="logID">The LogID to search for</param>
            <param name="relativePathNoFile">The filepath to search for. When set to null, any LogID match will be returned with custom root being prioritized</param>
        </member>
        <member name="M:LogUtils.Properties.PropertyDataController.SetPropertiesFromFile">
            <summary>
            Reads properties data from file and creates LogProperties instances from the data
            </summary>
        </member>
        <member name="M:LogUtils.Properties.PropertyDataController.GetUpdateEntries">
            <summary>
            Returns an array of property instances that have data that needs to be written to file
            </summary>
        </member>
        <member name="M:LogUtils.Properties.PropertyDataController.GetFields">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:LogUtils.Properties.Resources.LogUtils_VersionLoader">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="E:LogUtils.LogsFolder.OnMovePending">
            <summary>
            Event signals that the log directory is about to be moved, or renamed
            </summary>
        </member>
        <member name="E:LogUtils.LogsFolder.OnMoveAborted">
            <summary>
            Event signals that the log directory was unable to be moved, or renamed
            </summary>
        </member>
        <member name="E:LogUtils.LogsFolder.OnMoveComplete">
            <summary>
            Event signals that the log directory has successfully been moved, or renamed
            </summary>
        </member>
        <member name="F:LogUtils.LogsFolder.LOGS_FOLDER_NAME">
            <summary>
            The default directory name
            </summary>
        </member>
        <member name="F:LogUtils.LogsFolder.AvailablePaths">
            <summary>
            A list of valid paths that may contain the log directory
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.ContainingPath">
            <summary>
            The path containing, or selected to contain the log directory
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.CurrentPath">
            <summary>
            The currently selected path (including directory name) of the log directory (whether it exists or not)
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.Name">
            <summary>
            The currently selected directory name
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.Exists">
            <summary>
            Checks that log directory exists at its currently set path
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.IsCurrentPath(System.String)">
            <summary>
            Checks a path against the current log directory path
            </summary>
        </member>
        <member name="P:LogUtils.LogsFolder.IsManagingFiles">
            <summary>
            A flag that indicates whether the log directory contains eligible log files
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.Create">
            <summary>
            Attempts to create a new log directory at the currently set path
            </summary>
            <remarks>This method does nothing when the folder already exists</remarks>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
        </member>
        <member name="M:LogUtils.LogsFolder.Initialize">
            <summary>
            Initializes the log directory path
            </summary>
            <remarks>LogUtils does not create this directory by default</remarks>
        </member>
        <member name="M:LogUtils.LogsFolder.FindLogsDirectory">
            <summary>
            Checks existing path history, and available paths, and returns the first existing directory, or null if none of the directory candidates exist
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.GetContainedLogFiles">
            <summary>
            Returns all registered LogIDs representing log files within the current log directory or otherwise target it as a write path
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.MoveFilesToFolder">
            <summary>
            Moves eligible log files to current log directory
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.RestoreFiles">
            <summary>
            Restores log files that are part of the current log directory to their original folder paths
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.AddToFolder(LogUtils.Properties.LogProperties)">
            <summary>
            Transfers a log file to the Logs folder (when it exists)
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.RemoveFromFolder(LogUtils.Properties.LogProperties)">
            <summary>
            Transfers a log file from the Logs folder (when it exists)
            </summary>
        </member>
        <member name="M:LogUtils.LogsFolder.SetContainingPath(System.String)">
            <summary>
            Targets a directory path to contain a logs folder
            </summary>
            <param name="path">A valid directory path</param>
        </member>
        <member name="M:LogUtils.LogsFolder.SetPath(System.String)">
            <summary>
            Targets a directory path to become the new logs folder
            </summary>
            <remarks>DO NOT set to any directory you don't want moved around</remarks>
            <param name="path">A valid directory path</param>
        </member>
        <member name="M:LogUtils.LogsFolder.PathHistory.Update">
            <summary>
            Appends a new path entry into the path history file
            </summary>
        </member>
        <member name="T:LogUtils.LogsFolder.PathResult">
            <summary>
            The result of a Logs folder path search
            </summary>
        </member>
        <member name="F:LogUtils.LogsFolder.PathResult.Target">
            <summary>
            The result of a the path search
            </summary>
        </member>
        <member name="F:LogUtils.LogsFolder.PathResult.IsResultFromPathHistory">
            <summary>
            The result is associated with an accurate path record
            </summary>
        </member>
        <member name="F:LogUtils.LogWriter.Writer">
            <summary>
            Writer used by default for most Logger implementations
            </summary>
        </member>
        <member name="F:LogUtils.LogWriter.JollyWriter">
            <summary>
            Writer used by default for JollyCoop
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.IsCachedWriter(LogUtils.ILogWriter)">
            <summary>
            Is this writer recognized by the assembly to be available for any Logger implementation to use
            </summary>
        </member>
        <member name="F:LogUtils.LogWriter.ShouldCloseWriterAfterUse">
            <summary>
            A flag that prevents StreamWriter from being closed
            </summary>
        </member>
        <member name="F:LogUtils.LogWriter.WriteHandler">
            <summary>
            Primary process delegate for handling a write request
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.WriteFrom(LogUtils.Requests.LogRequest)">
            <summary>
            Processes a write request
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.WriteFromBuffer(LogUtils.Enums.LogID,System.TimeSpan,System.Boolean)">
            <inheritdoc cref="M:LogUtils.IBufferHandler.WriteFromBuffer(LogUtils.Enums.LogID,System.TimeSpan,System.Boolean)"/>
            <returns>A handle to the scheduled write task</returns>
        </member>
        <member name="M:LogUtils.LogWriter.WriteToFile(LogUtils.Requests.LogRequest)">
            <summary>
            Attempts to write the most recently requested message to file
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.TryAssignWriter(LogUtils.Enums.LogID,System.IO.StreamWriter@)">
            <summary>
            Assigns a writer instance for handling a specified log file
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.AssignWriter(LogUtils.Enums.LogID,System.IO.StreamWriter@)">
            <summary>
            Assigns a writer instance for handling a specified log file
            </summary>
        </member>
        <member name="M:LogUtils.LogWriter.ApplyRules(LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.LogWriter.SendToBuffer(LogUtils.Events.LogRequestEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.ILogWriter.ApplyRules(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Applies rule-defined formatting to a message
            </summary>
        </member>
        <member name="M:LogUtils.ILogWriter.WriteFrom(LogUtils.Requests.LogRequest)">
            <summary>
            Provides a procedure for writing a message to file
            </summary>
        </member>
        <member name="M:LogUtils.IBufferHandler.SendToBuffer(LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Provides a procedure for adding a message to the WriteBuffer
            </summary>
            <remarks>Bypasses the LogRequest system - intended to be used as a fallback message handling process</remarks>
        </member>
        <member name="M:LogUtils.IBufferHandler.WriteFromBuffer(LogUtils.Enums.LogID,System.TimeSpan,System.Boolean)">
            <summary>
            Attempts to write content from the message buffer to file after a specified amount of time
            </summary>
            <remarks>Default behavior: Wait time will double on each failed attempt to write to file (up to a maximum of 5000 ms)</remarks>
            <param name="logFile">The file that contains the message buffer</param>
            <param name="waitTime">The initial time to wait before writing to file (when set to zero, write attempt will be immediate)</param>
            <param name="respectBufferState">Allow the buffer state to determine when to make a write attempt</param>
        </member>
        <member name="P:LogUtils.MessageBuffer.IsBuffering">
            <summary>
            When true, the buffer will be added to instead of writing to file on handling a write request
            </summary>
        </member>
        <member name="T:LogUtils.MissingAttributeException">
            <summary>
            Exception is thrown when an required attribute is not found
            </summary>
        </member>
        <member name="T:LogUtils.PatcherLogEventProcessor">
            <summary>
            Static class responsible for processing log event data stored by VersionLoader, and logging it to file
            </summary>
        </member>
        <member name="M:LogUtils.PatcherLogEventProcessor.GetEventListener">
            <summary>
            Accesses and returns the event listener containing unhandled patcher log events
            </summary>
            <returns>Returns a found listener, otherwise null</returns>
        </member>
        <member name="M:LogUtils.PatcherLogEventProcessor.GetEvents(BepInEx.Logging.ILogListener)">
            <summary>
            Extracts log event data from event listener object
            </summary>
        </member>
        <member name="P:LogUtils.PersistenceManager.Tag">
            <inheritdoc/>
        </member>
        <member name="E:LogUtils.PersistenceManager.OnHandleDisposed">
            <summary>
            Called whenever a PersistentFileHandle is disposed
            </summary>
        </member>
        <member name="T:LogUtils.PersistentFileHandle">
            <summary>
            A mod friendly class for handling persistent file stream operations 
            </summary>
        </member>
        <member name="P:LogUtils.PersistentFileHandle.IsClosed">
            <summary>
            Gets whether the underlying filestream has been closed
            </summary>
        </member>
        <member name="F:LogUtils.PersistentFileHandle.Lifetime">
            <summary>
            A managed representation of the time remaining before filestream is disposed in milliseconds
            </summary>
        </member>
        <member name="F:LogUtils.PersistentFileHandle.Stream">
            <summary>
            The underlying filestream if it exists, null otherwise. This stream is always active when the file is present 
            </summary>
            <remarks>Please do not close the stream. Interrupt and resume the stream instead</remarks>
        </member>
        <member name="F:LogUtils.PersistentFileHandle.resumeHandle">
            <summary>
            Contains a reference to the handle responsible for reopening the FileStream after interruption
            </summary>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.InterruptStream">
            <summary>
            Closes the stream. Mod should resume stream when file operations are finished
            </summary>
        </member>
        <member name="F:LogUtils.PersistentFileHandle.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.PersistentFileHandle"/>
            </summary>
            <param name="disposeState">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.BeginDispose(System.Boolean)">
            <summary>
            Dispose logic that must run at the start of a dispose request
            </summary>
            <inheritdoc cref="M:LogUtils.PersistentFileHandle.Dispose(System.Boolean)" select="param"/>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.EndDispose(System.Boolean)">
            <summary>
            Dispose logic that must run at the end of a dispose request
            </summary>
            <inheritdoc cref="M:LogUtils.PersistentFileHandle.Dispose(System.Boolean)" select="param"/>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.Dispose">
            <inheritdoc cref="M:LogUtils.PersistentFileHandle.Dispose(System.Boolean)"/>
        </member>
        <member name="M:LogUtils.PersistentFileHandle.Finalize">
            <summary/>
        </member>
        <member name="M:LogUtils.PersistentLogFileHandle.BeginDispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.PersistentLogFileHandle.EndDispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.PersistentLogFileWriter.Flush">
            <summary>
            Flushes the stream buffer to file
            </summary>
            <exception cref="T:System.ObjectDisposedException">The underlying stream element for this instance has been disposed of</exception>
        </member>
        <member name="M:LogUtils.PersistentLogFileWriter.SetStreamFromHandle">
            <summary>
            Injects file handle stream into the base StreamWriter
            </summary>
        </member>
        <member name="F:LogUtils.PersistentLogFileWriter.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.PersistentLogFileWriter.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.PersistentLogFileWriter"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.PersistentLogFileWriter.Finalize">
            <summary/>
        </member>
        <member name="T:LogUtils.Policy.CachedConfigEntry`1">
            <summary>
            ConfigEntry wrapper class
            </summary>
            <remarks>Provides an extra class controlled place to store data values that wont be accessed, or modified upon a config save, or reload operation</remarks>
        </member>
        <member name="P:LogUtils.Policy.CachedConfigEntry`1.Config">
            <summary>
            The config instance that contains this entry
            </summary>
        </member>
        <member name="E:LogUtils.Policy.CachedConfigEntry`1.ValueChanged">
            <summary>
            Event invoked when value has changed from its last set value
            </summary>
        </member>
        <member name="P:LogUtils.Policy.CachedConfigEntry`1.Value">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Policy.CachedConfigEntry`1.BoxedValue">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.Policy.CachedConfigEntry`1.IsMarked">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.#ctor(BepInEx.Configuration.ConfigEntry{`0})">
            <summary>
            Creates a new <see cref="T:LogUtils.Policy.CachedConfigEntry`1"/> instance
            </summary>
            <param name="baseEntry">The config entry to wrap around</param>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.Mark">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.Unmark">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.ResetToDefault(LogUtils.Policy.SaveOption)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.SetValue(`0,LogUtils.Policy.SaveOption)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.SetValueFromBase">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.SetValueSilently(`0,LogUtils.Policy.SaveOption)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Policy.CachedConfigEntry`1.UpdateBaseEntry">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Policy.CachedConfigEntry`1.ValueChangedEventHandler">
            <summary>
            Method signature for ValueChanged event
            </summary>
            <param name="entry">The changed entry</param>
            <param name="oldValue">The last value of the entry</param>
        </member>
        <member name="P:LogUtils.Policy.DebugPolicy.DebugMode">
            <summary>
            Enables, or disables LogUtils development build
            </summary>
        </member>
        <member name="P:LogUtils.Policy.DebugPolicy.ShowDebugLog">
            <summary>
            Enables, or disables the LogUtils debug log file
            </summary>
        </member>
        <member name="P:LogUtils.Policy.DebugPolicy.ShowActivityLog">
            <summary>
            Enables, or disables the LogUtils activity log file
            </summary>
        </member>
        <member name="P:LogUtils.Policy.DebugPolicy.AssertsEnabled">
            <summary>
            Affects whether test cases apply, or LogUtils based assert statements have an effect
            </summary>
        </member>
        <member name="M:LogUtils.Policy.DebugPolicy.UpdateAllowConditions">
            <summary>
            Activate, or deactivate development build specific log files based on several criteria
            </summary>
        </member>
        <member name="T:LogUtils.Policy.IConfigEntry">
            <summary>
            Exposes members for setting, or updating a config value
            </summary>
        </member>
        <member name="P:LogUtils.Policy.IConfigEntry.IsMarked">
            <summary>
            Indicates that an entry has been marked for special handling (such as during save operations)
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.Mark">
            <summary>
            Marks an entry for special handling (such as during save operations)
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.Unmark">
            <summary>
            Unmarks an entry for special handling (such as during save operations)
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.ResetToDefault(LogUtils.Policy.SaveOption)">
            <summary>
            Assigns the default value to the value cache
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.SetValueFromBase">
            <summary>
            Assigns value stored in the base config entry in the value cache
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry.UpdateBaseEntry">
            <summary>
            Updates config entry with cached data
            </summary>
        </member>
        <member name="T:LogUtils.Policy.IConfigEntry`1">
            <inheritdoc cref="T:LogUtils.Policy.IConfigEntry"/>
        </member>
        <member name="P:LogUtils.Policy.IConfigEntry`1.Value">
            <summary>
            The current config value
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry`1.SetValue(`0,LogUtils.Policy.SaveOption)">
            <summary>
            Assigns a new value to value cache
            </summary>
        </member>
        <member name="M:LogUtils.Policy.IConfigEntry`1.SetValueSilently(`0,LogUtils.Policy.SaveOption)">
            <summary>
            Assigns a new value to value cache without throwing a value changed event
            </summary>
        </member>
        <member name="P:LogUtils.Policy.LogRequestPolicy.ShowRejectionReasons">
            <summary>
            A flag that affects whether RejectionReasons are logged to file when they occur
            </summary>
        </member>
        <member name="T:LogUtils.Policy.PatcherPolicy">
            <summary>
            Global LogUtils related setting flags pertaining to Patcher behavior
            </summary>
        </member>
        <member name="P:LogUtils.Policy.PatcherPolicy.HasAskedForPermission">
            <summary>
            Indicates whether the user should be prompted for permission to deploy the patcher
            </summary>
        </member>
        <member name="P:LogUtils.Policy.PatcherPolicy.ShouldDeploy">
            <summary>
            Indicates that the patcher is able to be deployed
            </summary>
        </member>
        <member name="P:LogUtils.Policy.PatcherPolicy.ShowPatcherLog">
            <summary>
            Indicates that extra information should be provided in a separate log file
            </summary>
        </member>
        <member name="P:LogUtils.Policy.TestCasePolicy.PreferExpectationsAsFailures">
            <summary>
            A flag that affects whether failed expectations qualify as a failure result
            </summary>
        </member>
        <member name="P:LogUtils.Policy.TestCasePolicy.FailuresAreAlwaysReported">
            <summary>
            A flag that affects whether all failure results are reported, or only the unexpected ones
            </summary>
        </member>
        <member name="P:LogUtils.Policy.TestCasePolicy.ReportVerbosity">
            <summary>
            This field affects the level of detail revealed in the test case report
            </summary>
        </member>
        <member name="T:LogUtils.Policy.UtilityConfig">
            <summary>
            A container for utility settings, and user preferences
            </summary>
        </member>
        <member name="F:LogUtils.Policy.UtilityConfig.CONFIG_PATH">
            <summary>
            Path to the LogUtils core config file
            </summary>
        </member>
        <member name="P:LogUtils.Policy.UtilityConfig.Item(BepInEx.Configuration.ConfigDefinition)">
            <summary>
            Retrieves a cached config entry
            </summary>
        </member>
        <member name="P:LogUtils.Policy.UtilityConfig.Item(System.String,System.String)">
            <inheritdoc cref="P:LogUtils.Policy.UtilityConfig.Item(BepInEx.Configuration.ConfigDefinition)"/>
        </member>
        <member name="M:LogUtils.Policy.UtilityConfig.ReloadCache">
            <summary>
            Assigns values stored in the config to their associated policy
            </summary>
        </member>
        <member name="M:LogUtils.Policy.UtilityConfig.ResetToDefaults(LogUtils.Policy.SaveOption)">
            <summary>
            Assigns the default value for all config entries
            </summary>
        </member>
        <member name="M:LogUtils.Policy.UtilityConfig.TrySave">
            <summary>
            Process safe method of saving entry values to the config file
            </summary>
        </member>
        <member name="M:LogUtils.Policy.UtilityConfig.TryReload">
            <summary>
            Process safe method of reading entry values from the config file
            </summary>
            <remarks>This method does not affect the value cache. To assign values to cache, also invoke <see cref="M:LogUtils.Policy.UtilityConfig.ReloadCache"/>.</remarks>
        </member>
        <member name="T:LogUtils.Policy.SaveOption">
            <summary>
            Represents options for saving config entries to file
            </summary>
        </member>
        <member name="T:LogUtils.QueueLogWriter">
            <summary>
            This writer class imitates logging functionality exhibited by JollyCoop logger mainly in that all log messages are
            placed in a queue and logged at the end of a Rain World frame
            </summary>
        </member>
        <member name="M:LogUtils.QueueLogWriter.WriteToFile(LogUtils.Requests.LogRequest)">
            <summary>
            Operation is not supported by this write implementation
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:LogUtils.QueueLogWriter.Flush">
            <summary>
            Writes all messages in the queue to file
            </summary>
        </member>
        <member name="F:LogUtils.RainWorldDirectory.FolderTree">
            <summary>
            Hardcoded tree of directory names associated with a vanilla Rain world installation 
            </summary>
        </member>
        <member name="F:LogUtils.RainWorldDirectory.customRoot">
            <summary>
            Shortcut accessor for StreamingAssets path
            </summary>
        </member>
        <member name="M:LogUtils.RainWorldDirectory.GetDirectoryCategory(System.String)">
            <summary>
            Evaluates a directory path, determining whether it belongs to the game, mod sourced, or unknown, and returns the result
            </summary>
        </member>
        <member name="F:LogUtils.PathCategory.NotRooted">
            <summary>
            Path is not part of RainWorld folder
            </summary>
        </member>
        <member name="F:LogUtils.PathCategory.Game">
            <summary>
            Path points to a game-installed directory, or is part of mergedmods directory
            </summary>
        </member>
        <member name="F:LogUtils.PathCategory.ModRequiredFolder">
            <summary>
            Path points to a top-level directory inside the mods directory, or similar directory for mods, or a required mod subdirectory
            </summary>
        </member>
        <member name="F:LogUtils.PathCategory.ModSourced">
            <summary>
            Path is not a game-installed directory, not associated with a mod's directory structure, and is defined within the Rain World direcotry or a mod-specific directory
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LinkedLogRequestCollection.SortRequests">
            <summary>
            Returns an enumerable that sorts LogRequests by LogID (by value and path)
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LinkedLogRequestCollection.GroupRequests">
            <summary>
            Returns an enumerable that sorts LogRequests by LogID (by value and path) into partitioned groups for each different kind
            </summary>
        </member>
        <member name="T:LogUtils.Requests.LogRequest">
            <summary>
            A class for storing log details until a logger is available to process the request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.UNABLE_TO_RETRY_RANGE">
            <summary>
            Rejection codes up to and including this value are not recoverable. A LogRequest that is rejected in this range will not be handled again
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.Host">
            <summary>
            The log handler that has taken responsibility for handling the write process for this request
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequest.IsCompleteOrInvalid">
            <summary>
            Request has been handled, and no more attempts to process the request should be made
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.LogCallback">
            <summary>
            This field is primarily used by <see cref="T:LogUtils.Requests.LogRequestHandler"/> to communicate with unregistered loggers 
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.Sender">
            <summary>
            The log handler that was responsible for submitting the request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequest.Submitted">
            <summary>
            Whether this request has once been submitted through the log request system
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequest.IsFileRequest">
            <summary>
            A flag indicating whether the request targets a log file
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequest.IsTargetingConsole">
            <summary>
            Indicates that a ConsoleID is the current target for this request (of which there may be multiple targets)
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.#ctor(LogUtils.Requests.RequestType,LogUtils.Events.LogRequestEventArgs)">
            <summary>
            Constructs a new LogRequest instance
            </summary>
            <param name="type">The identifying request category (affects how request is handled)</param>
            <param name="data">Data used to construct a log message</param>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.ResetTarget">
            <summary>
            Reset the console target status back to its value set on construction
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.NotifyComplete(LogUtils.Enums.ConsoleID)">
            <summary>
            Notify that the specified ConsoleID no longer needs to be processed
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.NotifyComplete(System.Collections.Generic.IEnumerable{LogUtils.Enums.ConsoleID})">
            <summary>
            Notify that a collection of ConsoleIDs no longer needs to be processed
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.NotifyOnChange">
            <summary>
            Raises an event when the LogRequest status, or the rejection reason changes. Currently does not raise when ResetStatus is invoked
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="T:LogUtils.Requests.LogRequest.Factory">
            <summary>
            A class for constructor helper methods, and method signatures for creating LogRequests
            </summary>
        </member>
        <member name="T:LogUtils.Requests.LogRequest.Factory.Callback">
            <summary>
            A delegate signature for creating a LogRequest instance
            </summary>
            <param name="requestType">The type of LogRequest to make</param>
            <param name="target">The log destination identifier</param>
            <param name="category">The logging context to use</param>
            <param name="messageObj">The object representation of the logged message</param>
            <param name="shouldFilter">Whether a filter should be applied when message is handled</param>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.Factory.Create(LogUtils.Requests.RequestType,LogUtils.Enums.ILogTarget,LogUtils.Enums.LogCategory,System.Object,System.Boolean)">
            <summary>
            Constructs a new LogRequest instance
            </summary>
            <inheritdoc cref="T:LogUtils.Requests.LogRequest.Factory.Callback" section="param"/>
        </member>
        <member name="M:LogUtils.Requests.LogRequest.Factory.CreateDataCallback(System.EventArgs)">
            <summary>
            Creates a callback that will create a new LogRequest with the provided event data when invoked
            </summary>
        </member>
        <member name="T:LogUtils.Requests.RejectionReason">
            <summary>
            Describes the reason why a LogRequest could not be handled
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.None">
            <summary>
            Default state
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.AccessDenied">
            <summary>
            Logger available to handle the log request is private
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.LogDisabled">
            <summary>
            LogID is not enabled, Logger is not accepting logs, or LogID is ShowLogs aware and ShowLogs is false
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.FailedToWrite">
            <summary>
            Attempt to log failed due to an error
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.ExceptionAlreadyReported">
            <summary>
            Attempt to log the same Exception two, or more times to the same log file
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.FilterMatch">
            <summary>
            Attempt to log a string that is stored in FilteredStrings
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.PathMismatch">
            <summary>
            The path information for the LogID accepted by the logger does not match the path information of the LogID in the request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.NotAllowedToHandle">
            <summary>
            A log request was sent to a logger that cannot handle the request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.WaitingOnOtherRequests">
            <summary>
            Attempt to handle log request was prevented, because an earlier request could not be handled
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.LogUnavailable">
            <summary>
            No logger is available that accepts the LogID, or the logger accepts the LogID, but enforces a build period on the log file that is not yet satisfied
            </summary>
        </member>
        <member name="F:LogUtils.Requests.RejectionReason.ShowLogsNotInitialized">
            <summary>
            Attempt to log to a ShowLogs aware log before ShowLogs is initialized
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.RequestProcessLock">
            <summary>
            This lock object marshals control over submission of LogRequests, and processing requests stored in UnhandledRequests. When there is a need to
            process LogRequests directly from UnhandledRequests, it is recommended to use this lock object to achieve thread safety
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequestHandler.AvailableLoggers">
            <summary>
            A list of loggers available to handle local or remote log requests
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.UnhandledRequests">
            <summary>
            Contains LogRequest objects that are submitted and waiting to be handled
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.HandleOnNextAvailableFrame">
            <summary>
            Contains LogRequest objects that need to be submitted on the next available frame
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequestHandler.CurrentRequest">
            <summary>
            The request currently being handled. The property is cleared when request has been properly handled, or the request has been swapped out to another request
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequestHandler.PendingRequest">
            <summary>
            The latest request that has yet to be handled
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.CheckForHandledRequests">
            <summary>
            A flag that can be used to do a full check to discard handled, or no longer valid requests
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.RecursionCheckCounter">
            <summary>
            A counter used to prevent recursive LogRequest submissions
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.BeginCriticalSection">
            <summary>
            Acquires the lock necessary for entering a critical state pertaining to LogRequest handling
            </summary>
            <returns>A disposable scope object purposed for leaving a critical state</returns>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.EndCriticalSection">
            <summary>
            Releases the lock used to enter a critical state
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.ConsumeRequestCounter(LogUtils.Enums.LogID)">
            <summary>
            Consumes a request counter for the specified log file if a counter is present
            </summary>
            <returns>A counter value was detected and consumed</returns>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.GetRequestFromAPI(LogUtils.Enums.LogID,System.Boolean)">
            <summary>
            Invoked by external API callbacks to get a request sent through the LogUtils API, and processed by the external API
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.Submit(LogUtils.Requests.LogRequest,System.Boolean)">
            <summary>
            Submit a request - Treated as an active pending log request unless the request itself did not qualify for submission. A request must meet the following conditions: 
            <br>I. No rejection reasons were found during initial processing of the request</br>
            <br>II. Under the situation that there is a reason to reject, that reason is not severe enough to prevent future attempts to process the request</br>
            <br>Submitted request may be retrieved through CurrentRequest under the above conditions, or from the return value</br>
            </summary>
            <param name="request">The request to be processed</param>
            <param name="handleSubmission">Whether a log attempt should be made on the request</param>
            <returns>This method returns the same request given to it under any condition. The return value is more reliable than checking CurrentRequest, which may be null</returns>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.Register(LogUtils.ILogHandler)">
            <summary>
            Enables log handler communication with the log request system
            </summary>
            <remarks>Registration is required to use the log request system for both local and remote requests</remarks>
            <exception cref="T:System.InvalidOperationException">The logger is not allowed to be registered</exception>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.Unregister(LogUtils.ILogHandler)">
            <summary>
            Disables log handler communication with the log request system
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.ProcessRequests(LogUtils.Enums.LogID)">
            <summary>
            Attempts to handle all unhandled log requests belonging to a single LogID in the order they were submitted
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.ProcessRequests">
            <summary>
            Attempts to handle unhandled requests 
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.RequestMayBeCompleteOrInvalid(LogUtils.Requests.LogRequest)">
            <summary>
            Clean up process for requests that need to be removed from the request handling system
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.DiscardStatus.Keep">
            <summary>
            Don't discard
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.DiscardStatus.Soft">
            <summary>
            Remove from CurrentRequest
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.DiscardStatus.Hard">
            <summary>
            Remove from UnhandledRequests and CurrentRequest
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.DiscardHandledRequests">
            <summary>
            Checks all requests stored in UnhandledRequests, removing any that have been completed, or are no longer valid
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestHandler.SanitizeCurrentRequest">
            <summary>
            Ensures that CurrentRequest represents a pending unrejected request
            </summary>
        </member>
        <member name="F:LogUtils.Requests.LogRequestHandler.LoggerSelection.AccessTarget">
            <summary>
            The access specification used to assign the handler
            </summary>
        </member>
        <member name="P:LogUtils.Requests.LogRequestRecord.LastUpdated">
            <summary>
            The last time the reason was updated (defaults to 0 prior to the first update)
            </summary>
        </member>
        <member name="M:LogUtils.Requests.LogRequestRecord.Reset">
            <summary>
            Resets the state back to original values
            </summary>
        </member>
        <member name="T:LogUtils.Requests.Validation.GameRequestValidator">
            <summary>
            Used to validate game-specific log requests
            </summary>
        </member>
        <member name="M:LogUtils.Requests.Validation.RequestValidator.ShowLogsValidation(LogUtils.Enums.LogID)">
            <summary>
            Checks that the ShowLogs property is applicable to the provided LogID, and returns the applicable RejectionReason when it does
            </summary>
        </member>
        <member name="M:LogUtils.Requests.Validation.RequestValidator.ShowLogsViolation">
            <summary>
            Gets the applicable RejectionReason for a ShowLogs aware log request
            </summary>
        </member>
        <member name="M:LogUtils.Requests.Validation.IRequestValidator.GetResult(LogUtils.Requests.LogRequest)">
            <summary>
            Evaluates a LogRequest object
            </summary>
            <param name="request">The request to evaluate</param>
            <returns>The processed handle state based on logger specific validation rules</returns>
        </member>
        <member name="T:LogUtils.RWInfo">
            <summary>
            A static class for storing Rain World associated data
            </summary>
        </member>
        <member name="F:LogUtils.RWInfo.SHOW_LOGS_ACTIVE_PERIOD">
            <summary>
            A period during which it is safe to evaluate RainWorld.ShowLogs because it is guaranteed to be initialized at this time
            </summary>
        </member>
        <member name="F:LogUtils.RWInfo.STARTUP_CUTOFF_PERIOD">
            <summary>
            The period during which it becomes too late to initiate the startup routine (such as for replacing log files)
            </summary>
        </member>
        <member name="F:LogUtils.RWInfo.LastReportedException">
            <summary>
            Dictionary of last reported errors logged to a specific log file
            </summary>
        </member>
        <member name="P:LogUtils.RWInfo.MergeProcessComplete">
            <summary>
            A flag indicating merge folder is ready to access
            TODO: Refine this check to be more accurate
            </summary>
        </member>
        <member name="F:LogUtils.RWInfo.LatestSetupPeriodReached">
            <summary>
            The latest point in the initialization process that Rain World has reached since the application began
            </summary>
            <remarks>Do not modify directly, use NotifyOnPeriodReached instead</remarks>
        </member>
        <member name="T:LogUtils.SharedDataHandler">
            <summary>
            This class maintains a list of data inside of a MonoBehavior for easy access from multiple mod sources
            </summary>
        </member>
        <member name="P:LogUtils.SharedDataHandler.Tag">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.SharedDataHandler.Find(System.Type,System.String)">
            <summary>
            Finds the first IShareable with a given tag under the specified type
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
            <param name="tag">The search tag</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.FindAll(System.Type,System.String)">
            <summary>
            Finds all IShareable instances with a given tag under the specified type
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
            <param name="tag">The search tag</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.RegisterData(LogUtils.IShareable)">
            <summary>
            Assigns an IShareable to the data list of its own type
            </summary>
            <param name="data">Data to store under a registered type</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.RegisterData(System.Type,LogUtils.IShareable)">
            <summary>
            Assigns an IShareable to the data list of the specified type
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
            <param name="data">Data to store under a registered type</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.RegisterType(System.Type)">
            <summary>
            Assigns a list for data of the specified type
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.ReplaceData(System.Type,LogUtils.IShareable)">
            <summary>
            Assigns an IShareable to the data list of the specified type, existing data will be overwritten
            </summary>
            <param name="type">The desired type to associate IShareables with (e.g. Shareable booleans can be registered under the boolean type</param>
            <param name="data">Data to store under a registered type</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.GetField``1(System.String,``0)">
            <summary>
            Retrieves a registered SharedField instance with the specified tag, and optional initial value
            </summary>
            <typeparam name="T">The type of data that will be stored in the field</typeparam>
            <param name="tag">The search tag</param>
            <param name="initValue">A value to be optionally set on creation of the SharedField</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.GetField``1(System.Type,System.String,``0)">
            <summary>
            Retrieves a registered SharedField instance with the specified tag, and optional initial value
            </summary>
            <typeparam name="T">The type of data that will be stored in the field</typeparam>
            <param name="tag">The search tag</param>
            <param name="type">The desired type to associate IShareables with</param>
            <param name="initValue">A value to be optionally set on creation of the SharedField</param>
        </member>
        <member name="M:LogUtils.SharedDataHandler.GetOrAssign(LogUtils.IShareable)">
            <summary>
            Retrieves an IShareable with an existing data tag, or stores, and returns the given one if it does not yet exist
            This method uses the data type to retrieve the data
            </summary>
            <param name="data">The data to check for, or retrieve</param>
            <returns>The associated shared data object</returns>
        </member>
        <member name="M:LogUtils.SharedDataHandler.GetFields">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.SharedField`1.Tag">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.SharedField`1.CheckTag(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:LogUtils.IShareable.Tag">
            <summary>
            An identifying string used for lookup and storage of objects through a SharedDataHandler
            </summary>
        </member>
        <member name="M:LogUtils.IShareable.CheckTag(System.String)">
            <summary>
            Checks that a tag matches a given input string
            </summary>
            <param name="tag">The input to compare to</param>
            <returns>Whether a match has been found</returns>
        </member>
        <member name="T:LogUtils.Templates.LoggerTemplate">
            <summary>
            Illustrates the standardized method order implementation of the ILogger interface
            </summary>
        </member>
        <member name="T:LogUtils.Templates.LoggingAdapter">
            <summary>
            An example class demonstration on how to encapsulate, and use a LogUtils instance without the assembly being aware that LogUtils is available at runtime.
            A fallback implementation is used in the case that LogUtils is unavailable. Be aware that a fallback implementation should bear the same responsibilities
            associated with maintaining a custom log file in the situation that LogUtils cannot perform such functions for the user.
            </summary>
        </member>
        <member name="M:LogUtils.Templates.LoggingAdapter.LogUtilsAccess.UnsafeAccess">
            <summary>
            Attempt to initialize LogUtils assembly
            </summary>
            <exception cref="T:System.TypeLoadException">An assembly dependency is unavailable, or is of the wrong version</exception>
        </member>
        <member name="T:LogUtils.Templates.LoggingAdapter.LogUtilsAccess.LogUtilsAdapter">
            <summary>
            Wrapper class for a LogUtils logger instance
            </summary>
        </member>
        <member name="M:LogUtils.Templates.LoggingAdapter.CreateLogger">
            <summary>
            Creates a logger employing a safe encapsulation technique
            </summary>
        </member>
        <member name="T:LogUtils.Templates.IMyLogger">
            <summary>
            Interface provides a safe boundary with and a compatible interface for a LogUtils logger instance
            </summary>
        </member>
        <member name="P:LogUtils.Threading.FileLock.FileContext">
            <summary>
            The associated log file context
            </summary>
        </member>
        <member name="P:LogUtils.Threading.FileLock.LastActivity">
            <summary>
            The last known file change/access activity that resulted in acquiring the file lock  
            </summary>
        </member>
        <member name="T:LogUtils.Threading.Lock">
            <summary>
            A wrapper class for a locked object implementation. API exposes a lockable Scope designed to work with with 'using' keyword, does not work well with 'lock'
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Lock.ActiveCount">
            <summary>
            The number of acquired locks yet to be released
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Lock.Context">
            <summary>
            Information assigned to identify the lock instance
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Lock.IsAcquiredByCurrentThread">
            <summary/>
        </member>
        <member name="F:LogUtils.Threading.Lock.SuppressNextRelease">
            <summary>
            Suppresses the next Release attempt made on this lock 
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Lock.Scope.Dispose">
            <summary>
            Releases a lock acquired by the calling thread
            </summary>
            <exception cref="T:System.Threading.SynchronizationLockException">The calling thread does not have any active locks to release</exception>
        </member>
        <member name="T:LogUtils.Threading.Lock.ContextProvider">
            <summary>
            A provided delegate used to provide a context on demand
            </summary>
        </member>
        <member name="P:LogUtils.Threading.LogTasker.ThreadID">
            <summary>
            The managed thread ID of the LogTasker thread
            </summary>
        </member>
        <member name="P:LogUtils.Threading.LogTasker.WaitingOnSignal">
            <summary>
            Task thread is waiting on another thread to signal it to continue
            </summary>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.StartBatching">
            <summary>
            Allows tasks to be scheduled in an uninterrupted sequence
            </summary>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.Schedule(LogUtils.Threading.Task)">
            <summary>
            Schedules a task to run on a background thread
            </summary>
            <param name="task">Task to run</param>
            <exception cref="T:System.ArgumentNullException">Exception that throws when passing in a null task</exception>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.ScheduleBefore(LogUtils.Threading.Task,LogUtils.Threading.Task)">
            <summary>
            Schedules a task to run before another task on a background thread
            </summary>
            <param name="task">Task to run</param>
            <param name="taskOther">Task that should run after</param>
            <exception cref="T:LogUtils.Threading.TaskNotFoundException">Exception that throws if the targeted task does not exist</exception>
            <exception cref="T:System.ArgumentNullException">Exception that throws when passing in a null task</exception>
            <exception cref="T:System.ArgumentException">Exception that throws if the task instances are the same</exception>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.ScheduleAfter(LogUtils.Threading.Task,LogUtils.Threading.Task)">
            <summary>
            Schedules a task to run after another task on a background thread
            </summary>
            <param name="task">Task to run</param>
            <param name="taskOther">Task that should run before</param>
            <exception cref="T:LogUtils.Threading.TaskNotFoundException">Exception that throws if the targeted task does not exist</exception>
            <exception cref="T:System.ArgumentNullException">Exception that throws when passing in a null task</exception>
            <exception cref="T:System.ArgumentException">Exception that throws if the task instances are the same</exception>
        </member>
        <member name="M:LogUtils.Threading.LogTasker.EndTask(LogUtils.Threading.Task,System.Boolean)">
            <summary>
            Sets the task state to Aborted, or Complete
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Task.Handle">
            <summary>
            Useful for awaiting on this task asynchronously
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Task.WaitTimeInterval">
            <summary>
            The time to wait in between task runs
            </summary>
        </member>
        <member name="P:LogUtils.Threading.Task.HasRunOnce">
            <summary>
            A flag that indicates whether task has run at least once
            </summary>
        </member>
        <member name="F:LogUtils.Threading.Task.IsContinuous">
            <summary>
            When true, task will run more than one time, instead of once
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.#ctor(System.Action,System.Int32)">
            <summary>
            Constructs a Task object - Pass this object into LogTasker to run a task on a background thread
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.#ctor(System.Action,System.TimeSpan)">
            <summary>
            Constructs a Task object - Pass this object into LogTasker to run a task on a background thread
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.#ctor(LogUtils.Threading.TaskProvider,System.TimeSpan)">
            <summary>
            Constructs a Task object - Pass this object into LogTasker to run a task on a background thread
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.GetAsyncHandle">
            <summary>
            Get an awaitable handle that will complete when the task ends
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.RunOnce">
            <summary>
            Runs the task a single time
            </summary>
            <exception cref="T:System.InvalidOperationException">The task is already completed, or canceled OR the task is running on another thread, and task concurrency is not allowed</exception>
        </member>
        <member name="M:LogUtils.Threading.Task.RunOnceAndEnd(System.Boolean)">
            <summary>
            Runs the task a single time before terminating
            </summary>
            <param name="force">Should this task bypass the scheduling process (in the case of an unsubmitted task)</param>
            <exception cref="T:System.InvalidOperationException">The task is already completed, or canceled OR the task is running on another thread, and task concurrency is not allowed</exception>
            <exception cref="T:LogUtils.Threading.InvalidStateException">The state has failed, or has been marked as complete</exception>
        </member>
        <member name="M:LogUtils.Threading.Task.Cancel">
            <summary>
            Task will no longer run - asynchronous operations that support cancel operations will be notified
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.Complete">
            <summary>
            Task will no longer run - asynchronous operations started by the task may still continue
            </summary>
        </member>
        <member name="M:LogUtils.Threading.Task.RunBefore(LogUtils.Threading.Task)">
            <summary>
            Positions this task before another task in the task run list
            </summary>
            <param name="otherTask">The task that shall run after</param>
            <exception cref="T:LogUtils.Threading.TaskNotFoundException">Exception that throws if the targeted task does not exist</exception>
            <exception cref="T:System.ArgumentException">Exception that throws if the task instances are the same</exception>
        </member>
        <member name="M:LogUtils.Threading.Task.RunAfter(LogUtils.Threading.Task)">
            <summary>
            Positions this task after another task in the task run list
            </summary>
            <param name="otherTask">The task that shall run before</param>
            <exception cref="T:LogUtils.Threading.TaskNotFoundException">Exception that throws if the targeted task does not exist</exception>
            <exception cref="T:System.ArgumentException">Exception that throws if the task instances are the same</exception>
        </member>
        <member name="M:LogUtils.Threading.Task.WaitUntil(System.Func{System.Boolean},System.Int32,System.Int32)">
            <summary>
            Blocks until condition is true or timeout occurs.
            </summary>
            <param name="condition">The break condition</param>
            <param name="frequency">The frequency at which the condition will be checked</param>
            <param name="timeout">The timeout in milliseconds</param>
            <exception cref="T:System.TimeoutException">Timeout expired</exception>
        </member>
        <member name="P:LogUtils.Threading.TaskHandle.IsValid">
            <summary>
            
            </summary>
        </member>
        <member name="F:LogUtils.Threading.TaskHandle.Task">
            <summary>
            The asynchronous execution task
            </summary>
        </member>
        <member name="F:LogUtils.Threading.TaskHandle.Owner">
            <summary>
            The task that this handle belongs to
            </summary>
        </member>
        <member name="F:LogUtils.Threading.TaskHandle.CancellationToken">
            <summary>
            An object that LogTasker uses to request early termination of a task
            </summary>
        </member>
        <member name="F:LogUtils.Threading.TaskHandle.accessCount">
            <summary>
            The number of unreleased references to this instance
            </summary>
        </member>
        <member name="M:LogUtils.Threading.TaskHandle.Dispose">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.Threading.TaskHandle"/>
            </summary>
        </member>
        <member name="T:LogUtils.Threading.TaskNotFoundException">
            <summary>
            An exception that is thrown when a Task is expected to be found, but the Task could not be located
            </summary>
        </member>
        <member name="F:LogUtils.Threading.ThreadSafeWorker.UseEnumerableWrapper">
            <summary>
            A flag that indicates whether locks should be extracted from the provided enumerable, and placed into an array before work starts
            </summary>
            <remarks>May be set to false if underlying enumerable is unlikely to be modified during work</remarks>
        </member>
        <member name="F:LogUtils.TimedLogWriter.WriteTask">
            <summary>
            This task handles writing to file, on a fixed interval off the main thread
            </summary>
        </member>
        <member name="F:LogUtils.TimedLogWriter.INTERVAL_DEFAULT">
            <summary>
            The flush interval in milliseconds
            </summary>
        </member>
        <member name="M:LogUtils.TimedLogWriter.#ctor(System.Int32)">
            <summary>
            Constructs a TimedLogWriter instance
            </summary>
            <param name="writeInterval">The flush interval in milliseconds</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The flush interval is an invalid value</exception>
        </member>
        <member name="M:LogUtils.TimedLogWriter.Flush">
            <summary>
            Flushes the stream buffer to file
            </summary>
            <exception cref="T:System.ObjectDisposedException">The writer has been disposed</exception>
        </member>
        <member name="M:LogUtils.TimedLogWriter.ScheduleFlush">
            <summary>
            Attempts to flush the stream buffer to file on a .NET task thread
            </summary>
        </member>
        <member name="M:LogUtils.TimedLogWriter.TryFlush">
            <summary>
            Attempts to flush the stream buffer to file
            </summary>
        </member>
        <member name="M:LogUtils.TimedLogWriter.WriteToFile(LogUtils.Requests.LogRequest)">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.TimedLogWriter.AssignWriter(LogUtils.Enums.LogID,System.IO.StreamWriter@)">
            <inheritdoc/>
        </member>
        <member name="F:LogUtils.TimedLogWriter.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.TimedLogWriter.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.TimedLogWriter"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.TimedLogWriter.Dispose">
            <inheritdoc cref="M:LogUtils.TimedLogWriter.Dispose(System.Boolean)"/>
        </member>
        <member name="M:LogUtils.TimedLogWriter.Finalize">
            <summary/>
        </member>
        <member name="F:LogUtils.Timers.EventScheduler.scheduledEvents">
            <summary>
            Maintain a strong list of ScheduledEvents to prevent their associated FrameTimers from disposing
            </summary>
        </member>
        <member name="P:LogUtils.Timers.EventScheduler.Tag">
            <inheritdoc/>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.AddEvent(LogUtils.Timers.ScheduledEvent)">
            <summary>
            Adds a ScheduledEvent to be managed by the current instance
            </summary>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.AddTimer(LogUtils.Timers.FrameTimer)">
            <summary>
            Adds a timer to be managed by the current instance
            </summary>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.Schedule(System.Action,System.Int32,System.Int32)">
            <summary>
            Schedules an event delegate to be invoked periodically after a specified number of frames 
            </summary>
            <param name="action">The delegate to invoke</param>
            <param name="frameInterval">The number of frames in between event invocations</param>
            <param name="invokeLimit">The maximum number of invocations to attempt</param>
            <returns>An object containing the event state</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The frame interval is an invalid value</exception>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.Schedule(System.Action,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Schedules an event delegate to be invoked periodically after a specified number of frames 
            </summary>
            <param name="action">The delegate to invoke</param>
            <param name="frameInterval">The number of frames in between event invocations</param>
            <param name="syncToRainWorld">When true, event will be handled in MainLoopProcess.Update instead of through EventSceduler.Update</param>
            <param name="invokeLimit">The maximum number of invocations to attempt</param>
            <returns>An object containing the event state</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The frame interval is an invalid value</exception>
        </member>
        <member name="F:LogUtils.Timers.EventScheduler.IsDisposed">
            <summary/>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.Dispose(System.Boolean)">
            <summary>
            Performs tasks for disposing an <see cref="T:LogUtils.Timers.EventScheduler"/>
            </summary>
            <param name="disposing">Whether or not the dispose request is invoked by the application (true), or invoked by the destructor (false)</param>
        </member>
        <member name="M:LogUtils.Timers.EventScheduler.Dispose">
            <inheritdoc cref="M:LogUtils.Timers.EventScheduler.Dispose(System.Boolean)"/>
        </member>
        <member name="P:LogUtils.Timers.ScheduledEvent.InvokeCount">
            <summary>
            The number of times this event has been fired
            </summary>
        </member>
        <member name="F:LogUtils.Timers.ScheduledEvent.InvokeLimit">
            <summary>
            The amount of times event may be invoked
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.Event">
            <summary>
            Contains a reference to a ScheduledEvent for timers created by an EventScheduler
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.IsSynchronous">
            <summary>
            Should this timer be synced with the current RainWorld process or attempt to update on every available frame
            </summary>
        </member>
        <member name="P:LogUtils.Timers.FrameTimer.Released">
            <summary>
            The FrameTimer equivalent of a disposed flag
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.SyncHandler">
            <summary>
            Stores delegate information that will run when an synchronous event is handled
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.ElapsedTicks">
            <summary>
            Number of allowed frame updates since timer was last started
            </summary>
        </member>
        <member name="M:LogUtils.Timers.FrameTimer.Start">
            <summary>
            Allows frame counter to update
            </summary>
        </member>
        <member name="M:LogUtils.Timers.FrameTimer.Stop">
            <summary>
            Prevents frame counter from updating
            </summary>
        </member>
        <member name="M:LogUtils.Timers.FrameTimer.Release">
            <summary>
            Activate timer dispose procedure
            </summary>
        </member>
        <member name="M:LogUtils.Timers.FrameTimer.Restart">
            <summary>
            Resets frame counter back to zero and resumes updating the frame counter
            </summary>
        </member>
        <member name="F:LogUtils.Timers.FrameTimer.OnRelease">
            <summary>
            Invoked when a FrameTimer instance signals that it should no longer be updated by the scheduler
            </summary>
        </member>
        <member name="F:LogUtils.Timers.PollingTimer.Tag">
            <summary>
            Used to attach identifying information
            </summary>
        </member>
        <member name="F:LogUtils.Timers.PollingTimer.TrackingPollTime">
            <summary>
            Should the timer record the time of poll signals
            </summary>
        </member>
        <member name="F:LogUtils.Timers.PollingTimer.lastPollTime">
            <summary>
            The last time the timer was signaled (in ticks)
            </summary>
        </member>
        <member name="P:LogUtils.Timers.PollingTimer.PollFlagged">
            <summary>
            The poll state since the last elapsed time interval
            </summary>
        </member>
        <member name="E:LogUtils.Timers.PollingTimer.OnSignal">
            <summary>
            Activated when timer is signaled
            </summary>
        </member>
        <member name="E:LogUtils.Timers.PollingTimer.OnTimeout">
            <summary>
            Activated when an entire polling interval passes without receiving a poll signal
            </summary>
        </member>
        <member name="M:LogUtils.Timers.PollingTimer.#ctor(System.Double)">
            <summary>
            Constructs a PollingTimer
            </summary>
            <param name="checkInterval">The time window in which a polling flag must be set</param>
        </member>
        <member name="M:LogUtils.Timers.PollingTimer.Signal">
            <summary>
            Notifies the timer that it shouldn't raise an event on the next timed interval
            </summary>
        </member>
        <member name="M:LogUtils.Timers.PollingTimer.Start">
            <summary>
            Starts raising the System.Timers.Timer.Elapsed event by setting System.Timers.Timer.Enabled to true
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The System.Timers.Timer is created with an interval equal to or greater than
            System.Int32.MaxValue + 1, or set to an interval less than zero.</exception>
        </member>
        <member name="P:LogUtils.UtilityComponent.Version">
            <summary>
            The version of a component is the same as its assembly version. In the situation of multiple loaded assemblies,
            this version may not match other loaded assemblies
            </summary>
        </member>
        <member name="P:LogUtils.UtilityComponent.Tag">
            <summary>
            A tag used for identification purposes (Not the same field as Component.tag)
            </summary>
        </member>
        <member name="M:LogUtils.UtilityComponent.GetFields">
            <summary>
            Returns field values stored by the component using the field name as the key 
            </summary>
        </member>
        <member name="M:LogUtils.UtilityConsts.DataFields.IsRecognizedField(System.String)">
            <summary>
            Case sensitive comparison of a string against known utility DataFields
            </summary>
        </member>
        <member name="M:LogUtils.UtilityConsts.LogNames.NameMatch(System.String)">
            <summary>
            Evaluates whether given name is a match to a game log filename
            </summary>
        </member>
        <member name="F:LogUtils.UtilityCore.Build">
            <summary>
            The active build environment for the assembly
            </summary>
        </member>
        <member name="P:LogUtils.UtilityCore.IsControllingAssembly">
            <summary>
            The assembly responsible for loading core resources for the utility
            </summary>
        </member>
        <member name="P:LogUtils.UtilityCore.IsInitialized">
            <summary>
            The initialized state for the assembly. This does NOT indicate that another version of the assembly has initialized,
            and every assembly must go through the init process
            </summary>
        </member>
        <member name="P:LogUtils.UtilityCore.InitializedWithErrors">
            <summary>
            The initialized state encountered a problem during initialization
            </summary>
        </member>
        <member name="F:LogUtils.UtilityCore.initializingInProgress">
            <summary>
            The initialization process is in progress for the current assembly
            </summary>
        </member>
        <member name="F:LogUtils.UtilityCore.Config">
            <inheritdoc cref="T:LogUtils.Policy.UtilityConfig"/>
        </member>
        <member name="F:LogUtils.UtilityCore.DataHandler">
            <summary>
            Handles cross-mod data storage for the utility
            </summary>
        </member>
        <member name="F:LogUtils.UtilityCore.RequestHandler">
            <summary>
            Handles log requests between different loggers
            </summary>
        </member>
        <member name="M:LogUtils.UtilityCore.EnsureInitializedState">
            <summary>
            Ensures that core functionality is in a proper and useable state by ensuring the initialization procedure has run
            </summary>
        </member>
        <member name="M:LogUtils.UtilityCore.LoadComponents">
            <summary>
            Creates, or establishes a reference to an existing instance of necessary utility components
            </summary>
        </member>
        <member name="F:LogUtils.UtilityLogger.activityLogger">
            <summary>
            Activity logger is responsible for reporting file behavior associated with log related files
            </summary>
        </member>
        <member name="F:LogUtils.UtilityLogger.writeTask">
            <summary>
            Used to maintain the high performance write implementation
            </summary>
        </member>
        <member name="P:LogUtils.UtilityLogger.PerformanceMode">
            <summary>
            Enables a write buffer that intercepts all debug logs and writes them to file off the main thread
            </summary>
        </member>
        <member name="M:LogUtils.UtilityLogger.CreateLogger(System.String,LogUtils.Formatting.StringProvider)">
            <summary>
            Creates a logger that LogUtils can use to log to files directly (without using LogIDs, or the log request system) - not intended for users of LogUtils
            </summary>
        </member>
        <member name="M:LogUtils.UtilityLogSource.Dispose">
            <summary>
            Performs tasks for disposing a <see cref="T:LogUtils.UtilityLogSource"/>
            </summary>
        </member>
        <member name="M:PathComparer.CompareFilenameAndPath(System.String,System.String,System.Boolean)">
            <summary>
            Compares two paths (with or without a filename)
            </summary>
        </member>
        <member name="M:PathComparer.Compare(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:PathComparer.Equals(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:PathComparer.InternalCompare(System.String,System.String)">
            <summary>
            Assumes path info is being compared, not keywords
            </summary>
        </member>
        <member name="M:PathComparer.InternalEquals(System.String,System.String)">
            <summary>
            Assumes path info is being compared, not keywords
            </summary>
        </member>
    </members>
</doc>
